{
  "allSuites": [
    {
      "time": 878,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.http.conversion.ApiEntitiesConvertersSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "ApiEntitiesConverters should convert an AddConnectionAPIRequest to AddConnectionRequest",
          "classname": "io.lenses.flows.http.conversion.ApiEntitiesConvertersSpec",
          "time": 878,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 138,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.http.routes.release3_1.TemporaryHiddenValuesSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "filter connection templates by name, basing on whitelist should filter non-empty list",
          "classname": "io.lenses.flows.http.routes.release3_1.TemporaryHiddenValuesSpec",
          "time": 116,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "filter connection templates by name, basing on whitelist should filter empty list",
          "classname": "io.lenses.flows.http.routes.release3_1.TemporaryHiddenValuesSpec",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "filter connections by name, basing on template names whitelist should filter non-empty list",
          "classname": "io.lenses.flows.http.routes.release3_1.TemporaryHiddenValuesSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "filter connections by name, basing on template names whitelist should filter empty list",
          "classname": "io.lenses.flows.http.routes.release3_1.TemporaryHiddenValuesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 45,
      "tests": 45,
      "failures": 0,
      "errors": 0,
      "skipped": 45,
      "name": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "Posting azure credentials should return 201 for a valid create provider request",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 201 for a valid create provider request with default values",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 400 for a valid create provider request that fails credentials validation",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 404 when url doesn't match an existing one",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 400 when request body doesn't match the expected schema",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 400 when request body has missing fields",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 400 when request body is an invalid json string",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 400 when request body has an invalid field type",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 400 when request body has a missing field",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 415 for unsupported content type",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Posting azure credentials should return 400 when a credentials already exist",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Deleting azure credentials should return 200 OK for successful operation",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Deleting azure credentials should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Deleting azure credentials should return 404 when url doesn't match an existing one",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Deleting azure credentials should return 404 when a credentials does not exist",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Deleting azure credentials should return 409 when a credentials have connections assigned to it",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Deleting azure credentials should return 500 for exception",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Updating azure credentials should return 200 OK for successful operation",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Updating azure credentials should return 401 for unathenticated request",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Updating azure credentials should return 404 when url doesn't match an existing one",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Updating azure credentials should return 404 when a credentials does not exist",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Updating azure credentials should return 500 for exception",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Updating azure credentials should return 400 when request body doesn't match the expected schema",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Updating azure credentials should return 400 when request body has missing fields",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Updating azure credentials should return 400 when request body is an invalid json string",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Updating azure credentials should return 415 for unsupported content type",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Listing all credentials should return 200 and an Empty list for a valid GET providers request when there is no previous records",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Listing all credentials should return 200 for a valid GET providers request",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Listing all credentials should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Listing all credentials should return 500 for exception",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Getting azure credentials should return 404 for a non existing credentials",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Getting azure credentials should return 200 for an existent credentials provider",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Getting azure credentials should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Getting azure credentials should return 500 for exception",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Validating credentials should return 200 when successfully got credentials validation result",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Validating credentials should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Validating credentials should return 404 for a non existing credentials",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Validating credentials should return 500 for exception",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Validating all credentials should return 200 with success response when successfully got credentials validation result",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Validating all credentials should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Validating all credentials should return 500 for exception",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Listing all key vaults should return 200 with success response when successfully got key vaults",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Listing all key vaults should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "Listing all key vaults should return 500 for exception",
          "classname": "io.lenses.flows.http.routes.CredentialsRoutesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        }
      ]
    },
    {
      "time": 1041,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.http.serde.CredentialsJsonSerdeSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "JsonSerdeTest should Serializes an enumeration as String",
          "classname": "io.lenses.flows.http.serde.CredentialsJsonSerdeSpec",
          "time": 962,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TemplateCategory Serialization/Deserialization should work in both ways",
          "classname": "io.lenses.flows.http.serde.CredentialsJsonSerdeSpec",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionPropertyType Serialization/Deserialization should work in both ways",
          "classname": "io.lenses.flows.http.serde.CredentialsJsonSerdeSpec",
          "time": 33,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 693,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.http.routes.RoutesBaseSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "RoutesBaseSpec can define namespace routes prefixes should define deployment namespace route prefix",
          "classname": "io.lenses.flows.http.routes.RoutesBaseSpec",
          "time": 685,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RoutesBaseSpec can define namespace routes prefixes should define connection namespace route prefix",
          "classname": "io.lenses.flows.http.routes.RoutesBaseSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RoutesBaseSpec can define namespace routes prefixes should define security namespace route prefix",
          "classname": "io.lenses.flows.http.routes.RoutesBaseSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 4816,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.http.routes.ConnectionTemplateRoutesSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "Listing all connection templates should return 200 for a valid GET connection templates request",
          "classname": "io.lenses.flows.http.routes.ConnectionTemplateRoutesSpec",
          "time": 2364,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "1",
          "classname": "io.lenses.flows.http.routes.ConnectionTemplateRoutesSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Listing all connection templates should always return all fields in response entity - including ones with null values",
          "classname": "io.lenses.flows.http.routes.ConnectionTemplateRoutesSpec",
          "time": 958,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Listing all connection templates should decode connection template in proper way",
          "classname": "io.lenses.flows.http.routes.ConnectionTemplateRoutesSpec",
          "time": 1457,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Listing all connection templates should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.ConnectionTemplateRoutesSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Listing all connection templates should return 500 for an exception",
          "classname": "io.lenses.flows.http.routes.ConnectionTemplateRoutesSpec",
          "time": 22,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 11285,
      "tests": 50,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "Creating connections should return 201 for a valid create connection request",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 1830,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should return 400 for a valid create connection request that fails validation",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 582,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 68,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should return 404 when url doesn't match an existing one",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 241,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should return 400 when request body doesn't match the expected schema",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 131,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should return 400 when request body has missing fields",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 566,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should return 400 when request body is an invalid json string",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should return 400 when request body has an invalid field type",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 34,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should return 400 when connection name has invalid value",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 473,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should return 415 for unsupported content type",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 36,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should return 400 when a connection already exist",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Creating connections should be authorized with ManageConnectionAction",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 938,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Listing all connections should return all connections with the status 200 OK",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 391,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "1",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Listing all connections should always return all fields in response entity - including ones with null values",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 322,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Listing all connections should return status 401 Unauthorized for missing token",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Listing all connections should return status 401 Unauthorized for invalid token",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Listing all connections should return 500 for an exception",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Listing all connections should be authorized with ViewConnectionAction",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 58,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Deleting connection should connection id with the status 200 OK for existing connection",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 362,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Deleting connection should connection id with the status 404 BadRequest for an invalid connection name",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 366,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Deleting connection should pass deletion strategy to the connections manager",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 408,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Deleting connection should return status 401 Unauthorized for missing token",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 217,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Deleting connection should return status 401 Unauthorized for invalid token",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 235,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Deleting connection should return status 404 Not Found for unknown connection id",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 281,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Deleting connection should return status 409 Conflict when connection is read only",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 353,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Deleting connection should return status 409 Conflict when connection is in use",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 326,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Deleting connection should return 500 for an exception",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 331,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Deleting connection should be authorized with ManageConnectionAction",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 41,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting connection details should return 404 for a non existing connection",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting connection details should return 404 for an invalid connection name",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 41,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting connection details should return 200 for an existent connection",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting connection details should always return all fields in response entity - including ones with null values",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 360,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting connection details should return non-empty array for `configuration` for users permitted to ViewConnectionSecretsAction",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 367,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting connection details should return empty array for `configuration` for users NOT permitted to ViewConnectionSecretsAction",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 261,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting connection details should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 35,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting connection details should return 500 for exception",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting connection details should be authorized with ViewConnectionAction",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 102,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 200 for a valid PUT connection request",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 359,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 400 for a valid create connection request that fails validation",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 346,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 401 for unauthenticated request",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 404 when url doesn't match an existing one",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 400 when request body doesn't match the expected schema",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 400 when request body has missing fields",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 266,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 400 when request body is an invalid json string",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 400 when request body has an invalid field type",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 409 Conflict for an attempt to patch read-only connection",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 304,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 415 for unsupported content type",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should return 400 when a DB constraint is broken",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 22,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Updating connections should be authorized with ManageConnectionAction",
          "classname": "io.lenses.flows.http.routes.ConnectionRoutesSpec",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2160,
      "tests": 16,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "adding connection should pass proper parameters to all its functions",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 1320,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should rollbacks when client call fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 75,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should succeed when all steps succeed",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 42,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should fail when storing fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should do not store into secrets provider if storing fails (can happen when name is already used)",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should fail when adding to secrets provider fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should fail when getting credentials client fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should error when credentials client returns InvalidStorageUrl",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 464,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should error when credentials client returns UnexpectedError",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should error when credentials client returns InvalidProperties",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should fail when getting template fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should fail when credentials properties are invalid",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 56,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should fail when an invalid templateName is provided",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should fail when an invalid credentialsName is provided",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should fail with both errors when an invalid templateName and credentialsName are provided",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding connection should fail with both errors when both credentials and property are invalid",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionAddSpec",
          "time": 82,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 391,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.conversion.CredentialsConversionsSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "Lenses-kv credentials conversion should convert Lenses Credentials to class required by store",
          "classname": "io.lenses.flows.secrets.credentials.conversion.CredentialsConversionsSpec",
          "time": 57,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Lenses-kv credentials conversion should always succeed reversion",
          "classname": "io.lenses.flows.secrets.credentials.conversion.CredentialsConversionsSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Azure credentials conversion should convert AzureCredentials to AzureCredentialsDetails",
          "classname": "io.lenses.flows.secrets.credentials.conversion.CredentialsConversionsSpec",
          "time": 273,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Azure credentials conversion should convert AzureCredentialsDetails to AzureCredentials",
          "classname": "io.lenses.flows.secrets.credentials.conversion.CredentialsConversionsSpec",
          "time": 59,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 138,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.connection.management.PersistentConnectionsGetSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "listing connections should return a list of stored connections",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionsGetSpec",
          "time": 129,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "listing connections should fail for failure",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionsGetSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 215,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.connection.config.KafkaConnectionSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "KafkaConnection to connection properties should generate list of connection properties",
          "classname": "io.lenses.flows.connection.config.KafkaConnectionSpec",
          "time": 215,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 206,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultClientSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "LensesKeyVaultClient should always return successful validation",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultClientSpec",
          "time": 119,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesKeyVaultClient should return lenses resource as only key vault",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultClientSpec",
          "time": 87,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 4531,
      "tests": 25,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.init.LensesConfigSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "kafkaConfig should remove white characters from kubernetes brokers",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 1524,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "client when it is defined amalgamating with default settings when it exists",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 696,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kafkaConfig should use producer or amalgamate producer and consumer (and default) kafka settings when there is no client",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 561,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kafkaConfig should use consumer settings (with optional default) when it is defined and other kafka configurations are missing",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 203,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kafkaConfig should use default security settings when it is defined and others are missing",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 192,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kafkaConfig should use no security settings when security configuration is missing",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kafkaConfig should get SASL from Lenses config if defined wrapping it in kafka client context",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 175,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kafkaConfig should get SASL from JAAS file (via system properties) without wrapping the value",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 151,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kafkaConfig should get SASL from Lenses config if defined both in config and passed via props wrapping the value",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 170,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kafkaConfig should use no SASL if not configured",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 97,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kafkaConfig should get keytab path from jaas file and ignore comments",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kafkaConfig should get keytab from a random string",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "schemaRegistryConfig should parse schema registry configuration",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 217,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "schemaRegistryConfig should get SASL when defined only in configuration and wrap it in Schema Registry context",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 92,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "schemaRegistryConfig should get SASL from JAAS file (via system properties) when there is no sasl defined in config",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 105,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "schemaRegistryConfig should get SASL from Lenses config if defined both in config and passed via props",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 138,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "schemaRegistryConfig should fail if jaas file defined in config does not exist",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 75,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "schemaRegistryConfig should fail when IO reading jaas file defined in config fails",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kerberosConfig should return kerberos configuration when it is defined in Lenses config",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 56,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kerberosConfig should return kerberos configuration when it is not defined in Lenses config but is defined as java property",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 30,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kerberosConfig should return no kerberos settings when it is not configured",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kerberosConfig should fail if krb5 file defined in config does not exist",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kerberosConfig should fail when IO reading krb5 file defined in config fails",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kerberosConfig should fail if krb5 file defined in env property does not exist",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "kerberosConfig should fail when IO reading krb5 file defined in env property fails",
          "classname": "io.lenses.flows.init.LensesConfigSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1598,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.validation.TypedParameterSpec",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "stringToTypedParameter should convert string to ParameterStr",
          "classname": "io.lenses.flows.validation.TypedParameterSpec",
          "time": 1448,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "stringToTypedParameter should fail to convert empty string to ParameterStr",
          "classname": "io.lenses.flows.validation.TypedParameterSpec",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "stringToTypedParameter should convert double to ParameterDouble",
          "classname": "io.lenses.flows.validation.TypedParameterSpec",
          "time": 40,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "stringToTypedParameter should convert long to ParameterLong",
          "classname": "io.lenses.flows.validation.TypedParameterSpec",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "stringToTypedParameter should fail to convert not a double to ParameterDouble",
          "classname": "io.lenses.flows.validation.TypedParameterSpec",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "stringToTypedParameter should fail to convert not a long number to ParameterLong",
          "classname": "io.lenses.flows.validation.TypedParameterSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "stringToTypedParameter should convert boolean to ParameterBool",
          "classname": "io.lenses.flows.validation.TypedParameterSpec",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "stringToTypedParameter should fail to convert not a boolean to ParameterBool",
          "classname": "io.lenses.flows.validation.TypedParameterSpec",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "stringToTypedParameter should convert array to ParameterStrArray",
          "classname": "io.lenses.flows.validation.TypedParameterSpec",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "stringToTypedParameter should fail to convert empty string to ParameterStrArray",
          "classname": "io.lenses.flows.validation.TypedParameterSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1095,
      "tests": 16,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "patching connection should pass proper parameters to all its functions",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 846,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should succeed when all steps succeed",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 25,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should fail when connection is read only",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should succeed when connection is read only and the mode is force update",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should fail when storing fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should do not store into secrets provider if storing fails (can happen when name is already used)",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should fail when adding to secrets provider fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should fail when getting credentials client fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should error when credentials client returns error",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should fail when getting template fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should fail when the connection we want to patch has a linked credentials with invalid properties",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should fail when the connection we want to patch has an invalid templateName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should fail when an invalid credentialsName is provided",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 29,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should fail with both errors when an invalid templateName and credentialsName are provided",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should fail with both errors when both credentials and property are invalid",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 63,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patching connection should return None when patching a non existing connection",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionPatchSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 13,
      "tests": 13,
      "failures": 0,
      "errors": 0,
      "skipped": 13,
      "name": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "adding connection should generate proper key, tags and values out of the input",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "adding connection should use only last value if there are duplicated keys",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "adding connection should handle UnknownHostException",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "adding connection should propagate unknown exception",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "getting a connection should generate proper key, tags and values out of the input",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "getting a connection should ignore not found properties",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "getting a connection should handle UnknownHostException",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "getting a connection should propagate unknown exception",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "deleting a connection should generate proper key, tags and values out of the input",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "deleting a connection should ignore not found properties",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "deleting a connection should handle UnknownHostException",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "deleting a connection should propagate unknown exception",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "updating connection should call secret client's updateWithPrune method",
          "classname": "io.lenses.flows.connection.client.ConnectionSecretsClientSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        }
      ]
    },
    {
      "time": 419,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.lenseskv.SecretEncryptionSpec",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "encrypt should encrypt secret value using provided encryption, keep remaining fields unchanged",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.SecretEncryptionSpec",
          "time": 323,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "decrypt should decrypt encrypted secret value using provided encryption, keep remaining fields unchanged",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.SecretEncryptionSpec",
          "time": 58,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "decrypt should return none when decryption fails",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.SecretEncryptionSpec",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1118,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.template.management.PersistentConnectionTemplateManagementSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "getting connection types should return a list of ConnectionTemplateResponse",
          "classname": "io.lenses.flows.template.management.PersistentConnectionTemplateManagementSpec",
          "time": 731,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection types should sort configurations by id",
          "classname": "io.lenses.flows.template.management.PersistentConnectionTemplateManagementSpec",
          "time": 388,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 116,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.encryption.AesEncryptionSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "AES-256 Encryption should not be created for invalid key length",
          "classname": "io.lenses.flows.encryption.AesEncryptionSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AES-256 Encryption should not be able to decrypt message for uncrecognized key",
          "classname": "io.lenses.flows.encryption.AesEncryptionSpec",
          "time": 51,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AES-256 Encryption should decrypt encrypted text",
          "classname": "io.lenses.flows.encryption.AesEncryptionSpec",
          "time": 37,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AES-256 Encryption should encrypt text prefixing initialization vector with space-separator",
          "classname": "io.lenses.flows.encryption.AesEncryptionSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AES-256 Encryption should encrypt same text into 2 different values ignoring prefixing initialization vector",
          "classname": "io.lenses.flows.encryption.AesEncryptionSpec",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 17,
      "tests": 17,
      "failures": 0,
      "errors": 0,
      "skipped": 17,
      "name": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "CredentialsValidationState should validate credentials on add",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "CredentialsValidationState should return failure when validating fails with exception on add",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "CredentialsValidationState should return failure when validating fails with an AskTimeoutException on add",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "CredentialsValidationState should update credentials validation periodically",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "CredentialsValidationState should keep checking state regardless of failures",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "CredentialsValidationState should fail validation on validation failure",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "CredentialsValidationState should bring back validation removed after validation failure when validation works again",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "CredentialsValidationState should remove credentials cache and stop refreshing on remove",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "CredentialsValidationState should do not add removed credentials when validation response comes after removal",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "CredentialsValidationState should return key vaults for all added credentials",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "CredentialsValidationState should ignore stores failing to get key vaults",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "getting connection client should fail when credentials cannot be found by provided id",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "getting connection client should succeed when credentials are found",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "getting connection client should returns empty option when we timeout to fetch it",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "removing a connection client should elevate the exception if something goes wrong",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "getting cached connections should return an empty value if something goes wrong",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "getting key-vaults should return an empty value if something goes wrong",
          "classname": "io.lenses.flows.secrets.credentials.state.CredentialsClientsSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        }
      ]
    },
    {
      "time": 1483,
      "tests": 14,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
      "timestamp": "2020-09-11T09:13:32",
      "testcase": [
        {
          "name": "adding new connection should log audit when successful",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 178,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding new connection should not log audit when IO failed",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 99,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding new connection should not log audit when failed",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 174,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating connection should log audit when successful",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 127,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating connection should not log audit when IO failed",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 91,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating connection should not log audit when failed",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 255,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating connection should not log audit when connection was not found",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 112,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should log audit when successful",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 62,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should not log audit when IO failed",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 48,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should not log audit when failed",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 70,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should not log audit when connection was not found",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 62,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting a connection should log audit when successful",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 190,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting a connection should not log audit when connection is not found",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting a connection should not log audit when IO failed",
          "classname": "io.lenses.flows.connection.management.AuditedConnectionManagementSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 46,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.conversion.CredentialsTypeSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "Conversion from CredentialDetails to CredentialsType should work for AzureCredentialDetails",
          "classname": "io.lenses.flows.secrets.credentials.conversion.CredentialsTypeSpec",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Conversion from CredentialDetails to CredentialsType should work for LensesCredentials",
          "classname": "io.lenses.flows.secrets.credentials.conversion.CredentialsTypeSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 884,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.managment.HideLensesKVCredentialsManagementSpec",
      "timestamp": "2020-09-11T09:13:32",
      "testcase": [
        {
          "name": "CredentialsFeatureSwitch should remove lenses kv credentials from listAll response",
          "classname": "io.lenses.flows.secrets.credentials.managment.HideLensesKVCredentialsManagementSpec",
          "time": 458,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CredentialsFeatureSwitch should not return lenses kv credentials on getById",
          "classname": "io.lenses.flows.secrets.credentials.managment.HideLensesKVCredentialsManagementSpec",
          "time": 41,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CredentialsFeatureSwitch should not return lenses kv credentials on getByName",
          "classname": "io.lenses.flows.secrets.credentials.managment.HideLensesKVCredentialsManagementSpec",
          "time": 103,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CredentialsFeatureSwitch should not find lenses kv credentials on update",
          "classname": "io.lenses.flows.secrets.credentials.managment.HideLensesKVCredentialsManagementSpec",
          "time": 83,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CredentialsFeatureSwitch should not find lenses kv credentials on delete",
          "classname": "io.lenses.flows.secrets.credentials.managment.HideLensesKVCredentialsManagementSpec",
          "time": 37,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CredentialsFeatureSwitch should not find lenses kv credentials on validationFor",
          "classname": "io.lenses.flows.secrets.credentials.managment.HideLensesKVCredentialsManagementSpec",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CredentialsFeatureSwitch should remove lenses kv credentials from allValidations response",
          "classname": "io.lenses.flows.secrets.credentials.managment.HideLensesKVCredentialsManagementSpec",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CredentialsFeatureSwitch should remove lenses kv credentials from keyVaults response",
          "classname": "io.lenses.flows.secrets.credentials.managment.HideLensesKVCredentialsManagementSpec",
          "time": 87,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 5151,
      "tests": 12,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "adding credentials should succeed for valid credentials",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 542,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding credentials should succeed for invalid credentials and validation off",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 244,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding credentials should fail for invalid credentials and validation on",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 47,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should succeed for valid credentials and validation on",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 270,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should succeed for invalid credentials and validation off",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 259,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should fail for invalid credentials and validation on",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 52,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "credentials validation should be refreshed periodically and obtained by get all",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 1049,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "credentials validation should be refreshed periodically and obtained by validate call",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 308,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "credentials validation should be updated on updating credentials",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 742,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "credentials validation should be updated on removing credentials",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 628,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "credentials validation should not be removed when credentials removing fails with domain rejection",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 732,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "key vaults should return key vaults returned by the client",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsConnectionManagementSpec",
          "time": 276,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1172,
      "tests": 14,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "adding new credentials should log audit when successful",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 91,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding new credentials should not log audit when IO failed",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 30,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding new credentials should not log audit when failed",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 64,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should log audit when successful",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 171,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should log modified properties",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 156,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should log removed properties",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 244,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should not log audit when IO failed",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 142,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should not log audit when failed",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 97,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should not log audit when credentials were not found",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 49,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should not log audit when credentials were not found when updating",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 72,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting credentials should log audit when successful",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting credentials should not log audit when IO failed",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting credentials should not log audit when credentials were not found",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting credentials should not log audit when credentials validation failed",
          "classname": "io.lenses.flows.secrets.credentials.managment.CredentialsAuditsSpec",
          "time": 27,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1812,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.azure.AzureClientSpec",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "validateAzure should succeed when able to get subscriptions",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureClientSpec",
          "time": 1400,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateAzure should fail when getting subscriptions fails",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureClientSpec",
          "time": 28,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateAzure should succeed when subscription id can be found",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureClientSpec",
          "time": 338,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateAzure should fail when subscription with requested id can not be found",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureClientSpec",
          "time": 47,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 46,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.util.FileHelperSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "FileHelper should store base64 content into the file and decode it back",
          "classname": "io.lenses.flows.util.FileHelperSpec",
          "time": 37,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FileHelper should read string file content",
          "classname": "io.lenses.flows.util.FileHelperSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1356,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.azure.AzureCallbackSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "future should succeed for callback succeeding",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureCallbackSpec",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "future should fail for callback failing",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureCallbackSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "future should return result of provided function",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureCallbackSpec",
          "time": 249,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "listIO should return successful IO when callback succeeds",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureCallbackSpec",
          "time": 182,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "listIO should fail IO when callback fails",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureCallbackSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "listIO should fail for passed function throwing exception",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureCallbackSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "listIO should be thread safe",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureCallbackSpec",
          "time": 914,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 128,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.encryption.InitializationVectorSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "InitializationVector should generate bytes array of non zero length",
          "classname": "io.lenses.flows.encryption.InitializationVectorSpec",
          "time": 37,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "InitializationVector should different byte arrays",
          "classname": "io.lenses.flows.encryption.InitializationVectorSpec",
          "time": 27,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "InitializationVector should add generated bytes to provided string",
          "classname": "io.lenses.flows.encryption.InitializationVectorSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "InitializationVector should wrk",
          "classname": "io.lenses.flows.encryption.InitializationVectorSpec",
          "time": 39,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "InitializationVector should be able to extract initialization vector from prefixed text",
          "classname": "io.lenses.flows.encryption.InitializationVectorSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "InitializationVector should not extract initialization vector from text when space separator is missing",
          "classname": "io.lenses.flows.encryption.InitializationVectorSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 80,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.util.Base64StringSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "toBytes should return initial base64 bytes",
          "classname": "io.lenses.flows.util.Base64StringSpec",
          "time": 31,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromString should decode valid string into bytes",
          "classname": "io.lenses.flows.util.Base64StringSpec",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromString should fail for too short string",
          "classname": "io.lenses.flows.util.Base64StringSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromString should fail for invalid string",
          "classname": "io.lenses.flows.util.Base64StringSpec",
          "time": 27,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1764,
      "tests": 12,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "getting connection should pass proper parameters to all its functions",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 1388,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should succeed when all steps succeed for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 55,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should fail when getting connection fails for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 25,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should fail when getting connection from store fails for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should return None when credentials store finds no connection for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should fail when secrets provider fails for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 21,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should fail when getting connections client fails for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 27,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should error when credentials client returns error for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 20,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should fail when getting getting template fails for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should fail when transformation fails for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 128,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should fail when getting connection has empty storage url for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting connection should fail when getting connection has empty name defined for getByName",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionGetSpec",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 493,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.encryption.CredentialsEncryptionSpec",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "LensesKVCredentials CredentialsEncryption should return input when encrypting",
          "classname": "io.lenses.flows.secrets.credentials.encryption.CredentialsEncryptionSpec",
          "time": 55,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesKVCredentials CredentialsEncryption should return input when decrypting",
          "classname": "io.lenses.flows.secrets.credentials.encryption.CredentialsEncryptionSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AzureCredentials CredentialsEncryption should modify all fields of credentials according to encryption provided",
          "classname": "io.lenses.flows.secrets.credentials.encryption.CredentialsEncryptionSpec",
          "time": 299,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AzureCredentials CredentialsEncryption should modify all fields of credentials according to decryption provided",
          "classname": "io.lenses.flows.secrets.credentials.encryption.CredentialsEncryptionSpec",
          "time": 101,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AzureCredentials CredentialsEncryption should return none for decryption returning none",
          "classname": "io.lenses.flows.secrets.credentials.encryption.CredentialsEncryptionSpec",
          "time": 36,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1043,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.azure.AzureSecretsClientSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "set a secret should fail for callback failing",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureSecretsClientSpec",
          "time": 573,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "set a secret should succeed for callback succeeding",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureSecretsClientSpec",
          "time": 287,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get a secret should fail for callback failing",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureSecretsClientSpec",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get a secret should succeed for callback succeeding",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureSecretsClientSpec",
          "time": 51,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "delete a secret should fail for callback failing",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureSecretsClientSpec",
          "time": 67,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "delete a secret should succeed for callback succeeding",
          "classname": "io.lenses.flows.secrets.credentials.azure.AzureSecretsClientSpec",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 17093,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "AddConnectionRequestTransformation should transform add connection request into typed parameters",
          "classname": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
          "time": 8880,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AddConnectionRequestTransformation should fail when all mandatory fields are missing",
          "classname": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
          "time": 1562,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AddConnectionRequestTransformation should fail for invalid enum value",
          "classname": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
          "time": 6205,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AddConnectionRequestTransformation should throw exception for parameter of type enum with no enum values defined",
          "classname": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
          "time": 425,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AddConnectionRequestTransformation should success when configuration keys follows format rules",
          "classname": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AddConnectionRequestTransformation should success when an optional configuration key is missing",
          "classname": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AddConnectionRequestTransformation should fail with proper error when a mandatory field is missing",
          "classname": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AddConnectionRequestTransformation should fail with proper error when a valid numeric key contains a non numeric string",
          "classname": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AddConnectionRequestTransformation should fail with proper error when a valid boolean key contains a non boolean string",
          "classname": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AddConnectionRequestTransformation should fail with proper error when an invalid field is provided",
          "classname": "io.lenses.flows.connection.management.common.ConnectionParametersTransformationSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1214,
      "tests": 11,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "adding credentials should succeed for successful store update",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 138,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "adding credentials should encrypt credentials",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 129,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should succeed for successful store update",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 122,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating credentials should encrypt credentials",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 81,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting credentials should succeed for successful store update",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 21,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting credentials should fail and return assigned connections if they exist",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 54,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting credentials should fail IO for unknown constraint validation error",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 34,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting all credentials should return transformed credentials",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 167,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting credential by name should return transformed credentials if found or None",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 181,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting credential by name should decrypt credentials",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 163,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getting credential by name should decrypt credentials should fail for decrypting failing",
          "classname": "io.lenses.flows.secrets.credentials.managment.PersistentCredentialsManagementSpec",
          "time": 123,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 48,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.util.RefinedValidatorSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "expectNonEmptyString should validate non empty string",
          "classname": "io.lenses.flows.util.RefinedValidatorSpec",
          "time": 33,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "expectNonEmptyString should invalidate empty string",
          "classname": "io.lenses.flows.util.RefinedValidatorSpec",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2936,
      "tests": 16,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "deleting connection should pass proper parameters to all its functions",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 1332,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should succeed when all steps succeed",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 108,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should skip removing read only connection",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 58,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should succeed to remove read only connection when the update mode is force",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 137,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should delete from credentials provider when DeleteFromSecretsProvider strategy is passed",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 126,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should do not delete from credentials provider when KeepInSecretsProvider strategy is passed",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 67,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should translate store ConstraintViolationError to ConnectionUsedError",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 234,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should fail when getting connection from store fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 115,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should return None when credentials store finds no connection",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 77,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should not delete secrets from provider when store deletion finds no connection",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 93,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should fail when secrets provider fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 177,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should fail when getting connections client fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 103,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should error when credentials client returns error",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 62,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should fail when getting getting template fails",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 93,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should fail when getting connection has empty storage url",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 79,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting connection should fail when getting connection has empty name defined",
          "classname": "io.lenses.flows.connection.management.PersistentConnectionDeleteSpec",
          "time": 76,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1039,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultSecretsClientSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "set secret should fail when store function is failing",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultSecretsClientSpec",
          "time": 225,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "set secret should succeed when store function succeeds",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultSecretsClientSpec",
          "time": 233,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "set secret should encode secret value",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultSecretsClientSpec",
          "time": 238,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get secret should return decoded store response",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultSecretsClientSpec",
          "time": 108,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get secret should fail for failing store",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultSecretsClientSpec",
          "time": 30,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get secret should fail when unable to decode store response",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultSecretsClientSpec",
          "time": 94,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "removing secret should return store response",
          "classname": "io.lenses.flows.secrets.credentials.lenseskv.LensesKeyVaultSecretsClientSpec",
          "time": 112,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1025,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.conversion.CredentialsConvertersSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "CredentialsConverters should convert a AddAzureCredentials in a valid CredentialsProvider instance",
          "classname": "io.lenses.flows.secrets.credentials.conversion.CredentialsConvertersSpec",
          "time": 132,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CredentialsConverters should convert a CredentialsProvider in a valid CredentialsResponse instance",
          "classname": "io.lenses.flows.secrets.credentials.conversion.CredentialsConvertersSpec",
          "time": 548,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CredentialsConverters should convert a AzureProvider in a valid ServicePrincipalResponse instance",
          "classname": "io.lenses.flows.secrets.credentials.conversion.CredentialsConvertersSpec",
          "time": 345,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 5861,
      "tests": 29,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "JaasHelperSpec.jaas from java props for KafkaClient should get JAAS config from Java security conf",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JaasHelperSpec.jaas from java props for KafkaClient should return no JAAS config if JAAS is not provided via file",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JaasHelperSpec.jaas from java props for RegistryClient should get JAAS config from Java security conf",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JaasHelperSpec.jaas from java props for RegistryClient should return no JAAS config if JAAS is not provided via file",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JaasHelperSpec.wrap provided string in proper KafkaClient jaas section should get KafkaClient JAAS from Java security conf",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JaasHelperSpec.wrap provided string in proper RegistryClient jaas section should get RegistryClient JAAS from Java security conf",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JaasHelperSpec.flagSimpleName should return the simple name of a module control flag",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KerberosHelperSpec.krb5 path from java env should return krb5 path when it is defined in proper Java property",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KerberosHelperSpec.krb5 path from java env should return None when it is not defined in proper Java property",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.kafka connection should be created when it is missing in store",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 929,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.kafka connection should fail creation when it is missing in configuration",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 74,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.kafka connection should be updated when it is found in store and is different than configured one",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 264,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.kafka connection should be kept when it is found in store and is equal to configured one",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 225,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.schema registry connection should be created when it is missing in store",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 244,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.schema registry connection should be kept when it is found in store and is no different than configured one",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 137,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.schema registry connection should be updated when it is found in store and is different than configured one",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 320,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.schema registry connection should be deleted when it is missing in configuration",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 326,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.kerberos connection should be created when it is missing in store",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 212,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.kerberos connection should remain not existing when it is not found in store and is not configured",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 107,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.kerberos connection should be kept when it is found in store and is no different than configured one",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 114,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.kerberos connection should be updated when it is found in store and is different than configured one",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 136,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsInitSpec.kerberos connection should be deleted when it is missing in configuration",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 145,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSpec.adding credentials should succeed for successful store update, fail for invalid credentials when requiring validation",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 217,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSpec.updating credentials should succeed for successful store update, fail for invalid credentials when requiring validation",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 95,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSpec.deleting credentials should succeed for successful store delete",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 116,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSpec.getting all credentials should return credentials matching to the credentials found in store",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 294,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSpec.getting credentials by id should return credentials if found",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 44,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSpec.getting credentials by name should return credentials if found",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 49,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSpec.credentials validation should be updated periodically by credentials client",
          "classname": "io.lenses.flows.JavaSecuritySystemPropertyFragileSpecs",
          "time": 1760,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1316,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.connection.conversion.ConnectionConvertersSpec",
      "timestamp": "2020-09-11T09:13:33",
      "testcase": [
        {
          "name": "ConnectionConverters should convert a AddConnectionRequest in a valid NewConnection instance",
          "classname": "io.lenses.flows.connection.conversion.ConnectionConvertersSpec",
          "time": 830,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionConverters should convert a TaggedConnectionSummary into ConnectionSummaryResponse instance",
          "classname": "io.lenses.flows.connection.conversion.ConnectionConvertersSpec",
          "time": 134,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionConverters should convert a ConnectionResponse into TaggedConnection instance",
          "classname": "io.lenses.flows.connection.conversion.ConnectionConvertersSpec",
          "time": 352,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1476,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.template.conversion.ConnectionTemplateConvertersSpec",
      "timestamp": "2020-09-11T09:13:31",
      "testcase": [
        {
          "name": "ConnectionTypeDetails in a valid ConnectionTemplateResponse instance",
          "classname": "io.lenses.flows.template.conversion.ConnectionTemplateConvertersSpec",
          "time": 766,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionConfigKey in a valid ConnectionProperty instance",
          "classname": "io.lenses.flows.template.conversion.ConnectionTemplateConvertersSpec",
          "time": 710,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 143,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.connection.config.SchemaRegistryConnectionSpec",
      "timestamp": "2020-09-11T09:13:34",
      "testcase": [
        {
          "name": "SchemaRegistryConnection to connection properties should generate list of connection properties",
          "classname": "io.lenses.flows.connection.config.SchemaRegistryConnectionSpec",
          "time": 143,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1819,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.flows.secrets.credentials.client.SecretsClientSimpleUpsertSpec",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "SecretsClientSimpleUpsert should delete obsolete keys and set existing ones",
          "classname": "io.lenses.flows.secrets.credentials.client.SecretsClientSimpleUpsertSpec",
          "time": 1819,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 48,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseZkAlertsFnTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "RaiseZkAlertsFn should raise an alert when the ZK is down",
          "classname": "io.lenses.core.monitoring.actions.RaiseZkAlertsFnTest",
          "time": 44,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseZkAlertsFn should not raise the alert more than once",
          "classname": "io.lenses.core.monitoring.actions.RaiseZkAlertsFnTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseZkAlertsFn should raise an alert when the one ZK node is online and another one is down",
          "classname": "io.lenses.core.monitoring.actions.RaiseZkAlertsFnTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 227,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.ChannelLicenseChecksTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "ChannelLicenseChecksTest should check maximum number of alert channels when maximum number not reached",
          "classname": "io.lenses.core.channels.ChannelLicenseChecksTest",
          "time": 215,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelLicenseChecksTest should check maximum number of alert channels when maximum number reached",
          "classname": "io.lenses.core.channels.ChannelLicenseChecksTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelLicenseChecksTest should check allowed channel integration when trying to create new channel with allowed name/type",
          "classname": "io.lenses.core.channels.ChannelLicenseChecksTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelLicenseChecksTest should check allowed channel integration when trying to create new channel with disabled name/type",
          "classname": "io.lenses.core.channels.ChannelLicenseChecksTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelLicenseChecksTest should check allowed channel integration when trying to create new channel when there is no restriction on name/type",
          "classname": "io.lenses.core.channels.ChannelLicenseChecksTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 20,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.ConnectorsRepositoryImplTest",
      "timestamp": "2020-09-11T09:14:09",
      "testcase": [
        {
          "name": "ConnectorsRepositoryImpl should return None if the cluster is not present",
          "classname": "io.lenses.core.kafka.ConnectorsRepositoryImplTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectorsRepositoryImpl should handles a remove even if the connector is not present",
          "classname": "io.lenses.core.kafka.ConnectorsRepositoryImplTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectorsRepositoryImpl should return None if the connector config is not understood",
          "classname": "io.lenses.core.kafka.ConnectorsRepositoryImplTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectorsRepositoryImpl should adds the connector to the repo",
          "classname": "io.lenses.core.kafka.ConnectorsRepositoryImplTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectorsRepositoryImpl should adds the connector and remove it",
          "classname": "io.lenses.core.kafka.ConnectorsRepositoryImplTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 65329,
      "tests": 11,
      "failures": 3,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.TopicCommandTest",
      "timestamp": "2020-09-11T09:14:07",
      "testcase": [
        {
          "name": "type is not CreateTime or LogAppendTime",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "createTopic should create a topic with compact cleanup policy",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 20011,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.core.kafka.TopicCommand$.$anonfun$createTopic$1(TopicCommand.scala:90)\n\tat io.lenses.domain.logging.MetricsSupport.timed(MetricsSupport.scala:22)\n\tat io.lenses.domain.logging.MetricsSupport.timed$(MetricsSupport.scala:20)\n\tat io.lenses.core.kafka.TopicCommand$.timed(TopicCommand.scala:44)\n\tat io.lenses.core.kafka.TopicCommand$.createTopic(TopicCommand.scala:55)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$8(TopicCommandTest.scala:106)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$8$adapted(TopicCommandTest.scala:97)\n\tat io.lenses.core.kafka.TopicCommandTest.testEnvironment$1(TopicCommandTest.scala:68)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$6(TopicCommandTest.scala:97)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.kafka.TopicCommandTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicCommandTest.scala:54)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.core.kafka.TopicCommandTest.run(TopicCommandTest.scala:54)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "type CreateTime",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 20013,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.core.kafka.TopicCommand$.$anonfun$createTopic$1(TopicCommand.scala:90)\n\tat io.lenses.domain.logging.MetricsSupport.timed(MetricsSupport.scala:22)\n\tat io.lenses.domain.logging.MetricsSupport.timed$(MetricsSupport.scala:20)\n\tat io.lenses.core.kafka.TopicCommand$.timed(TopicCommand.scala:44)\n\tat io.lenses.core.kafka.TopicCommand$.createTopic(TopicCommand.scala:55)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$13(TopicCommandTest.scala:126)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$13$adapted(TopicCommandTest.scala:119)\n\tat io.lenses.core.kafka.TopicCommandTest.testEnvironment$1(TopicCommandTest.scala:68)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$11(TopicCommandTest.scala:119)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.kafka.TopicCommandTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicCommandTest.scala:54)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.core.kafka.TopicCommandTest.run(TopicCommandTest.scala:54)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "createTopic should update topic config, preserving default values",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 25048,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.core.kafka.TopicCommand$.$anonfun$createTopic$1(TopicCommand.scala:90)\n\tat io.lenses.domain.logging.MetricsSupport.timed(MetricsSupport.scala:22)\n\tat io.lenses.domain.logging.MetricsSupport.timed$(MetricsSupport.scala:20)\n\tat io.lenses.core.kafka.TopicCommand$.timed(TopicCommand.scala:44)\n\tat io.lenses.core.kafka.TopicCommand$.createTopic(TopicCommand.scala:55)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$19(TopicCommandTest.scala:146)\n\tat io.lenses.core.kafka.TopicCommandTest.withKafkaTableRepository(TopicCommandTest.scala:344)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$18(TopicCommandTest.scala:145)\n\tat io.lenses.core.kafka.TopicCommandTest.testEnvironment$1(TopicCommandTest.scala:68)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$16(TopicCommandTest.scala:139)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.kafka.TopicCommandTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicCommandTest.scala:54)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.core.kafka.TopicCommandTest.run(TopicCommandTest.scala:54)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "increasePartitionCount should return TopicNotFound if describeTopics doesn't return a value with the given topic",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "increasePartitionCount should return TopicNotFound if describeTopics throws an exception",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "increasePartitionCount should return failed Future if createPartitions doesn't return a result for the given topic (should never happen)",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 44,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "increasePartitionCount should return PartitionsAdded with number of new partitions on success",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 44,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "increasePartitionCount should pass failure to update topic on to caller",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "increasePartitionCount should return InvalidNumberOfPartitions if number of partitions specified is less than existing number",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "increasePartitionCount should return InvalidNumberOfPartitions if number of partitions specified is equal to existing number",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.security.SecurityConfigTest",
      "timestamp": "2020-09-11T09:14:01",
      "testcase": [
        {
          "name": " returns an error",
          "classname": "io.lenses.core.security.SecurityConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validating the admin password format for abc does return None",
          "classname": "io.lenses.core.security.SecurityConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validating the admin password format for PLAIN:abc does return None",
          "classname": "io.lenses.core.security.SecurityConfigTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validating the admin password format for PLaIN:abc does return None",
          "classname": "io.lenses.core.security.SecurityConfigTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validating the admin password format for sha256:abc does return None",
          "classname": "io.lenses.core.security.SecurityConfigTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validating the admin password format for shA256:abc does return None",
          "classname": "io.lenses.core.security.SecurityConfigTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 228,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.pagination.CollectionPaginationSpec",
      "timestamp": "2020-09-11T09:14:09",
      "testcase": [
        {
          "name": "slice should get list elements for page start and page end indexes being integers",
          "classname": "io.lenses.core.pagination.CollectionPaginationSpec",
          "time": 37,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "slice should get last list elements for page page exceeding integer max",
          "classname": "io.lenses.core.pagination.CollectionPaginationSpec",
          "time": 105,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "slice should get empty list for too high page start",
          "classname": "io.lenses.core.pagination.CollectionPaginationSpec",
          "time": 71,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "slice should start from beginning of list for too first index < 0",
          "classname": "io.lenses.core.pagination.CollectionPaginationSpec",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 552,
      "tests": 21,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "sets all offsets to start",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 369,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "sets all offsets to end",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "sets all offsets to particular timestamp",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "sets all offsets to particular timestamp, or end when passed timestamp exceeds all records",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "sets all offsets for to start (for subset of topics)",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 24,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "sets all offsets to end (for subset of topics)",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "sets all offsets to particular timestamp (for subset of topics)",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "sets a single offset to absolute value",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "sets a single offset to start",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "sets a single offset to end",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offsets if group doesn't exist (state: Dead)",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offsets if group doesn't exist (state: Unknown)",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offsets if group doesn't exist (state: null)",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offsets if group is active (state: CompletingRebalance)",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offsets if group is active (state: PreparingRebalance)",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offsets if group is active (state: Stable)",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offsets if topic(s) not consumed by group",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offsets if consumer group consumes no topics",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offsets if offset retrieval fails",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offset if topic partition is not found",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails to set offset if offset out of bounds",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerServiceTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 193,
      "tests": 9,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.pagerduty.PagerDutyClientTest",
      "timestamp": "2020-09-11T09:14:06",
      "testcase": [
        {
          "name": "PagerDutyClient should supplies the API token as a header",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyClientTest",
          "time": 36,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyClient should supplies the form header",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyClientTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyClient should raiseIncident should persist incidents in pager duty",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyClientTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyClient should raiseIncident should gracefully handle the case where an incident has been already raised",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyClientTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyClient should resolveIncident should set the incident status to resolved, gracefully handling the case where the incident has been already resolved",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyClientTest",
          "time": 30,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyClient should allUnresolvedIncidents should returns an empty list if no data is present",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyClientTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyClient should allUnresolvedIncidents should scan through multiple pages of results",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyClientTest",
          "time": 40,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyClient should allUnresolvedIncidents should filter out all resolved incidents",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyClientTest",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyClient should allUnresolvedIncidents should filter out results from other services",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyClientTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6472,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.audits.AuditLoggerTest",
      "timestamp": "2020-09-11T09:14:01",
      "testcase": [
        {
          "name": "AuditLogger should log audits to store and forward them to channels",
          "classname": "io.lenses.core.audits.AuditLoggerTest",
          "time": 6472,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 27,
      "tests": 11,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.migration.AlertRuleMigrationSpec",
      "timestamp": "2020-09-11T09:14:14",
      "testcase": [
        {
          "name": "AlertRuleMigration should toAlertRuleOp should succeed for fixed rule update",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 20,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleMigration should toAlertRuleOp should succeed for condition add",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleMigration should toAlertRuleOp should succeed for condition delete",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleMigration should toAlertRuleOp should fail gracefully for null key",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleMigration should toAlertRuleOp should fail for invalid key",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleMigration should toAlertRuleOp should fail for fixed rule update of conditional rule",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleMigration should toAlertRuleOp should fail for fixed rule update with no value",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleMigration should toAlertRuleOp should fail for invalid fixed rule update value",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleMigration should toAlertRuleOp should fail for conditional rule update of fixed rule",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleMigration should toAlertRuleOp should fail for invalid condition ID",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleMigration should toAlertRuleOp should fail for invalid condition DSL",
          "classname": "io.lenses.core.migration.AlertRuleMigrationSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 8,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseActiveControllersFnTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "RaiseActiveControllersFn should raise an alert when active controllers is < 1",
          "classname": "io.lenses.core.monitoring.actions.RaiseActiveControllersFnTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseActiveControllersFn should raise an alert when active controllers is > 1",
          "classname": "io.lenses.core.monitoring.actions.RaiseActiveControllersFnTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseActiveControllersFn should raise an INFO alert when active controllers is = 1",
          "classname": "io.lenses.core.monitoring.actions.RaiseActiveControllersFnTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1146,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.ZookeeperDataAggregatorActorSpec",
      "timestamp": "2020-09-11T09:14:10",
      "testcase": [
        {
          "name": "ZookeeperDataAggregatorActor should send Zookeeper node status to ServicesActor on startup",
          "classname": "io.lenses.core.actors.ZookeeperDataAggregatorActorSpec",
          "time": 255,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LinkToOutputActor should send status of zookeeper(s) to subscribers",
          "classname": "io.lenses.core.actors.ZookeeperDataAggregatorActorSpec",
          "time": 187,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LinkToOutputActor should hides sensitive information",
          "classname": "io.lenses.core.actors.ZookeeperDataAggregatorActorSpec",
          "time": 191,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "GetZookeeperMetricsResponse should only update with metrics if node is active",
          "classname": "io.lenses.core.actors.ZookeeperDataAggregatorActorSpec",
          "time": 387,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UpdateActivityStatus should set jmx to None if node is not active",
          "classname": "io.lenses.core.actors.ZookeeperDataAggregatorActorSpec",
          "time": 127,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 213,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.audits.BackgroundAuditLoggerTest",
      "timestamp": "2020-09-11T09:14:11",
      "testcase": [
        {
          "name": "BackgroundAuditLogger should log audits in background",
          "classname": "io.lenses.core.audits.BackgroundAuditLoggerTest",
          "time": 128,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "BackgroundAuditLogger should cancel if timeout exceeded",
          "classname": "io.lenses.core.audits.BackgroundAuditLoggerTest",
          "time": 84,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseFailedProduceRequestsPerSecAlertsFnTest",
      "timestamp": "2020-09-11T09:14:06",
      "testcase": [
        {
          "name": "1",
          "classname": "io.lenses.core.monitoring.actions.RaiseFailedProduceRequestsPerSecAlertsFnTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseFailedProduceRequestPerSecAlertsFn should raise a MEDIUM level alert when failed produce request percentage > 0",
          "classname": "io.lenses.core.monitoring.actions.RaiseFailedProduceRequestsPerSecAlertsFnTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseFailedProduceRequestPerSecAlertsFn should raise an INFO alert when the failed produce request is back to 0 on brokers",
          "classname": "io.lenses.core.monitoring.actions.RaiseFailedProduceRequestsPerSecAlertsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 120049,
      "tests": 6,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.lsql.JdbcRoutesControllerInsertStatementTest",
      "timestamp": "2020-09-11T09:14:11",
      "testcase": [
        {
          "name": "handlePrepareStatementData should return partition and offset info",
          "classname": "io.lenses.core.lsql.JdbcRoutesControllerInsertStatementTest",
          "time": 120027,
          "failure": {
            "message": "Topic myTopic not present in metadata after 60000 ms.",
            "type": "org.apache.kafka.common.errors.TimeoutException",
            "stackTrace": "org.apache.kafka.common.errors.TimeoutException: Topic myTopic not present in metadata after 60000 ms."
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "handlePrepareStatementData should fail to insert data when metadata keyType is set to BYTES",
          "classname": "io.lenses.core.lsql.JdbcRoutesControllerInsertStatementTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "handlePrepareStatementData should fail to insert data when metadata valueType is set to BYTES",
          "classname": "io.lenses.core.lsql.JdbcRoutesControllerInsertStatementTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "handlePrepareStatementData should fail to insert data when metadata key type is not set",
          "classname": "io.lenses.core.lsql.JdbcRoutesControllerInsertStatementTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "handlePrepareStatementData should fail to insert data when metadata value type is not set",
          "classname": "io.lenses.core.lsql.JdbcRoutesControllerInsertStatementTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "handlePrepareStatementData should fail to insert data when neither metadata value type not key type is set",
          "classname": "io.lenses.core.lsql.JdbcRoutesControllerInsertStatementTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 12206,
      "tests": 12,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.DashboardActorSpec",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "RefreshTelemetryData should update UserLoginsTelemetry",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 1002,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RefreshTelemetryData should update connections telemetry",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 184,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RefreshTelemetryData should update alerts telemetry",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 620,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RefreshTelemetryData should update audits telemetry",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 595,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RefreshTelemetryData should update external apps telemetry",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 175,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Audit should update audits list unless AuditResource is of type USER",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 287,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LinkActor and PublishUpdates should send data to subscriber, including audits if user has permission to view them",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 457,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LinkActor and PublishUpdates should send data to subscriber, excluding audits if user does not have permission to view them",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 233,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "OnDashboardControllersData should raise a controller alert if the number of controllers drops down to zero",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 2220,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "OnDashboardControllersData should not raise a controller alert if active controllers are back to normal after second check",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 2102,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "OnDashboardControllersData should raise an offline partitions alert if there are some offline partitions",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 2176,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "OnDashboardControllersData should not raise an offline partitions alert if offline partitions are back to normal after second check",
          "classname": "io.lenses.core.actors.DashboardActorSpec",
          "time": 2152,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.utils.ExtractHostFromEndpointTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "ExtractHostFromEndpoint should extract PLAINTEXT://miles:9092",
          "classname": "io.lenses.core.utils.ExtractHostFromEndpointTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "30:9092",
          "classname": "io.lenses.core.utils.ExtractHostFromEndpointTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "com:19092",
          "classname": "io.lenses.core.utils.ExtractHostFromEndpointTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "com:19093",
          "classname": "io.lenses.core.utils.ExtractHostFromEndpointTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "com:19094",
          "classname": "io.lenses.core.utils.ExtractHostFromEndpointTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "com:19096",
          "classname": "io.lenses.core.utils.ExtractHostFromEndpointTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 20,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseBrokerAlertsFnTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "RaiseBrokersAlertsFn should raise an alert when the broker is down",
          "classname": "io.lenses.core.monitoring.actions.RaiseBrokerAlertsFnTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseBrokersAlertsFn should not raise the alert twice",
          "classname": "io.lenses.core.monitoring.actions.RaiseBrokerAlertsFnTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseBrokersAlertsFn should raise an alert when the broker is back online",
          "classname": "io.lenses.core.monitoring.actions.RaiseBrokerAlertsFnTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseBrokersAlertsFn should raise an alert when one broker is down and the other one is back up",
          "classname": "io.lenses.core.monitoring.actions.RaiseBrokerAlertsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 192931,
      "tests": 5,
      "failures": 4,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
      "timestamp": "2020-09-11T09:14:12",
      "testcase": [
        {
          "name": "describeCluster should returns the Kafka cluster description",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
          "time": 5008,
          "failure": {
            "message": "Timed out waiting for a node assignment.",
            "type": "org.apache.kafka.common.errors.TimeoutException",
            "stackTrace": "org.apache.kafka.common.errors.TimeoutException: Timed out waiting for a node assignment."
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "describeLogDirs should returns logDir info by broker id",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
          "time": 5008,
          "failure": {
            "message": "Set() was not equal to Set(0)",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: Set() was not equal to Set(0)\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImplSpec.$anonfun$new$8(KafkaAdminClientImplSpec.scala:34)\n\tat cats.effect.IO$Map.apply(IO.scala:1504)\n\tat cats.effect.IO$Map.apply(IO.scala:1502)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:142)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:361)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.run(Callback.scala:130)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.apply(Callback.scala:136)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.apply(Callback.scala:125)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImpl.$anonfun$describeLogDirs$8(KafkaAdminClientImpl.scala:162)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImpl.$anonfun$describeLogDirs$8$adapted(KafkaAdminClientImpl.scala:162)\n\tat io.lenses.core.kafka.KafkaFutureOps$Wrapper.$anonfun$asyncComplete$1(KafkaFutureOps.scala:48)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer.accept(KafkaFutureImpl.java:175)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer.accept(KafkaFutureImpl.java:162)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.completeExceptionally(KafkaFutureImpl.java:238)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient.completeAllExceptionally(KafkaAdminClient.java:287)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient.access$2300(KafkaAdminClient.java:181)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$14.handleFailure(KafkaAdminClient.java:2134)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$Call.fail(KafkaAdminClient.java:641)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor.handleTimeouts(KafkaAdminClient.java:757)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable.timeoutPendingCalls(KafkaAdminClient.java:825)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable.run(KafkaAdminClient.java:1119)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "describeLogDirs should omits the log dir info when a broker lookup fails",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
          "time": 5005,
          "failure": {
            "message": "Set() was not equal to Set(0)",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: Set() was not equal to Set(0)\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImplSpec.$anonfun$new$11(KafkaAdminClientImplSpec.scala:41)\n\tat cats.effect.IO$Map.apply(IO.scala:1504)\n\tat cats.effect.IO$Map.apply(IO.scala:1502)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:142)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:361)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.run(Callback.scala:130)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.apply(Callback.scala:136)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.apply(Callback.scala:125)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImpl.$anonfun$describeLogDirs$8(KafkaAdminClientImpl.scala:162)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImpl.$anonfun$describeLogDirs$8$adapted(KafkaAdminClientImpl.scala:162)\n\tat io.lenses.core.kafka.KafkaFutureOps$Wrapper.$anonfun$asyncComplete$1(KafkaFutureOps.scala:48)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer.accept(KafkaFutureImpl.java:175)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer.accept(KafkaFutureImpl.java:162)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.completeExceptionally(KafkaFutureImpl.java:238)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient.completeAllExceptionally(KafkaAdminClient.java:287)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient.access$2300(KafkaAdminClient.java:181)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$14.handleFailure(KafkaAdminClient.java:2134)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$Call.fail(KafkaAdminClient.java:641)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor.handleTimeouts(KafkaAdminClient.java:757)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable.timeoutPendingCalls(KafkaAdminClient.java:825)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable.run(KafkaAdminClient.java:1119)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "describeTopics should return no keys for non-existing topic",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
          "time": 120007,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "describeTopics should return a key for an existing topic",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
          "time": 57900,
          "failure": {
            "message": null,
            "type": "java.lang.InterruptedException",
            "stackTrace": "java.lang.InterruptedException\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:998)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\n\tat cats.effect.internals.IOPlatform$.$anonfun$unsafeResync$2(IOPlatform.scala:51)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$DefaultBlockContext$.blockOn(BlockContext.scala:57)\n\tat scala.concurrent.package$.blocking(package.scala:146)\n\tat cats.effect.internals.IOPlatform$.unsafeResync(IOPlatform.scala:51)\n\tat cats.effect.IO.unsafeRunTimed(IO.scala:325)\n\tat cats.effect.IO.unsafeRunSync(IO.scala:240)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImplSpec.withAdminClient(KafkaAdminClientImplSpec.scala:69)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImplSpec.$anonfun$new$16(KafkaAdminClientImplSpec.scala:55)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat org.scalatest.wordspec.AnyWordSpec.run(AnyWordSpec.scala:1879)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6847,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.BrokerDataAggregatorActorTest2",
      "timestamp": "2020-09-11T09:14:12",
      "testcase": [
        {
          "name": "BrokerDataAggregatorActor should raise a cpu alert for brokers in",
          "classname": "io.lenses.core.actors.BrokerDataAggregatorActorTest2",
          "time": 2283,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "BrokerDataAggregatorActor should raise a failedFetchRequestPerSec alert for brokers in",
          "classname": "io.lenses.core.actors.BrokerDataAggregatorActorTest2",
          "time": 2282,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "BrokerDataAggregatorActor should raise a failedProduceRequest alert for brokers in",
          "classname": "io.lenses.core.actors.BrokerDataAggregatorActorTest2",
          "time": 2282,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 218,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.license.LicenseManagerImplTest",
      "timestamp": "2020-09-11T09:14:08",
      "testcase": [
        {
          "name": "updates the license is respected",
          "classname": "io.lenses.core.license.LicenseManagerImplTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails if the store function files",
          "classname": "io.lenses.core.license.LicenseManagerImplTest",
          "time": 198,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails if the license is not valid",
          "classname": "io.lenses.core.license.LicenseManagerImplTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updates the license",
          "classname": "io.lenses.core.license.LicenseManagerImplTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 21,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseConnectWorkerAlertsFnTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "RaiseConnectWorkersAlertsFn should raise an alert when a connect worker is down",
          "classname": "io.lenses.core.monitoring.actions.RaiseConnectWorkerAlertsFnTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseConnectWorkersAlertsFn should not raise the alert twice",
          "classname": "io.lenses.core.monitoring.actions.RaiseConnectWorkerAlertsFnTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseConnectWorkersAlertsFn should raise an alert when a connect worker is online",
          "classname": "io.lenses.core.monitoring.actions.RaiseConnectWorkerAlertsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseConnectWorkersAlertsFn should raise an alert when a connect worker is down and one worker is back online",
          "classname": "io.lenses.core.monitoring.actions.RaiseConnectWorkerAlertsFnTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 15,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseConsumerLagFnTest",
      "timestamp": "2020-09-11T09:14:11",
      "testcase": [
        {
          "name": "RaiseConsumerLagFn should raise alert on consumer lag exceeded",
          "classname": "io.lenses.core.monitoring.actions.RaiseConsumerLagFnTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseConsumerLagFn should raise one alert per group",
          "classname": "io.lenses.core.monitoring.actions.RaiseConsumerLagFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 192588,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.migration.AuditMigrationIntegrationTest",
      "timestamp": "2020-09-11T09:14:12",
      "testcase": [
        {
          "name": "migrate audits to AuditStore",
          "classname": "io.lenses.core.migration.AuditMigrationIntegrationTest",
          "time": 192588,
          "failure": {
            "message": "java.lang.InterruptedException",
            "type": "org.apache.kafka.common.errors.InterruptException",
            "stackTrace": "org.apache.kafka.common.errors.InterruptException: java.lang.InterruptedException\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:937)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:856)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:743)\n\tat io.lenses.core.migration.AuditMigrationIntegrationTest.$anonfun$new$2(AuditMigrationIntegrationTest.scala:67)\n\tat scala.collection.immutable.Stream.foreach(Stream.scala:533)\n\tat io.lenses.core.migration.AuditMigrationIntegrationTest.$anonfun$new$1(AuditMigrationIntegrationTest.scala:60)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.InterruptedException\n\tat java.lang.Object.wait(Native Method)\n\tat org.apache.kafka.common.utils.SystemTime.waitObject(SystemTime.java:60)\n\tat org.apache.kafka.clients.producer.internals.ProducerMetadata.awaitUpdate(ProducerMetadata.java:97)\n\tat org.apache.kafka.clients.producer.KafkaProducer.waitOnMetadata(KafkaProducer.java:999)\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:876)\n\t... 61 more"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 12133,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.metrics.MetricValuesRetentionStreamsTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "MetricValuesRetentionStreams should onInsertPipe should delete expired values according to policy",
          "classname": "io.lenses.core.metrics.MetricValuesRetentionStreamsTest",
          "time": 10156,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricValuesRetentionStreams should onInsertPipe should delete excess values even when earlier data points un-fulfilled",
          "classname": "io.lenses.core.metrics.MetricValuesRetentionStreamsTest",
          "time": 1132,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricValuesRetentionStreams should hardDeleteStream should delete values before retention cutoff",
          "classname": "io.lenses.core.metrics.MetricValuesRetentionStreamsTest",
          "time": 845,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 884,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.AuditActorSpec",
      "timestamp": "2020-09-11T09:14:09",
      "testcase": [
        {
          "name": "AuditActor should log the audit and forward it to 'subscriber'",
          "classname": "io.lenses.core.actors.AuditActorSpec",
          "time": 39,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditActor should should not log the audit and forward it to 'subscriber' if license is disabling it",
          "classname": "io.lenses.core.actors.AuditActorSpec",
          "time": 263,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditActor should ignore failed audit and continue",
          "classname": "io.lenses.core.actors.AuditActorSpec",
          "time": 582,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1784,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.splunk.SplunkAuditPublisherTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "SplunkAuditPublisher should raise an InitError when the supplied configuration is not valid",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkAuditPublisherTest",
          "time": 299,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "SplunkAuditPublisher should publish audits using Splunk CIM schema",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkAuditPublisherTest",
          "time": 1258,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "SplunkAuditPublisher should raise a PublishError error if Splunk call fails",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkAuditPublisherTest",
          "time": 227,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2566,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.BrokerDataAggregatorActorTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "BrokerDataAggregatorActor should raise the openfile descriptor alert for broker 1",
          "classname": "io.lenses.core.actors.BrokerDataAggregatorActorTest",
          "time": 288,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "BrokerDataAggregatorActor should raise the openfile descriptor alert for broker 1 and broker 2",
          "classname": "io.lenses.core.actors.BrokerDataAggregatorActorTest",
          "time": 376,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "BrokerDataAggregatorActor should raise the openfile descriptor alert for broker 1 once it is not an issue",
          "classname": "io.lenses.core.actors.BrokerDataAggregatorActorTest",
          "time": 356,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "BrokerDataAggregatorActor should raise the openfile descriptor alert for broker 1, 4 times",
          "classname": "io.lenses.core.actors.BrokerDataAggregatorActorTest",
          "time": 955,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "BrokerDataAggregatorActor should hides broker details",
          "classname": "io.lenses.core.actors.BrokerDataAggregatorActorTest",
          "time": 592,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 7429,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.metrics.data.kafka.MessageProducedMetricsCalculationServiceImplTest",
      "timestamp": "2020-09-11T09:14:03",
      "testcase": [
        {
          "name": "MessageProducedMetricsCalculationServiceImpl can calculate periodically metrics should successfully calculate",
          "classname": "io.lenses.core.metrics.data.kafka.MessageProducedMetricsCalculationServiceImplTest",
          "time": 3935,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MessageProducedMetricsCalculationServiceImpl can calculate periodically metrics should successfully calculate filling missing data with nones",
          "classname": "io.lenses.core.metrics.data.kafka.MessageProducedMetricsCalculationServiceImplTest",
          "time": 1116,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MessageProducedMetricsCalculationServiceImpl can calculate periodically metrics should successfully calculate filling missing middle periods",
          "classname": "io.lenses.core.metrics.data.kafka.MessageProducedMetricsCalculationServiceImplTest",
          "time": 812,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MessageProducedMetricsCalculationServiceImpl can calculate periodically metrics should successfully calculate grouping by period",
          "classname": "io.lenses.core.metrics.data.kafka.MessageProducedMetricsCalculationServiceImplTest",
          "time": 700,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MessageProducedMetricsCalculationServiceImpl can calculate periodically metrics should successfully calculate filling missing from and to periods hourly",
          "classname": "io.lenses.core.metrics.data.kafka.MessageProducedMetricsCalculationServiceImplTest",
          "time": 867,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 196804,
      "tests": 2,
      "failures": 2,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.admin.KafkaAdminClientCreateAndDeleteSpec",
      "timestamp": "2020-09-11T09:14:08",
      "testcase": [
        {
          "name": "createTopics and deleteTopics should work as expected when all topics new",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientCreateAndDeleteSpec",
          "time": 120021,
          "failure": {
            "message": "Timed out waiting for a node assignment.",
            "type": "org.apache.kafka.common.errors.TimeoutException",
            "stackTrace": "org.apache.kafka.common.errors.TimeoutException: Timed out waiting for a node assignment."
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "createTopics and deleteTopics should fail creating topics that are already present",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientCreateAndDeleteSpec",
          "time": 76783,
          "failure": {
            "message": null,
            "type": "java.lang.InterruptedException",
            "stackTrace": "java.lang.InterruptedException\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:998)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\n\tat cats.effect.internals.IOPlatform$.$anonfun$unsafeResync$2(IOPlatform.scala:51)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$DefaultBlockContext$.blockOn(BlockContext.scala:57)\n\tat scala.concurrent.package$.blocking(package.scala:146)\n\tat cats.effect.internals.IOPlatform$.unsafeResync(IOPlatform.scala:51)\n\tat cats.effect.IO.unsafeRunTimed(IO.scala:325)\n\tat cats.effect.IO.unsafeRunSync(IO.scala:240)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientCreateAndDeleteSpec.withAdminClient(KafkaAdminClientCreateAndDeleteSpec.scala:79)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientCreateAndDeleteSpec.$anonfun$new$9(KafkaAdminClientCreateAndDeleteSpec.scala:53)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat org.scalatest.wordspec.AnyWordSpec.run(AnyWordSpec.scala:1879)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1519,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.alertplugin.AlertPluginChannelPublisherTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "AlertPluginChannelPublisherTest should pass configuration as Map[String, String]",
          "classname": "io.lenses.core.channels.publisher.alertplugin.AlertPluginChannelPublisherTest",
          "time": 1243,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertPluginChannelPublisherTest should route alerts to correct plugin",
          "classname": "io.lenses.core.channels.publisher.alertplugin.AlertPluginChannelPublisherTest",
          "time": 24,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertPluginChannelPublisherTest should raise error if className missing",
          "classname": "io.lenses.core.channels.publisher.alertplugin.AlertPluginChannelPublisherTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertPluginChannelPublisherTest should raise initialisation errors",
          "classname": "io.lenses.core.channels.publisher.alertplugin.AlertPluginChannelPublisherTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertPluginChannelPublisherTest should raise publishing errors",
          "classname": "io.lenses.core.channels.publisher.alertplugin.AlertPluginChannelPublisherTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertPluginChannelPublisherTest should use cached AlertingService instance if present and cache newly created services",
          "classname": "io.lenses.core.channels.publisher.alertplugin.AlertPluginChannelPublisherTest",
          "time": 75,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertPluginChannelPublisherTest should close and delete cached closable AlertingService instances if channel updated or deleted",
          "classname": "io.lenses.core.channels.publisher.alertplugin.AlertPluginChannelPublisherTest",
          "time": 107,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertPluginChannelPublisherTest should just delete cached unclosable AlertingService instances if channel updated or deleted",
          "classname": "io.lenses.core.channels.publisher.alertplugin.AlertPluginChannelPublisherTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 745,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.webhook.loader.render.AlertTemplateRendererTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "AlertTemplateRenderer should properly find variables",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.render.AlertTemplateRendererTest",
          "time": 745,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 902,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.yaml.YamlHelperTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "YamlHelper should read a connect model from Yaml json",
          "classname": "io.lenses.core.yaml.YamlHelperTest",
          "time": 862,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "YamlHelper should read a connect model from Yaml json with a default value being list",
          "classname": "io.lenses.core.yaml.YamlHelperTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "YamlHelper should read the model from a Yaml",
          "classname": "io.lenses.core.yaml.YamlHelperTest",
          "time": 29,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 204154,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.migration.AlertMigrationIntegrationTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "migrate alerts to AlertStore",
          "classname": "io.lenses.core.migration.AlertMigrationIntegrationTest",
          "time": 204154,
          "failure": {
            "message": "java.lang.InterruptedException",
            "type": "org.apache.kafka.common.errors.InterruptException",
            "stackTrace": "org.apache.kafka.common.errors.InterruptException: java.lang.InterruptedException\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:937)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:856)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:743)\n\tat io.lenses.core.migration.AlertMigrationIntegrationTest.$anonfun$new$2(AlertMigrationIntegrationTest.scala:70)\n\tat scala.collection.immutable.Stream.foreach(Stream.scala:533)\n\tat io.lenses.core.migration.AlertMigrationIntegrationTest.$anonfun$new$1(AlertMigrationIntegrationTest.scala:62)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.InterruptedException\n\tat java.lang.Object.wait(Native Method)\n\tat org.apache.kafka.common.utils.SystemTime.waitObject(SystemTime.java:60)\n\tat org.apache.kafka.clients.producer.internals.ProducerMetadata.awaitUpdate(ProducerMetadata.java:97)\n\tat org.apache.kafka.clients.producer.KafkaProducer.waitOnMetadata(KafkaProducer.java:999)\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:876)\n\t... 61 more"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseFailedFetchRequestsPerSecAlertsFnTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "1",
          "classname": "io.lenses.core.monitoring.actions.RaiseFailedFetchRequestsPerSecAlertsFnTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseFailedFetchRequestPerSecAlertsFn should raise a MEDIUM level alert when failed fetch request percentage > 0",
          "classname": "io.lenses.core.monitoring.actions.RaiseFailedFetchRequestsPerSecAlertsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseFailedFetchRequestPerSecAlertsFn should raise an INfo alert when the failed fetch request is back to 0 on brokers",
          "classname": "io.lenses.core.monitoring.actions.RaiseFailedFetchRequestsPerSecAlertsFnTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2311,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.forwarder.AlertChannelForwarderTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "AlertChannelForwarder should route consumer lag alerts to channels configured for this setting",
          "classname": "io.lenses.core.channels.forwarder.AlertChannelForwarderTest",
          "time": 1478,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertChannelForwarder should route 'fixed alerts' to channels configured for this setting",
          "classname": "io.lenses.core.channels.forwarder.AlertChannelForwarderTest",
          "time": 833,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 4448,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.telemetry.FlowsBackedConnectionsTelemetrySpec",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "connections telemetry should return info about all connection types",
          "classname": "io.lenses.core.telemetry.FlowsBackedConnectionsTelemetrySpec",
          "time": 4448,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 119,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.datadog.DataDogAlertPublisherTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "DataDogAlertPublisher should throw an InitError when the supplied configuration is not valid",
          "classname": "io.lenses.core.channels.publisher.datadog.DataDogAlertPublisherTest",
          "time": 55,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DataDogAlertPublisher should aggregates consumer events by condition id",
          "classname": "io.lenses.core.channels.publisher.datadog.DataDogAlertPublisherTest",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DataDogAlertPublisher should aggregates broker events by condition id",
          "classname": "io.lenses.core.channels.publisher.datadog.DataDogAlertPublisherTest",
          "time": 26,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1874,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.migration.AsyncMigrationManagerTest",
      "timestamp": "2020-09-11T09:14:01",
      "testcase": [
        {
          "name": "handles empty task list",
          "classname": "io.lenses.core.migration.AsyncMigrationManagerTest",
          "time": 1013,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "handles one migration task",
          "classname": "io.lenses.core.migration.AsyncMigrationManagerTest",
          "time": 439,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "handles two migration task",
          "classname": "io.lenses.core.migration.AsyncMigrationManagerTest",
          "time": 422,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 7020,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.utils.FileWatcherTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "should raise a notification when file has changed",
          "classname": "io.lenses.core.utils.FileWatcherTest",
          "time": 7020,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1484,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.datadog.DataDogClientTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "DataDogClient should successfully submit events to DataDog when site is correctly set",
          "classname": "io.lenses.core.channels.publisher.datadog.DataDogClientTest",
          "time": 1316,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DataDogClient should submit no event to DataDog when region is misconfigured",
          "classname": "io.lenses.core.channels.publisher.datadog.DataDogClientTest",
          "time": 67,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DataDogClient should submit no event to DataDog when apiKey is misconfigured",
          "classname": "io.lenses.core.channels.publisher.datadog.DataDogClientTest",
          "time": 94,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DataDogClient should submit no event to DataDog when applicationKey is misconfigured",
          "classname": "io.lenses.core.channels.publisher.datadog.DataDogClientTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 32,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.migration.KafkaOnePartitionTopicReaderTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "returns hasNext true when not all data is read",
          "classname": "io.lenses.core.migration.KafkaOnePartitionTopicReaderTest",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2556,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.PayloadIdentifierTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "KEY & VALUE type identification should work",
          "classname": "io.lenses.core.actors.PayloadIdentifierTest",
          "time": 1848,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KEY & VALUE type identification should work for Serdes",
          "classname": "io.lenses.core.actors.PayloadIdentifierTest",
          "time": 708,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 10001,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.FetcherWrapperTest",
      "timestamp": "2020-09-11T09:14:14",
      "testcase": [
        {
          "name": "should read last offset",
          "classname": "io.lenses.core.kafka.FetcherWrapperTest",
          "time": 10001,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.kafka.FetcherWrapperTest.createTopic(FetcherWrapperTest.scala:24)\n\tat io.lenses.core.kafka.FetcherWrapperTest.$anonfun$new$1(FetcherWrapperTest.scala:37)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.core.kafka.FetcherWrapperTest.withFixture(FetcherWrapperTest.scala:24)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.core.kafka.FetcherWrapperTest.runTest(FetcherWrapperTest.scala:24)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.core.kafka.FetcherWrapperTest.runTests(FetcherWrapperTest.scala:24)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.core.kafka.FetcherWrapperTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(FetcherWrapperTest.scala:24)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.kafka.FetcherWrapperTest.org$scalatest$BeforeAndAfterAll$$super$run(FetcherWrapperTest.scala:24)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.core.kafka.FetcherWrapperTest.run(FetcherWrapperTest.scala:24)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 9,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.forwarder.ConditionalChannelForwarderTest",
      "timestamp": "2020-09-11T09:14:06",
      "testcase": [
        {
          "name": "does not forward the event if it is not allowed",
          "classname": "io.lenses.core.channels.forwarder.ConditionalChannelForwarderTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "forward the event if it is allowed",
          "classname": "io.lenses.core.channels.forwarder.ConditionalChannelForwarderTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 14887,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.metrics.KafkaPartitionEndOffsetCollectorTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "KafkaPartitionEndOffsetCollector should store offsets (and trigger event) when store is empty",
          "classname": "io.lenses.core.metrics.KafkaPartitionEndOffsetCollectorTest",
          "time": 10062,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaPartitionEndOffsetCollector should only trigger event, when previous values after start of day",
          "classname": "io.lenses.core.metrics.KafkaPartitionEndOffsetCollectorTest",
          "time": 1080,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaPartitionEndOffsetCollector should store offsets if previously stored were before startOfDay",
          "classname": "io.lenses.core.metrics.KafkaPartitionEndOffsetCollectorTest",
          "time": 810,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaPartitionEndOffsetCollector should store offsets for partitions that were missing in previous storage",
          "classname": "io.lenses.core.metrics.KafkaPartitionEndOffsetCollectorTest",
          "time": 700,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaPartitionEndOffsetCollector should store offsets if collection duration becomes shorter",
          "classname": "io.lenses.core.metrics.KafkaPartitionEndOffsetCollectorTest",
          "time": 819,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaPartitionEndOffsetCollector should fire correct summary events over time",
          "classname": "io.lenses.core.metrics.KafkaPartitionEndOffsetCollectorTest",
          "time": 845,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaPartitionEndOffsetCollector should don't send events if invalid data detected",
          "classname": "io.lenses.core.metrics.KafkaPartitionEndOffsetCollectorTest",
          "time": 571,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3132,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.migration.ConsumerRecordConverterTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "convert record to AlertV0",
          "classname": "io.lenses.core.migration.ConsumerRecordConverterTest",
          "time": 865,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "convert ConsumerRecord to Audit",
          "classname": "io.lenses.core.migration.ConsumerRecordConverterTest",
          "time": 2267,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 8,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.KafkaTopicSummaryTest",
      "timestamp": "2020-09-11T09:14:14",
      "testcase": [
        {
          "name": "should return blank messagePerPartitions when partitions > 0 but no message data is available",
          "classname": "io.lenses.core.kafka.KafkaTopicSummaryTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "should return message data if present",
          "classname": "io.lenses.core.kafka.KafkaTopicSummaryTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 205953,
      "tests": 2,
      "failures": 2,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.topics.TopicCreateServiceTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "createTopic should be able to create a topic and emit a single new dataset event",
          "classname": "io.lenses.core.kafka.topics.TopicCreateServiceTest",
          "time": 121176,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.core.kafka.TopicCommand$.$anonfun$createTopic$1(TopicCommand.scala:90)\n\tat io.lenses.domain.logging.MetricsSupport.timed(MetricsSupport.scala:22)\n\tat io.lenses.domain.logging.MetricsSupport.timed$(MetricsSupport.scala:20)\n\tat io.lenses.core.kafka.TopicCommand$.timed(TopicCommand.scala:44)\n\tat io.lenses.core.kafka.TopicCommand$.createTopic(TopicCommand.scala:55)\n\tat io.lenses.core.kafka.topics.TopicCreateServiceImpl.$anonfun$createTopic$2(TopicCreateService.scala:81)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:87)\n\tat cats.effect.internals.IORunLoop$.startCancelable(IORunLoop.scala:41)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:88)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "createTopic should be unable to create topic due to InvalidReplicationFactorException",
          "classname": "io.lenses.core.kafka.topics.TopicCreateServiceTest",
          "time": 84776,
          "failure": {
            "message": null,
            "type": "java.lang.InterruptedException",
            "stackTrace": "java.lang.InterruptedException\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:998)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\n\tat cats.effect.internals.IOPlatform$.$anonfun$unsafeResync$2(IOPlatform.scala:51)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$DefaultBlockContext$.blockOn(BlockContext.scala:57)\n\tat scala.concurrent.package$.blocking(package.scala:146)\n\tat cats.effect.internals.IOPlatform$.unsafeResync(IOPlatform.scala:51)\n\tat cats.effect.IO.unsafeRunTimed(IO.scala:325)\n\tat cats.effect.IO.unsafeRunSync(IO.scala:240)\n\tat io.lenses.core.kafka.topics.TopicCreateServiceTest.createTopicResultWithDatasetEvents(TopicCreateServiceTest.scala:99)\n\tat io.lenses.core.kafka.topics.TopicCreateServiceTest.$anonfun$new$2(TopicCreateServiceTest.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.flatspec.AnyFlatSpecLike$$anon$5.apply(AnyFlatSpecLike.scala:1683)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.flatspec.AnyFlatSpec.withFixture(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.invokeWithFixture$1(AnyFlatSpecLike.scala:1681)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTest$1(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest$(AnyFlatSpecLike.scala:1675)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTest(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTests$1(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests$(AnyFlatSpecLike.scala:1750)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTests(AnyFlatSpec.scala:1685)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.flatspec.AnyFlatSpec.org$scalatest$flatspec$AnyFlatSpecLike$$super$run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$run$1(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run$(AnyFlatSpecLike.scala:1794)\n\tat org.scalatest.flatspec.AnyFlatSpec.run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 10,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.license.LicenseFileUpdaterTest",
      "timestamp": "2020-09-11T09:14:13",
      "testcase": [
        {
          "name": "updates the license from the file",
          "classname": "io.lenses.core.license.LicenseFileUpdaterTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fails if the license content is invalid",
          "classname": "io.lenses.core.license.LicenseFileUpdaterTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6366,
      "tests": 38,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.indexer.CatalogIndexTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "CatalogIndex should return nothing when index empty",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 2016,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should return result for Kafka topic with primitive schemas",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 1310,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should should not match when the query does not match",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 259,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should include/exclude system entities with keyword: Some(table)",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 146,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should include/exclude system entities with keyword: None",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 99,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should sort Kafka topics by num records",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 153,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should sort Kafka topics by name",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 228,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should sort Kafka topics by name descending",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 94,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should sort datasets by sourceType",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 206,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should match fields (includeMetadata true)",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 292,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should match fields (includeMetadata false)",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 54,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should separate key/value fields with ancestors",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 75,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should pagination",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 172,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should combination of Kafka and ElasticSearch records, including policy matches",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 95,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should DatasetRemoved",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 95,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should ConnectionRemoved",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 73,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should DatasetChanged",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 93,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should filter by connection excludes connections that don't match filter",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 92,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should empty query returns all tables",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 142,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should return source types for entire search, not just current page",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 77,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should matching multi-word string",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 54,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name camelCaseText matches query camel",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 41,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name camelCaseText matches query case",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name camelCaseText matches query text",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 26,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name camelCaseText matches query camelCaseText",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 28,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name camelCaseText matches query caseText",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name dash-separated-text matches query dash",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name dash-separated-text matches query separated",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 21,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name dash-separated-text matches query text",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 26,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name dash-separated-text matches query dash-separated-text",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 34,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name dash-separated-text matches query separated-text",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 29,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "elastic matches query hidden",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "elastic matches query like",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "elastic matches query elastic",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "elastic",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 35,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LIKE",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 24,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should Table name wildcard\\escape*char?test matches query wildcard\\escape*char?test",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "CatalogIndex should permissions",
          "classname": "io.lenses.core.indexer.CatalogIndexTest",
          "time": 78,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 328,
      "tests": 12,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
      "timestamp": "2020-09-11T09:14:10",
      "testcase": [
        {
          "name": "WebHookChannel should hasInsecureSSLConfig should should be true when `useHttps` and `insecure` are set",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebHookChannel should hasInsecureSSLConfig should should be false when `insecure` is set but `useHttps` isn't",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebHookChannel should hasInsecureSSLConfig should should be false `useHttps` is set but `insecure` is false",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RequestGeneration should forward error from path rendering",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RequestGeneration should forward error from body rendering",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RequestGeneration should forward error from headers rendering",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RequestGeneration should sets the https scheme when the web hook secure parameter is set to true",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RequestGeneration should sets the http scheme when the web hook secure parameter is set to false",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RequestGeneration should sets the port number when present",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RequestGeneration should sets the expected HTTP method",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RequestGeneration should sets the headers, with content type set at the entity level",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 306,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RequestGeneration should sets the supplied body",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.domain.WebHookChannelTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 156,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.consumer.KafkaConsumerImplTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "beginningOffsets should translate properly",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerImplTest",
          "time": 151,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "endOffsets should translate properly",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerImplTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "offsetsForTimes should translate properly",
          "classname": "io.lenses.core.kafka.consumer.KafkaConsumerImplTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 112,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.BrokersStatusActorSpec",
      "timestamp": "2020-09-11T09:14:08",
      "testcase": [
        {
          "name": "GetBrokerState should discover new brokers when they are added to the cluster",
          "classname": "io.lenses.core.actors.BrokersStatusActorSpec",
          "time": 64,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "GetBrokerState should notifies the broker data aggregator when a new broker is discovered",
          "classname": "io.lenses.core.actors.BrokersStatusActorSpec",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "GetBrokerState should mark all brokers as inactive if the cluster is not reachable",
          "classname": "io.lenses.core.actors.BrokersStatusActorSpec",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "GetBrokerState should remove brokers when these are no longer reachable",
          "classname": "io.lenses.core.actors.BrokersStatusActorSpec",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "GetBrokerState should notifies the broker data aggregator when a new broker is no longer reachable",
          "classname": "io.lenses.core.actors.BrokersStatusActorSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 743,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.ConnectDataAggregatorActorTest",
      "timestamp": "2020-09-11T09:14:19",
      "testcase": [
        {
          "name": "JMX state does not get set if isAlive is not true",
          "classname": "io.lenses.core.actors.ConnectDataAggregatorActorTest",
          "time": 80,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JMX state is set when isAlive is true",
          "classname": "io.lenses.core.actors.ConnectDataAggregatorActorTest",
          "time": 90,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "receive all data on subscribe",
          "classname": "io.lenses.core.actors.ConnectDataAggregatorActorTest",
          "time": 149,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "receive all data updates",
          "classname": "io.lenses.core.actors.ConnectDataAggregatorActorTest",
          "time": 328,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "hides sensitive information",
          "classname": "io.lenses.core.actors.ConnectDataAggregatorActorTest",
          "time": 96,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 107,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.datasets.RepositoryDifferTest",
      "timestamp": "2020-09-11T09:14:10",
      "testcase": [
        {
          "name": "connectionEvents should emit ConnectDeleted events when previously existing connections are removed",
          "classname": "io.lenses.core.datasets.RepositoryDifferTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "datasetEvents should emit DatasetRemoved events when previously seen tables are removed",
          "classname": "io.lenses.core.datasets.RepositoryDifferTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "datasetEvents should not remove tables with the same name if they belong to another connection",
          "classname": "io.lenses.core.datasets.RepositoryDifferTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "datasetEvents should emit NewDataset events when new tables are added",
          "classname": "io.lenses.core.datasets.RepositoryDifferTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "datasetEvents should emit DatasetChanged events when relevant table properties change",
          "classname": "io.lenses.core.datasets.RepositoryDifferTest",
          "time": 36,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "datasetEvents should emit no DatasetChanged events when Diff[T] instance is overriden to disregard certain fields",
          "classname": "io.lenses.core.datasets.RepositoryDifferTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 163,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.alerting.AlertRuleServiceSpec",
      "timestamp": "2020-09-11T09:14:11",
      "testcase": [
        {
          "name": "AlertRuleService should getAlertRuleConditions should provide decoded conditions",
          "classname": "io.lenses.core.alerting.AlertRuleServiceSpec",
          "time": 31,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleService should getAlertRuleConditions should provide no data produced conditions if license prohibits data SLA",
          "classname": "io.lenses.core.alerting.AlertRuleServiceSpec",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleService should getRules should provide no data produced conditions if license prohibits data SLA",
          "classname": "io.lenses.core.alerting.AlertRuleServiceSpec",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleService should does not return License alert",
          "classname": "io.lenses.core.alerting.AlertRuleServiceSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleService should does not return Connect related alert settings on empty connect cluster",
          "classname": "io.lenses.core.alerting.AlertRuleServiceSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleService should returns Connect related alert settings on non empty connect cluster",
          "classname": "io.lenses.core.alerting.AlertRuleServiceSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleService should return all the settings",
          "classname": "io.lenses.core.alerting.AlertRuleServiceSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleService should disable/enable setting",
          "classname": "io.lenses.core.alerting.AlertRuleServiceSpec",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleService should add/remove condition",
          "classname": "io.lenses.core.alerting.AlertRuleServiceSpec",
          "time": 27,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleService should validate state is preserved",
          "classname": "io.lenses.core.alerting.AlertRuleServiceSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseRequestHandlerAvgIdlePercentAlertsFnTest",
      "timestamp": "2020-09-11T09:14:12",
      "testcase": [
        {
          "name": "RaiseRequestHandlerAvgIdlePercentAlertsFn should raise a CRITICAL level alert when percentage is < 2%",
          "classname": "io.lenses.core.monitoring.actions.RaiseRequestHandlerAvgIdlePercentAlertsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseRequestHandlerAvgIdlePercentAlertsFn should raise a HIGH level alert when percentage is < 10%",
          "classname": "io.lenses.core.monitoring.actions.RaiseRequestHandlerAvgIdlePercentAlertsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseRequestHandlerAvgIdlePercentAlertsFn should raise an INFO alert then the idle percentage is ok on brokers",
          "classname": "io.lenses.core.monitoring.actions.RaiseRequestHandlerAvgIdlePercentAlertsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 9,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseSchemaRegistryAlertsFnTest",
      "timestamp": "2020-09-11T09:14:08",
      "testcase": [
        {
          "name": "RaiseSchemaRegistryAlertsFn should raise an alert when the sr is down",
          "classname": "io.lenses.core.monitoring.actions.RaiseSchemaRegistryAlertsFnTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseSchemaRegistryAlertsFn should not raise an alert again",
          "classname": "io.lenses.core.monitoring.actions.RaiseSchemaRegistryAlertsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseSchemaRegistryAlertsFn should raise an alert when the sr is online and another one is down",
          "classname": "io.lenses.core.monitoring.actions.RaiseSchemaRegistryAlertsFnTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 7,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseFileOpenDescriptorsAlertsFnTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "RaiseFileOpenDescriptorsAlertsFn should raise a CRITICAL level alert when File-open descriptors > 90% of capacity on brokers",
          "classname": "io.lenses.core.monitoring.actions.RaiseFileOpenDescriptorsAlertsFnTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseFileOpenDescriptorsAlertsFn should raise a HIGH level alert when File-open descriptors > 80% of capacity on brokers",
          "classname": "io.lenses.core.monitoring.actions.RaiseFileOpenDescriptorsAlertsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseFileOpenDescriptorsAlertsFn should raise an INFO alert when File-open descriptors is ok of capacity on brokers",
          "classname": "io.lenses.core.monitoring.actions.RaiseFileOpenDescriptorsAlertsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1694,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 1,
      "name": "io.lenses.core.actors.AlertActorSpec",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "AlertsActor should keep last 100 alerts only",
          "classname": "io.lenses.core.actors.AlertActorSpec",
          "time": 769,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertsActor should give all the messages received only",
          "classname": "io.lenses.core.actors.AlertActorSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "AlertsActor should forward the alert to 'subscriber'",
          "classname": "io.lenses.core.actors.AlertActorSpec",
          "time": 368,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertsActor should does not forward the alert to 'subscriber' if alerts are disabled",
          "classname": "io.lenses.core.actors.AlertActorSpec",
          "time": 263,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertsActor should forward the alert to alerting system if configured",
          "classname": "io.lenses.core.actors.AlertActorSpec",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertsActor should does not forward the alert to alerting system if alerts disabled",
          "classname": "io.lenses.core.actors.AlertActorSpec",
          "time": 263,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 45041,
      "tests": 4,
      "failures": 3,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.topics.TopicMessageResenderTest",
      "timestamp": "2020-09-11T09:14:11",
      "testcase": [
        {
          "name": "resend should copy existing String message",
          "classname": "io.lenses.core.kafka.topics.TopicMessageResenderTest",
          "time": 10005,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createTopic(TopicMessageResenderTest.scala:30)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createUniqueTopic(TopicMessageResenderTest.scala:112)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.$anonfun$new$1(TopicMessageResenderTest.scala:48)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.flatspec.AnyFlatSpecLike$$anon$5.apply(AnyFlatSpecLike.scala:1683)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.flatspec.AnyFlatSpec.withFixture(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.invokeWithFixture$1(AnyFlatSpecLike.scala:1681)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTest$1(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest$(AnyFlatSpecLike.scala:1675)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTest(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTests$1(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests$(AnyFlatSpecLike.scala:1750)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTests(AnyFlatSpec.scala:1685)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.flatspec.AnyFlatSpec.org$scalatest$flatspec$AnyFlatSpecLike$$super$run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$run$1(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run$(AnyFlatSpecLike.scala:1794)\n\tat org.scalatest.flatspec.AnyFlatSpec.run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "resend should fail when topic does not exist",
          "classname": "io.lenses.core.kafka.topics.TopicMessageResenderTest",
          "time": 15029,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "resend should fail when partition does not exist",
          "classname": "io.lenses.core.kafka.topics.TopicMessageResenderTest",
          "time": 10001,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createTopic(TopicMessageResenderTest.scala:30)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createUniqueTopic(TopicMessageResenderTest.scala:112)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.$anonfun$new$5(TopicMessageResenderTest.scala:78)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.flatspec.AnyFlatSpecLike$$anon$5.apply(AnyFlatSpecLike.scala:1683)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.flatspec.AnyFlatSpec.withFixture(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.invokeWithFixture$1(AnyFlatSpecLike.scala:1681)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTest$1(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest$(AnyFlatSpecLike.scala:1675)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTest(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTests$1(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests$(AnyFlatSpecLike.scala:1750)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTests(AnyFlatSpec.scala:1685)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.flatspec.AnyFlatSpec.org$scalatest$flatspec$AnyFlatSpecLike$$super$run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$run$1(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run$(AnyFlatSpecLike.scala:1794)\n\tat org.scalatest.flatspec.AnyFlatSpec.run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "resend should fail when offset out of bounds",
          "classname": "io.lenses.core.kafka.topics.TopicMessageResenderTest",
          "time": 10003,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createTopic(TopicMessageResenderTest.scala:30)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createUniqueTopic(TopicMessageResenderTest.scala:112)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.$anonfun$new$7(TopicMessageResenderTest.scala:91)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.flatspec.AnyFlatSpecLike$$anon$5.apply(AnyFlatSpecLike.scala:1683)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.flatspec.AnyFlatSpec.withFixture(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.invokeWithFixture$1(AnyFlatSpecLike.scala:1681)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTest$1(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest$(AnyFlatSpecLike.scala:1675)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTest(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTests$1(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests$(AnyFlatSpecLike.scala:1750)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTests(AnyFlatSpec.scala:1685)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.flatspec.AnyFlatSpec.org$scalatest$flatspec$AnyFlatSpecLike$$super$run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$run$1(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run$(AnyFlatSpecLike.scala:1794)\n\tat org.scalatest.flatspec.AnyFlatSpec.run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 4,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseLeaderImbalanceAlertFnTest",
      "timestamp": "2020-09-11T09:14:08",
      "testcase": [
        {
          "name": "RaiseLeaderImbalanceAlert should Send an info alert",
          "classname": "io.lenses.core.monitoring.actions.RaiseLeaderImbalanceAlertFnTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.webhook.loader.parser.AuditVariablesParserTest",
      "timestamp": "2020-09-11T09:14:06",
      "testcase": [
        {
          "name": "AuditVariablesParser should properly parse variable",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.parser.AuditVariablesParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 13,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseMultipleBrokerVersionsFnTest",
      "timestamp": "2020-09-11T09:13:59",
      "testcase": [
        {
          "name": "RaiseMultipleBrokerVersionsFn should raise no alert if no brokers are available",
          "classname": "io.lenses.core.monitoring.actions.RaiseMultipleBrokerVersionsFnTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseMultipleBrokerVersionsFn should raise an alert when brokers have different versions",
          "classname": "io.lenses.core.monitoring.actions.RaiseMultipleBrokerVersionsFnTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseMultipleBrokerVersionsFn should do not raise the alert more than once when brokers have different versions",
          "classname": "io.lenses.core.monitoring.actions.RaiseMultipleBrokerVersionsFnTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseMultipleBrokerVersionsFn should raise an INFO alert when brokers are of the same version",
          "classname": "io.lenses.core.monitoring.actions.RaiseMultipleBrokerVersionsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 12,
      "tests": 15,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.validation.PluginConfigResolverTest",
      "timestamp": "2020-09-11T09:14:06",
      "testcase": [
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve a single config from plugin should with string value",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve a single config from plugin should with decimal value",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve a single config from plugin should with int value",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve a single config from plugin should with boolean value",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve a single config from plugin should with array value",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve a single config from connection should with string value",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve a single config from connection should with decimal value",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve a single config from connection should with int value",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve a single config from connection should with boolean value",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve a single config from connection should with array value",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should resolve multiple values",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should ignore missing configs if not required",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should ignore missing connection configs if not required",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should fail if required config not defined for plugin",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigResolver should resolveConfigToMap should fail if required config not defined for connection",
          "classname": "io.lenses.core.channels.validation.PluginConfigResolverTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 27,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.json.DomainFormatsSpec",
      "timestamp": "2020-09-11T09:14:11",
      "testcase": [
        {
          "name": "KafkaTopicActionFormat should write action as json string with value equal to the action class name",
          "classname": "io.lenses.core.json.DomainFormatsSpec",
          "time": 27,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 56,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.license.NTPDateTimeRetrieverTests",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "NTPDateTimeRetriever should retrieve current time",
          "classname": "io.lenses.core.license.NTPDateTimeRetrieverTests",
          "time": 56,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1213,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.security.TableInfoSecuritySpec",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "isAuthorizedToShow should allow to see table only when user has ShowTopicAction privilege",
          "classname": "io.lenses.core.security.TableInfoSecuritySpec",
          "time": 437,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "isAuthorizedToShow should do not allow to see table ShowTopicAction privilege for different table",
          "classname": "io.lenses.core.security.TableInfoSecuritySpec",
          "time": 126,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "isAuthorizedToShow should do not allow to see table when there is no ShowTopicAction privilege for the table",
          "classname": "io.lenses.core.security.TableInfoSecuritySpec",
          "time": 136,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "authorizedActionsFor should return all actions for which table is authorized",
          "classname": "io.lenses.core.security.TableInfoSecuritySpec",
          "time": 514,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 125,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.UserProfileManagerTest",
      "timestamp": "2020-09-11T09:14:06",
      "testcase": [
        {
          "name": "UserProfileManager should should load the state from the kafka topic",
          "classname": "io.lenses.core.actors.UserProfileManagerTest",
          "time": 83,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileManager should add and remove topics and load the state",
          "classname": "io.lenses.core.actors.UserProfileManagerTest",
          "time": 42,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 45,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseUnderReplicatedPartitionsFnTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "RaiseUnderReplicatedPartitionsFn should raise an alert when there are under replicated partitions",
          "classname": "io.lenses.core.monitoring.actions.RaiseUnderReplicatedPartitionsFnTest",
          "time": 44,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseUnderReplicatedPartitionsFn should raise an INFO alert when there no more offline partitions",
          "classname": "io.lenses.core.monitoring.actions.RaiseUnderReplicatedPartitionsFnTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3118,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 1,
      "name": "io.lenses.core.datasets.RepositoryEventEmitterTest",
      "timestamp": "2020-09-11T09:14:08",
      "testcase": [
        {
          "name": "RepositoryEventEmitterTest should emit the expected event sequence for the ElasticSearch and Kafka table repositories",
          "classname": "io.lenses.core.datasets.RepositoryEventEmitterTest",
          "time": 80,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "RepositoryEventEmitterTest should scope tables by repository and connection",
          "classname": "io.lenses.core.datasets.RepositoryEventEmitterTest",
          "time": 1529,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RepositoryEventEmitterTest should emit connectionRemoved events when a connection disappears from the metarepo",
          "classname": "io.lenses.core.datasets.RepositoryEventEmitterTest",
          "time": 1508,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 14,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.webhook.loader.render.TemplateRendererTest",
      "timestamp": "2020-09-11T09:14:03",
      "testcase": [
        {
          "name": "TemplateRendererImpl should forward error in case of unknown variable",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.render.TemplateRendererTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TemplateRendererImpl should properly render string without template variables",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.render.TemplateRendererTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TemplateRendererImpl should properly render string with one variable",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.render.TemplateRendererTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TemplateRendererImpl should properly render string with multiple variables",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.render.TemplateRendererTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TemplateRendererImpl should properly render alert",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.render.TemplateRendererTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TemplateRendererImpl should properly render audit",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.render.TemplateRendererTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 107,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.pagination.PaginationSpec",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "readPage should return paged values in reverse order",
          "classname": "io.lenses.core.pagination.PaginationSpec",
          "time": 87,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "readPage should support data source returning other amount of values than requested",
          "classname": "io.lenses.core.pagination.PaginationSpec",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "readPage should stop reading the page data when getting empty records list",
          "classname": "io.lenses.core.pagination.PaginationSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "readPage should return amount of total pages",
          "classname": "io.lenses.core.pagination.PaginationSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 31,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.datasets.DatasetMapperTest",
      "timestamp": "2020-09-11T09:14:03",
      "testcase": [
        {
          "name": "DatasetMapper should return a parsing error when the key schema is not valid avro",
          "classname": "io.lenses.core.datasets.DatasetMapperTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMapper should return a parsing error when the value schema is not valid avro",
          "classname": "io.lenses.core.datasets.DatasetMapperTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMapper should handle record names starting with numbers (against the avro spec)",
          "classname": "io.lenses.core.datasets.DatasetMapperTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMapper should return a dataset when the schema can be parsed",
          "classname": "io.lenses.core.datasets.DatasetMapperTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 373,
      "tests": 14,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.avro.AvroFieldsFlattenerTest",
      "timestamp": "2020-09-11T09:13:59",
      "testcase": [
        {
          "name": "AvroFieldsFlattener should not return any fields when an INT primitive type is involved",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should not return any fields when an INT primitive type is involved with prefix",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should not return any fields when a optional n INT primitive type is involved",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should not return any fields when a STRING primitive type is involved",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should not return any fields when a STRING primitive type is involved with prefix",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should not return any fields when a MAP type with private value is involved",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should not return any fields when a MAP type with a struct value involved",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 157,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should return the fields for CreditCard",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should return the fields for LocalPizza",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should return the fields for Person",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 52,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should return the fields for Person with prefix '_key'",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should flatten array schema",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 85,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should work on antwnis schema",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroFieldsFlattener should recursive case",
          "classname": "io.lenses.core.avro.AvroFieldsFlattenerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1224,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 1,
      "name": "io.lenses.core.actors.ConsumersActorTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "ConsumersActor should periodically fetch the consumer group details",
          "classname": "io.lenses.core.actors.ConsumersActorTest",
          "time": 886,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConsumersActor should recover from temporarely failures",
          "classname": "io.lenses.core.actors.ConsumersActorTest",
          "time": 336,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConsumersActor should raise alerts when consumer lag is above threshold",
          "classname": "io.lenses.core.actors.ConsumersActorTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": true
        }
      ]
    },
    {
      "time": 1597,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.metrics.MetricsSubscriptionServiceImplTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "MetricsSubscriptionServiceImpl should quietly do nothing after updating data on channel no one listen to",
          "classname": "io.lenses.core.metrics.MetricsSubscriptionServiceImplTest",
          "time": 60,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSubscriptionServiceImpl should create topic after subscription",
          "classname": "io.lenses.core.metrics.MetricsSubscriptionServiceImplTest",
          "time": 640,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSubscriptionServiceImpl should provide channel with initial message after subscription",
          "classname": "io.lenses.core.metrics.MetricsSubscriptionServiceImplTest",
          "time": 792,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSubscriptionServiceImpl should get published messages",
          "classname": "io.lenses.core.metrics.MetricsSubscriptionServiceImplTest",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSubscriptionServiceImpl should get latest message after subscribing",
          "classname": "io.lenses.core.metrics.MetricsSubscriptionServiceImplTest",
          "time": 36,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSubscriptionServiceImpl should get latest message after subscribing2",
          "classname": "io.lenses.core.metrics.MetricsSubscriptionServiceImplTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSubscriptionServiceImpl should fail subscribing to connection we dont have metrics provider for",
          "classname": "io.lenses.core.metrics.MetricsSubscriptionServiceImplTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 564,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "fromConfigMap should succeed for valid config",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
          "time": 390,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromConfigMap should fail for non-string host",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromConfigMap should fail for invalid host",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
          "time": 132,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromConfigMap should fail for non-numeric port",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromConfigMap should fail for invalid port",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromConfigMap should fail for non-string token",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromConfigMap should fail for invalid token",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromConfigMap should fail for non-boolean useHttps",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromConfigMap should fail for non-boolean insecure",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fromConfigMap should fail for non-string source",
          "classname": "io.lenses.core.channels.publisher.splunk.SplunkChannelTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 30766,
      "tests": 4,
      "failures": 3,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.KafkaTopicsActorSpec",
      "timestamp": "2020-09-11T09:14:02",
      "testcase": [
        {
          "name": "ScheduleTopicPartitionsStatistics should send DashboardTopicsData to dashboardActor",
          "classname": "io.lenses.core.actors.KafkaTopicsActorSpec",
          "time": 332,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ScheduleTopicPartitionsStatistics should handle DeleteFromTopicToOffset message for compacting topics by preventing deletion",
          "classname": "io.lenses.core.actors.KafkaTopicsActorSpec",
          "time": 10194,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.createTopic(KafkaTopicsActorSpec.scala:75)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.io$lenses$core$actors$KafkaTopicsActorSpec$$createTopicAndSetConfiguration(KafkaTopicsActorSpec.scala:232)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec$$anon$3.$anonfun$new$6(KafkaTopicsActorSpec.scala:140)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec$TestContext.$anonfun$withActor$4(KafkaTopicsActorSpec.scala:306)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:87)\n\tat cats.effect.internals.IORunLoop$.startCancelable(IORunLoop.scala:41)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:88)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat akka.dispatch.TaskInvocation.run(AbstractDispatcher.scala:47)\n\tat akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask.exec(ForkJoinExecutorConfigurator.scala:47)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "ScheduleTopicPartitionsStatistics should handle DeleteFromTopicToOffset message for non-compacting topics by allowing deletion",
          "classname": "io.lenses.core.actors.KafkaTopicsActorSpec",
          "time": 10138,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.createTopic(KafkaTopicsActorSpec.scala:75)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.io$lenses$core$actors$KafkaTopicsActorSpec$$createTopicAndSetConfiguration(KafkaTopicsActorSpec.scala:232)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec$$anon$4.$anonfun$new$9(KafkaTopicsActorSpec.scala:162)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec$TestContext.$anonfun$withActor$4(KafkaTopicsActorSpec.scala:306)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:87)\n\tat cats.effect.internals.IORunLoop$.startCancelable(IORunLoop.scala:41)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:88)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat akka.dispatch.TaskInvocation.run(AbstractDispatcher.scala:47)\n\tat akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask.exec(ForkJoinExecutorConfigurator.scala:47)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "ScheduleTopicPartitionsStatistics should send a dataset changed event on topic deletion",
          "classname": "io.lenses.core.actors.KafkaTopicsActorSpec",
          "time": 10101,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.createTopic(KafkaTopicsActorSpec.scala:75)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec$$anon$5.<init>(KafkaTopicsActorSpec.scala:179)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.$anonfun$new$11(KafkaTopicsActorSpec.scala:175)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.withFixture(KafkaTopicsActorSpec.scala:75)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.runTest(KafkaTopicsActorSpec.scala:75)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.runTests(KafkaTopicsActorSpec.scala:75)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(KafkaTopicsActorSpec.scala:75)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.run(KafkaTopicsActorSpec.scala:75)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 230,
      "tests": 26,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.ChannelServiceTest",
      "timestamp": "2020-09-11T09:14:12",
      "testcase": [
        {
          "name": "getAll should return a paginated list of all existing alert channels",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 84,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getAll should sorts the paginated list according to the supplied order",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get should return None when the supplied id is not found",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get should return the specified channel",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "delete should return an error when the supplied id is not found",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 25,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "delete should remove the record and log the deletion in the audit log",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add should persist a valid channel",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add should return error details when the supplied connection id is not present",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add should return error details when one or more fields are not valid",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add should a web-hook channel should return field errors if undefined variables are supplied in a templates field",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 21,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add should a web-hook channel should return field errors if the supplied headers list is not parsable as key value pairs",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add should a web-hook channel should persist a valid channel when no creds field is set in the connection",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add should a web-hook channel should persist a valid channel when no path field is set in the connection",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add should a web-hook channel should persist a valid channel",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update should return error details when one or more property values are not valid",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update should return error details when the supplied connection is not valid",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update should persist a valid channel update",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update should allow setting a different connection",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update should a web-hook channel should returns validation errors when an invalid update is supplied",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update should a web-hook channel should persist a valid update",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patch should return error details when one or more property values are not valid",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patch should return error details when the supplied connection is not valid",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patch should persist a valid channel patch",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patch should allow setting a different connection",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patch should a web-hook channel should returns validation errors when an invalid patch is supplied",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patch should a web-hook channel should persist a valid patch",
          "classname": "io.lenses.core.channels.ChannelServiceTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 46,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.avro.AvroStringFormatterTest",
      "timestamp": "2020-09-11T09:14:12",
      "testcase": [
        {
          "name": "AvroStringFormatter should handle null",
          "classname": "io.lenses.core.avro.AvroStringFormatterTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroStringFormatter should handle null value for NonRecordContainer",
          "classname": "io.lenses.core.avro.AvroStringFormatterTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroStringFormatter should format NonRecordContainer for a double",
          "classname": "io.lenses.core.avro.AvroStringFormatterTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AvroStringFormatter should format a GenericRecord",
          "classname": "io.lenses.core.avro.AvroStringFormatterTest",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 17,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.metrics.PartitionEndOffsetRetentionTest",
      "timestamp": "2020-09-11T09:14:12",
      "testcase": [
        {
          "name": "PartitionEndOffsetRetention should always retain 30 daily values",
          "classname": "io.lenses.core.metrics.PartitionEndOffsetRetentionTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PartitionEndOffsetRetention should hard limit 30 days ago",
          "classname": "io.lenses.core.metrics.PartitionEndOffsetRetentionTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PartitionEndOffsetRetention should retain values as per alert duration",
          "classname": "io.lenses.core.metrics.PartitionEndOffsetRetentionTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.ChannelPublisherFactoryTest",
      "timestamp": "2020-09-11T09:14:12",
      "testcase": [
        {
          "name": "ChannelPublisherFactory should return publisher by template name",
          "classname": "io.lenses.core.channels.publisher.ChannelPublisherFactoryTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelPublisherFactory should return publisher by class name",
          "classname": "io.lenses.core.channels.publisher.ChannelPublisherFactoryTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelPublisherFactory should raise error if no fallback publisher by class name",
          "classname": "io.lenses.core.channels.publisher.ChannelPublisherFactoryTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelPublisherFactory should raise error if no class name",
          "classname": "io.lenses.core.channels.publisher.ChannelPublisherFactoryTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 496,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.SchemaRegistryDataAggregatorActorSpec",
      "timestamp": "2020-09-11T09:14:06",
      "testcase": [
        {
          "name": "SchemaRegistryNodesStatusResponse should send status to subscribers with activity status reflecting activity of registries",
          "classname": "io.lenses.core.actors.SchemaRegistryDataAggregatorActorSpec",
          "time": 249,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "SchemaRegistryNodesStatusResponse should hides sensitive information for schema registry",
          "classname": "io.lenses.core.actors.SchemaRegistryDataAggregatorActorSpec",
          "time": 247,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.webhook.loader.parser.AlertVariablesParserTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "AlertVariablesParser should properly parse variable",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.parser.AlertVariablesParserTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 60366,
      "tests": 6,
      "failures": 6,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.TopicStatsWorkerTest",
      "timestamp": "2020-09-11T09:14:02",
      "testcase": [
        {
          "name": "handle identify topic when there are no messages on the topic",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10259,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$1.$anonfun$run$2(TopicStatsWorkerTest.scala:62)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "handle identify topic when there are no messages on the topic and there is no topic attributes",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10032,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$2.$anonfun$run$5(TopicStatsWorkerTest.scala:76)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "handle identify topic when there are no messages on the topic and no end offsets available",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10010,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$3.$anonfun$run$8(TopicStatsWorkerTest.scala:91)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "handle data on the partition with 1 record",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10014,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$4.$anonfun$run$11(TopicStatsWorkerTest.scala:119)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "handle data on the partition with 1 record after data has been deleted up to the record",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10027,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$8.$anonfun$run$19(TopicStatsWorkerTest.scala:162)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "handle data on the partition with 1 record after data has been deleted",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10024,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$12.$anonfun$run$31(TopicStatsWorkerTest.scala:224)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 501,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.pagerduty.PagerDutyAlertPublisherTest",
      "timestamp": "2020-09-11T09:14:05",
      "testcase": [
        {
          "name": "PagerDutyAlertPublisher should publish should fail when not all the mandatory field are supplied",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyAlertPublisherTest",
          "time": 67,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyAlertPublisher should publish should trigger and then resolve incidents for alerts raised by a 'fixed' alert rule",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyAlertPublisherTest",
          "time": 379,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyAlertPublisher should publish should trigger and then resolve incidents for alerts raised by consumer lag rules",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyAlertPublisherTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PagerDutyAlertPublisher should publish should avoid triggering incidents for ignored alerts",
          "classname": "io.lenses.core.channels.publisher.pagerduty.PagerDutyAlertPublisherTest",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 63,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseBrokerDiskUsageAlertFnTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "RaiseBrokerDiskUsageAlertFn should Raise no alert when disk usage is close to average for all brokers in the cluster",
          "classname": "io.lenses.core.monitoring.actions.RaiseBrokerDiskUsageAlertFnTest",
          "time": 50,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseBrokerDiskUsageAlertFn should Raise a MEDIUM level alert when a broker's disk usage is 25% greater than the cluster average",
          "classname": "io.lenses.core.monitoring.actions.RaiseBrokerDiskUsageAlertFnTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseBrokerDiskUsageAlertFn should Raise an INFO level alert when everything is back to normal",
          "classname": "io.lenses.core.monitoring.actions.RaiseBrokerDiskUsageAlertFnTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 306,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.json.JsonWriterSupportSpec",
      "timestamp": "2020-09-11T09:14:10",
      "testcase": [
        {
          "name": "flatteningWriter should add json object to original json if the latter is json object using provided key",
          "classname": "io.lenses.core.json.JsonWriterSupportSpec",
          "time": 186,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "flatteningWriter should add json value to original json if the latter is json array",
          "classname": "io.lenses.core.json.JsonWriterSupportSpec",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "listWriter should convert list to Json",
          "classname": "io.lenses.core.json.JsonWriterSupportSpec",
          "time": 103,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 689,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.webhook.loader.render.AuditTemplateRendererTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "AuditTemplateRenderer should properly find variables",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.render.AuditTemplateRendererTest",
          "time": 689,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 227,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.config.ChannelConfigServiceTest",
      "timestamp": "2020-09-11T09:14:03",
      "testcase": [
        {
          "name": "PluginConfigService should listAlertChannelTemplates should return a list of the existing templates",
          "classname": "io.lenses.core.channels.config.ChannelConfigServiceTest",
          "time": 48,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigService should listAlertChannelTemplates should include the list of applicable connections",
          "classname": "io.lenses.core.channels.config.ChannelConfigServiceTest",
          "time": 103,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigService should listResolvedPluginConfigs should resolve valid configurations",
          "classname": "io.lenses.core.channels.config.ChannelConfigServiceTest",
          "time": 41,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigService should listResolvedPluginConfigs should ignore if connection is missing",
          "classname": "io.lenses.core.channels.config.ChannelConfigServiceTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigService should listResolvedPluginConfigs should succeed if className is missing",
          "classname": "io.lenses.core.channels.config.ChannelConfigServiceTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigService should listResolvedPluginConfigs should ignore if config is missing",
          "classname": "io.lenses.core.channels.config.ChannelConfigServiceTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "PluginConfigService should listResolvedPluginConfigs should ignore if channel is not enabled",
          "classname": "io.lenses.core.channels.config.ChannelConfigServiceTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ResolvedPluginConfigWithTemplate should stringlyTypedResolvedConfiguration should should render json values as strings",
          "classname": "io.lenses.core.channels.config.ChannelConfigServiceTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 34,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.migration.KafkaOnePartitionTopicReaderCreateTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "returns None if the topic does not exist",
          "classname": "io.lenses.core.migration.KafkaOnePartitionTopicReaderCreateTest",
          "time": 20,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns the reader event if all data was read",
          "classname": "io.lenses.core.migration.KafkaOnePartitionTopicReaderCreateTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns the reader if data needs to be read",
          "classname": "io.lenses.core.migration.KafkaOnePartitionTopicReaderCreateTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1732,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.TopicInfoEnrichmentTest",
      "timestamp": "2020-09-11T09:13:57",
      "testcase": [
        {
          "name": "TopicInfoEnrichment should enrich topic info with kafka repo attributes and cached byte size",
          "classname": "io.lenses.core.kafka.TopicInfoEnrichmentTest",
          "time": 630,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TopicInfoEnrichment should refreshes the byte size cache in the background",
          "classname": "io.lenses.core.kafka.TopicInfoEnrichmentTest",
          "time": 507,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TopicInfoEnrichment should computes no byte size if an empty list of metrics is returned",
          "classname": "io.lenses.core.kafka.TopicInfoEnrichmentTest",
          "time": 174,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TopicInfoEnrichment should honours the configured grace period on error",
          "classname": "io.lenses.core.kafka.TopicInfoEnrichmentTest",
          "time": 421,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 636,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.akka.BaseRoutesSpec",
      "timestamp": "2020-09-11T09:14:05",
      "testcase": [
        {
          "name": "pagination should fail when there is no page size parameter",
          "classname": "io.lenses.core.akka.BaseRoutesSpec",
          "time": 327,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "pagination should accept request with valid page and page size parameters",
          "classname": "io.lenses.core.akka.BaseRoutesSpec",
          "time": 202,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "pagination should accept request with missing page parameter",
          "classname": "io.lenses.core.akka.BaseRoutesSpec",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "pagination should fail with 422 UnprocessableEntity when page parameter is invalid",
          "classname": "io.lenses.core.akka.BaseRoutesSpec",
          "time": 45,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "pagination should fail with 422 UnprocessableEntity when page size parameter is invalid",
          "classname": "io.lenses.core.akka.BaseRoutesSpec",
          "time": 24,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 10023,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.ConnectStatusActorTest",
      "timestamp": "2020-09-11T09:14:03",
      "testcase": [
        {
          "name": "should read task status",
          "classname": "io.lenses.core.actors.ConnectStatusActorTest",
          "time": 10023,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.ConnectStatusActorTest.createTopic(ConnectStatusActorTest.scala:31)\n\tat io.lenses.core.actors.ConnectStatusActorTest.$anonfun$new$1(ConnectStatusActorTest.scala:55)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.core.actors.ConnectStatusActorTest.withFixture(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.core.actors.ConnectStatusActorTest.runTest(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.core.actors.ConnectStatusActorTest.runTests(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.core.actors.ConnectStatusActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.actors.ConnectStatusActorTest.org$scalatest$BeforeAndAfterAll$$super$run(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.core.actors.ConnectStatusActorTest.run(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 7,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.monitoring.actions.RaiseOfflinePartitionsFnTest",
      "timestamp": "2020-09-11T09:13:58",
      "testcase": [
        {
          "name": "RaiseOfflinePartitionsFn should raise an alert when there are offline partitions",
          "classname": "io.lenses.core.monitoring.actions.RaiseOfflinePartitionsFnTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RaiseOfflinePartitionsFn should raise an INFO alert when there no more offline partitions",
          "classname": "io.lenses.core.monitoring.actions.RaiseOfflinePartitionsFnTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 11808,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.LicenseActorSpec",
      "timestamp": "2020-09-11T09:14:11",
      "testcase": [
        {
          "name": "LicenseActorSpec with 1 broker should start with default license and 1 broker the actor should not shutdown the system",
          "classname": "io.lenses.core.actors.LicenseActorSpec",
          "time": 5232,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": " the actor should not shutdown the system",
          "classname": "io.lenses.core.actors.LicenseActorSpec",
          "time": 5192,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": " the actor should shutdown the system",
          "classname": "io.lenses.core.actors.LicenseActorSpec",
          "time": 1382,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 12,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.channels.publisher.webhook.loader.parser.TemplateVariablesParserTest",
      "timestamp": "2020-09-11T09:14:08",
      "testcase": [
        {
          "name": "TemplateVariablesParserImpl should forward error in case of unknown variable",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.parser.TemplateVariablesParserTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TemplateVariablesParserImpl should properly behave in case of no variables in raw string",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.parser.TemplateVariablesParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TemplateVariablesParserImpl should properly find variables in raw string",
          "classname": "io.lenses.core.channels.publisher.webhook.loader.parser.TemplateVariablesParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1664,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.telemetry.AlertsTelemetryFnTest",
      "timestamp": "2020-09-11T09:14:06",
      "testcase": [
        {
          "name": "buildTelemetry should filter disabled rules from main array",
          "classname": "io.lenses.core.telemetry.AlertsTelemetryFnTest",
          "time": 1432,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "buildTelemetry should flatten conditional rules",
          "classname": "io.lenses.core.telemetry.AlertsTelemetryFnTest",
          "time": 47,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "buildTelemetry should show a rule in all channels it applies to",
          "classname": "io.lenses.core.telemetry.AlertsTelemetryFnTest",
          "time": 148,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "buildTelemetry should show channels without rule assignments",
          "classname": "io.lenses.core.telemetry.AlertsTelemetryFnTest",
          "time": 37,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 13,
      "tests": 9,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.avro.AvroDatasetFieldFlattenerTest",
      "timestamp": "2020-09-11T09:14:05",
      "testcase": [
        {
          "name": "not return any fields when an INT primitive type is involved",
          "classname": "io.lenses.core.avro.AvroDatasetFieldFlattenerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "not return any fields when a optional n INT primitive type is involved",
          "classname": "io.lenses.core.avro.AvroDatasetFieldFlattenerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "not return any fields when a STRING primitive type is involved",
          "classname": "io.lenses.core.avro.AvroDatasetFieldFlattenerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "not return any fields when a MAP type with private value is involved",
          "classname": "io.lenses.core.avro.AvroDatasetFieldFlattenerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "not return any fields when a MAP type with a string value involved",
          "classname": "io.lenses.core.avro.AvroDatasetFieldFlattenerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "not return any fields when a MAP type with a struct value involved",
          "classname": "io.lenses.core.avro.AvroDatasetFieldFlattenerTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return record fields with the expected field types, docs and ancestors",
          "classname": "io.lenses.core.avro.AvroDatasetFieldFlattenerTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "recursive case",
          "classname": "io.lenses.core.avro.AvroDatasetFieldFlattenerTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Doesn't throw errors when an unsupported avro schema is supplied",
          "classname": "io.lenses.core.avro.AvroDatasetFieldFlattenerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 0,
      "tests": 0,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.utils.HttpClientSSLTest",
      "timestamp": "2020-09-11T09:14:08",
      "testcase": []
    },
    {
      "time": 11701,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.metrics.KafkaDataProducedAlertTriggerPipeTest",
      "timestamp": "2020-09-11T09:14:00",
      "testcase": [
        {
          "name": "KafkaDataProducedAlertTriggerPipe should produce trigger containing correct messageCount for condition duration",
          "classname": "io.lenses.core.metrics.KafkaDataProducedAlertTriggerPipeTest",
          "time": 6717,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaDataProducedAlertTriggerPipe should raise multiple triggers when multiple topics updated",
          "classname": "io.lenses.core.metrics.KafkaDataProducedAlertTriggerPipeTest",
          "time": 1148,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaDataProducedAlertTriggerPipe should raise multiple triggers when multiple alert rules for a topic",
          "classname": "io.lenses.core.metrics.KafkaDataProducedAlertTriggerPipeTest",
          "time": 1049,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaDataProducedAlertTriggerPipe should not reevaluate more frequently than checkPeriod, when higher frequency data is present",
          "classname": "io.lenses.core.metrics.KafkaDataProducedAlertTriggerPipeTest",
          "time": 735,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaDataProducedAlertTriggerPipe should not produce trigger when no previous data present",
          "classname": "io.lenses.core.metrics.KafkaDataProducedAlertTriggerPipeTest",
          "time": 946,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaDataProducedAlertTriggerPipe should not produce trigger when data returned is too short a time period",
          "classname": "io.lenses.core.metrics.KafkaDataProducedAlertTriggerPipeTest",
          "time": 585,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaDataProducedAlertTriggerPipe should not produce trigger when data returned is for too long a time period",
          "classname": "io.lenses.core.metrics.KafkaDataProducedAlertTriggerPipeTest",
          "time": 521,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 621,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.audits.KafkaAuditLoggerTest",
      "timestamp": "2020-09-11T09:14:14",
      "testcase": [
        {
          "name": "KafkaAuditLogger should log audits to kafka producer",
          "classname": "io.lenses.core.audits.KafkaAuditLoggerTest",
          "time": 487,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaAuditLogger should only complete when producer callback fires",
          "classname": "io.lenses.core.audits.KafkaAuditLoggerTest",
          "time": 67,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaAuditLogger should fail if producer fails",
          "classname": "io.lenses.core.audits.KafkaAuditLoggerTest",
          "time": 67,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2624,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.data.officer.routes.PolicyRoutesLicenseTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "Return 401 when getting a list of all obfuscation methods if no valid token",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesLicenseTest",
          "time": 1930,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "List of all obfuscation methods",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesLicenseTest",
          "time": 499,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "List of all impact values",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesLicenseTest",
          "time": 25,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add a policy update check versions then delete it",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesLicenseTest",
          "time": 106,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "list all categories",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesLicenseTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "reject a new policy if there's a field already assigned",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesLicenseTest",
          "time": 21,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "reject an update if there's a field already assigned",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesLicenseTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 272,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.data.officer.PolicyReportBuilderTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "handle empty topic metadata repository",
          "classname": "io.lenses.data.officer.PolicyReportBuilderTest",
          "time": 128,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return policies with 0 impact if no field matches",
          "classname": "io.lenses.data.officer.PolicyReportBuilderTest",
          "time": 99,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "set the policy impact to 2 topics and 0 application usage",
          "classname": "io.lenses.data.officer.PolicyReportBuilderTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "multiple connections",
          "classname": "io.lenses.data.officer.PolicyReportBuilderTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "match nested fields",
          "classname": "io.lenses.data.officer.PolicyReportBuilderTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "set the policy impact to 2 topics and 1 connector, 2 processors, 2 custom app usage",
          "classname": "io.lenses.data.officer.PolicyReportBuilderTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3360,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.data.officer.DataPolicyCacheTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "cache telemetry and matches with tables",
          "classname": "io.lenses.data.officer.DataPolicyCacheTest",
          "time": 3360,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2875,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.data.officer.routes.PolicyRoutesTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "Return 401 when getting a list of all obfuscation methods if no valid token",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesTest",
          "time": 1927,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "List of all obfuscation methods",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesTest",
          "time": 505,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "List of all impact values",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add a policy update check versions then delete it",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesTest",
          "time": 349,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "list all categories",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesTest",
          "time": 24,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "reject a new policy if there's a field already assigned",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesTest",
          "time": 24,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "reject an update if there's a field already assigned",
          "classname": "io.lenses.data.officer.routes.PolicyRoutesTest",
          "time": 28,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 890,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.data.officer.DefaultPoliciesBuilderTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "should populate the store with the defaults",
          "classname": "io.lenses.data.officer.DefaultPoliciesBuilderTest",
          "time": 890,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 107,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.data.officer.routes.validations.FieldsOnlyOnOnePolicyValidationTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "return empty when there are no existing policies",
          "classname": "io.lenses.data.officer.routes.validations.FieldsOnlyOnOnePolicyValidationTest",
          "time": 98,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return non-empty if there fields already assigned",
          "classname": "io.lenses.data.officer.routes.validations.FieldsOnlyOnOnePolicyValidationTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return empty if the fields are not already assigned",
          "classname": "io.lenses.data.officer.routes.validations.FieldsOnlyOnOnePolicyValidationTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 631,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.ServiceMetricsConfigTest",
      "timestamp": "2020-09-11T09:13:24",
      "testcase": [
        {
          "name": "return none if jmx or metrics is not present",
          "classname": "io.lenses.config.ServiceMetricsConfigTest",
          "time": 522,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return the jmx metrics based on the old format",
          "classname": "io.lenses.config.ServiceMetricsConfigTest",
          "time": 35,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return the jmx metrics with user and password and ssl",
          "classname": "io.lenses.config.ServiceMetricsConfigTest",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return the jmx metrics with user with no password and ssl",
          "classname": "io.lenses.config.ServiceMetricsConfigTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return the http metrics with user and password and ssl",
          "classname": "io.lenses.config.ServiceMetricsConfigTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "raise an error when using http type and the url does not start with http/https",
          "classname": "io.lenses.config.ServiceMetricsConfigTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 687,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.util.PluginConfigSpec",
      "timestamp": "2020-09-11T09:13:24",
      "testcase": [
        {
          "name": "loadPlugin should succeed for valid class instance",
          "classname": "io.lenses.config.util.PluginConfigSpec",
          "time": 524,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "loadPlugin should fail when it is not defined in config",
          "classname": "io.lenses.config.util.PluginConfigSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "loadPlugin should fail when class cannot be found",
          "classname": "io.lenses.config.util.PluginConfigSpec",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "loadPlugin should fail when class has invalid type",
          "classname": "io.lenses.config.util.PluginConfigSpec",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "loadOptionalPlugin should succeed for valid class instance",
          "classname": "io.lenses.config.util.PluginConfigSpec",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "loadOptionalPlugin should return no instance when it is not defined in config",
          "classname": "io.lenses.config.util.PluginConfigSpec",
          "time": 30,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "loadOptionalPlugin should fail when class cannot be found",
          "classname": "io.lenses.config.util.PluginConfigSpec",
          "time": 56,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "loadOptionalPlugin should fail when class has invalid type",
          "classname": "io.lenses.config.util.PluginConfigSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 8793,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.domain.telemetry.LensesTelemetryTest",
      "timestamp": "2020-09-11T09:13:24",
      "testcase": [
        {
          "name": "LensesTelemetry should assemble from initial data correctly",
          "classname": "io.lenses.domain.telemetry.LensesTelemetryTest",
          "time": 8793,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 252,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.domain.monitoring.AlertSettingConditionTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "ConsumerLag should handle lag >= 1003  on  group GroupA and topic  topicA",
          "classname": "io.lenses.domain.monitoring.AlertSettingConditionTest",
          "time": 241,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A and topic topicA",
          "classname": "io.lenses.domain.monitoring.AlertSettingConditionTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A",
          "classname": "io.lenses.domain.monitoring.AlertSettingConditionTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A-xxx",
          "classname": "io.lenses.domain.monitoring.AlertSettingConditionTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A-xxx",
          "classname": "io.lenses.domain.monitoring.AlertSettingConditionTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A-xxx",
          "classname": "io.lenses.domain.monitoring.AlertSettingConditionTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 692,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.SQLConfigTest",
      "timestamp": "2020-09-11T09:13:24",
      "testcase": [
        {
          "name": "loads the SQL configuration",
          "classname": "io.lenses.config.SQLConfigTest",
          "time": 692,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 273,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.domain.datasets.search.DatasetMatchTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "Highlight should yields no results when there is no match",
          "classname": "io.lenses.domain.datasets.search.DatasetMatchTest",
          "time": 268,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Highlight should compute correctly a single string match",
          "classname": "io.lenses.domain.datasets.search.DatasetMatchTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Highlight should compute correctly for multiple string matches",
          "classname": "io.lenses.domain.datasets.search.DatasetMatchTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Highlight should compute handles list of strings as input",
          "classname": "io.lenses.domain.datasets.search.DatasetMatchTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 955,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.KafkaConfigTest",
      "timestamp": "2020-09-11T09:13:24",
      "testcase": [
        {
          "name": "client",
          "classname": "io.lenses.config.KafkaConfigTest",
          "time": 949,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "amalgamate data from producer and consumer if client is not present",
          "classname": "io.lenses.config.KafkaConfigTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throw exception if producer/consumer are present alongside client",
          "classname": "io.lenses.config.KafkaConfigTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 29,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.validation.ValidateFileAccessTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "raises an exception if the file given is not found",
          "classname": "io.lenses.config.validation.ValidateFileAccessTest",
          "time": 27,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "read a text file and not raise an exception",
          "classname": "io.lenses.config.validation.ValidateFileAccessTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "read a binary file and not raise an exception",
          "classname": "io.lenses.config.validation.ValidateFileAccessTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1132,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.ConfigExtensionSpec",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "readFlatMap should transform all configured values to strings",
          "classname": "io.lenses.config.ConfigExtensionSpec",
          "time": 1108,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "readFlatMap should return default for missing config",
          "classname": "io.lenses.config.ConfigExtensionSpec",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WrongType for invalid config type",
          "classname": "io.lenses.config.ConfigExtensionSpec",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "readFlatMap should flatten config with deeper structure into string",
          "classname": "io.lenses.config.ConfigExtensionSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 778,
      "tests": 19,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.DefaultTestConfigTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "LensesConfig should read kafka brokers AWS config",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 685,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should read the config",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "conf",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 37,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should read connect config with JMX",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should read connect config with HTTP",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should read connect config with basic auth",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should reject connect config for missing topic",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should reject connect config for a connector sharing a topic",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should should read username and password for schema registry",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should should read schema registry with no creds",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should should read schema registry with no creds and custom settings",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should should read schema registry with schema registry mode set to hortonworks",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should reads the config without temp audits topic",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesConfig should read the config with temp audits topic",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesRuntime should read runtime configuration with API cache disabled",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesRuntime should read runtime configuration with API cache enabled",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesRuntime should default to cache enabled",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesRuntime should default to not hide services endpoint",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesRuntime should read runtime configuration with sercices endpoints",
          "classname": "io.lenses.config.DefaultTestConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 0,
      "tests": 0,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.domain.zookeeper.ZKSpec",
      "timestamp": "2020-09-11T09:13:24",
      "testcase": []
    },
    {
      "time": 81,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.kafka.connect.FtpTopicsExtractorTest",
      "timestamp": "2020-09-11T09:13:24",
      "testcase": [
        {
          "name": "FtpTopicsExtractor should extract tailing topics from config",
          "classname": "io.lenses.config.kafka.connect.FtpTopicsExtractorTest",
          "time": 81,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 103,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.kafka.ConnectorInfoTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "ConnectorInfo should read from config",
          "classname": "io.lenses.config.kafka.ConnectorInfoTest",
          "time": 49,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectorInfo should throw exception because the extractor is not inheriting from TopicsExtractor",
          "classname": "io.lenses.config.kafka.ConnectorInfoTest",
          "time": 54,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 3,
      "name": "io.lenses.domain.metrics.SlidingTimeMeterLongTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "SlidingTimeMeter should return the values for the time window",
          "classname": "io.lenses.domain.metrics.SlidingTimeMeterLongTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "SlidingTimeMeter should evict values after the window is gone",
          "classname": "io.lenses.domain.metrics.SlidingTimeMeterLongTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "SlidingTimeMeter should calculate the average",
          "classname": "io.lenses.domain.metrics.SlidingTimeMeterLongTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        }
      ]
    },
    {
      "time": 259,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.DynamicConfigTest",
      "timestamp": "2020-09-11T09:13:24",
      "testcase": [
        {
          "name": "DynamicConfig should load from config",
          "classname": "io.lenses.config.DynamicConfigTest",
          "time": 259,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 442,
      "tests": 9,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.LensesSSLTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "returns none if the ssl configs are not there",
          "classname": "io.lenses.config.LensesSSLTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns the fully configured SSL",
          "classname": "io.lenses.config.LensesSSLTest",
          "time": 416,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "raise an exception if the keystore file does not exist",
          "classname": "io.lenses.config.LensesSSLTest",
          "time": 20,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "raises an exception if the keystore password does not exist",
          "classname": "io.lenses.config.LensesSSLTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "raises an exception if the key password is not provided",
          "classname": "io.lenses.config.LensesSSLTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "auth is set to true but no truststore is supplied",
          "classname": "io.lenses.config.LensesSSLTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "defaults the enabled protocols",
          "classname": "io.lenses.config.LensesSSLTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "defaults the algorithm",
          "classname": "io.lenses.config.LensesSSLTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "defaults the cypher suites",
          "classname": "io.lenses.config.LensesSSLTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 293,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.ExternalAppsModuleConfigSpec",
      "timestamp": "2020-09-11T09:13:24",
      "testcase": [
        {
          "name": "ExternalAppsModuleConfig should be created from typesafe Config",
          "classname": "io.lenses.config.ExternalAppsModuleConfigSpec",
          "time": 292,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ExternalAppsModuleConfig should be created with DefaultConstants for keys missing in given config",
          "classname": "io.lenses.config.ExternalAppsModuleConfigSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 319,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.domain.monitoring.AlertSettingSpec",
      "timestamp": "2020-09-11T09:13:24",
      "testcase": [
        {
          "name": "AlertSetting should have stable name (for use in telemetry)",
          "classname": "io.lenses.domain.monitoring.AlertSettingSpec",
          "time": 319,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 464,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.KubernetesConfigTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "KubernetesConfig should not be created when ExecutionMode is not KUBERNETES",
          "classname": "io.lenses.config.KubernetesConfigTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KubernetesConfig should be created with all default when only mandatory fields are set",
          "classname": "io.lenses.config.KubernetesConfigTest",
          "time": 430,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KubernetesConfig should be created with a list of customized namespaces",
          "classname": "io.lenses.config.KubernetesConfigTest",
          "time": 20,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KubernetesConfig should be created with pod-related fields set explicitly",
          "classname": "io.lenses.config.KubernetesConfigTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KubernetesConfig should be created with dad-buffers-related fields set explicitly",
          "classname": "io.lenses.config.KubernetesConfigTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KubernetesConfig should be created with all top fields set explicitly",
          "classname": "io.lenses.config.KubernetesConfigTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 179,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.ExternalServiceConfigTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "handle reading kafka settings for processors",
          "classname": "io.lenses.config.ExternalServiceConfigTest",
          "time": 179,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 29,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.config.kafka.connect.SimpleTopicsExtractorTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "SimpleTopicsExtractor should extract tailing topics from config",
          "classname": "io.lenses.config.kafka.connect.SimpleTopicsExtractorTest",
          "time": 29,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 505,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.domain.sql.DecoderTypeSpec",
      "timestamp": "2020-09-11T09:12:50",
      "testcase": [
        {
          "name": "DecoderType should be encoded/decoded correctly",
          "classname": "io.lenses.domain.sql.DecoderTypeSpec",
          "time": 505,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 75,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.KafkaConnectProxyListConnectorsTest",
      "timestamp": "2020-09-11T09:15:01",
      "testcase": [
        {
          "name": "returns sinks for which the user is allowed to read from",
          "classname": "io.lenses.http.routes.KafkaConnectProxyListConnectorsTest",
          "time": 75,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 48,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
      "timestamp": "2020-09-11T09:15:01",
      "testcase": [
        {
          "name": "RejectionHandlerBuilder should create a RejectionHandler based on a list of more than one partial function",
          "classname": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RejectionHandlerBuilder should create a RejectionHandler handling AuthenticationFailedRejection by default",
          "classname": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RejectionHandlerBuilder should create a RejectionHandler handling ValidationRejection by default",
          "classname": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RejectionHandlerBuilder should create a RejectionHandler handling InvalidKerberosCredentialsRejection by default",
          "classname": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RejectionHandlerBuilder should create a RejectionHandler handling NoMatchingUserInLensesRejection by default",
          "classname": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RejectionHandlerBuilder should create a RejectionHandler handling MalformedRequestContentRejection and return proper error for invalid json strings",
          "classname": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RejectionHandlerBuilder should create a RejectionHandler handling MalformedRequestContentRejection and return proper error for invalid json values",
          "classname": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RejectionHandlerBuilder should create a RejectionHandler handling MalformedRequestContentRejection and return proper error for invalid json keys",
          "classname": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RejectionHandlerBuilder should parse simple error message returned by circe",
          "classname": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RejectionHandlerBuilder should parse complex error message returned by circe",
          "classname": "io.lenses.http.routes.utils.RejectionHandlerBuilderSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1465,
      "tests": 72,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.ChannelRoutesTest",
      "timestamp": "2020-09-11T09:14:25",
      "testcase": [
        {
          "name": "alert channels routes should GET /api/v1/alert/channel-templates should return a list of channel templates to a root user, filtering out provided or connection configuration keys",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 347,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channel-templates should return a 402 when license does not allow it",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channel-templates should be forbidden to normal users",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should POST /api/v1/alert/channels should return 201 on success - with the new channel persisted",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 137,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should POST /api/v1/alert/channels should return 402 when license does not allow it",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should POST /api/v1/alert/channels should return BadRequest with error details on validation failure",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 20,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should POST /api/v1/alert/channels should return Conflict with error details on name conflict",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 33,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should POST /api/v1/alert/channels should be forbidden to normal users",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels/:id should return given channel",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels/:id should return 402 when the license is disabled",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels/:id should return 404 when no record can be found",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PUT /api/v1/alert/channels/:id should return 200 success - with channel updated",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 44,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PUT /api/v1/alert/channels/:id should return 402 when the license is disabled",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PUT /api/v1/alert/channels/:id should be forbidden to normal users",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PUT /api/v1/alert/channels/:id should return 400 with error details on validation failure",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PUT /api/v1/alert/channels/:id should return 404 when no record can be found",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PUT /api/v1/alert/channels/:id should return 409 with error details on name conflict",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PATCH /api/v1/alert/channels/:id should return 200 success - with channel patched",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 56,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PATCH /api/v1/alert/channels/:id should return 402 if the license is disabled",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PATCH /api/v1/alert/channels/:id should be forbidden to normal users",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PATCH /api/v1/alert/channels/:id should return 400 with error details on validation failure",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PATCH /api/v1/alert/channels/:id should return 404 when no record can be found",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should PATCH /api/v1/alert/channels/:id should return 409 with error details on name conflict",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should DELETE /api/v1/alert/channels/:id should return 204 on success",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should DELETE /api/v1/alert/channels/:id should be forbidden to normal users",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should DELETE /api/v1/alert/channels/:id should return 402 when the license is disabled",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should DELETE /api/v1/alert/channels/:id should return 404 when no record can be found",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels should return a list of channels",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 53,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels should returns 402 when listing channels when license is disabled",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels should filters channels by template and name fragment",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels should correctly parse sortField value name with sortOrder asc",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels should correctly parse sortField value templateName with sortOrder asc",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels should correctly parse sortField value createdAt with sortOrder asc",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels should correctly parse sortField value updatedAt with sortOrder asc",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels should return a bad request if an unknown sortField value is supplied",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "alert channels routes should GET /api/v1/alert/channels should return a bad request if an unknown sortOrder value is supplied",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channel-templates should return a list of channel templates to a root user, filtering out provided or connection configuration keys",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channel-templates should return a 402 when license does not allow it",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channel-templates should be forbidden to normal users",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should POST /api/v1/audit/channels should return 201 on success - with the new channel persisted",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should POST /api/v1/audit/channels should return 402 when license does not allow it",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should POST /api/v1/audit/channels should return BadRequest with error details on validation failure",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should POST /api/v1/audit/channels should return Conflict with error details on name conflict",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should POST /api/v1/audit/channels should be forbidden to normal users",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels/:id should return given channel",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels/:id should return 402 when the license is disabled",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels/:id should return 404 when no record can be found",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PUT /api/v1/audit/channels/:id should return 200 success - with channel updated",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 29,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PUT /api/v1/audit/channels/:id should return 402 when the license is disabled",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PUT /api/v1/audit/channels/:id should be forbidden to normal users",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PUT /api/v1/audit/channels/:id should return 400 with error details on validation failure",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PUT /api/v1/audit/channels/:id should return 404 when no record can be found",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PUT /api/v1/audit/channels/:id should return 409 with error details on name conflict",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PATCH /api/v1/audit/channels/:id should return 200 success - with channel patched",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PATCH /api/v1/audit/channels/:id should return 402 if the license is disabled",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PATCH /api/v1/audit/channels/:id should be forbidden to normal users",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PATCH /api/v1/audit/channels/:id should return 400 with error details on validation failure",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PATCH /api/v1/audit/channels/:id should return 404 when no record can be found",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should PATCH /api/v1/audit/channels/:id should return 409 with error details on name conflict",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should DELETE /api/v1/audit/channels/:id should return 204 on success",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should DELETE /api/v1/audit/channels/:id should be forbidden to normal users",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should DELETE /api/v1/audit/channels/:id should return 402 when the license is disabled",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should DELETE /api/v1/audit/channels/:id should return 404 when no record can be found",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels should return a list of channels",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels should returns 402 when listing channels when license is disabled",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels should filters channels by template and name fragment",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels should correctly parse sortField value name with sortOrder asc",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels should correctly parse sortField value templateName with sortOrder asc",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels should correctly parse sortField value createdAt with sortOrder asc",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels should correctly parse sortField value updatedAt with sortOrder asc",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels should return a bad request if an unknown sortField value is supplied",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "audit channels routes should GET /api/v1/audit/channels should return a bad request if an unknown sortOrder value is supplied",
          "classname": "io.lenses.http.routes.ChannelRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 137,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.JWTRouteTest",
      "timestamp": "2020-09-11T09:14:25",
      "testcase": [
        {
          "name": "JWTRouteTest should generate correct JWT",
          "classname": "io.lenses.http.routes.JWTRouteTest",
          "time": 124,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JWTRouteTest should generate token respecting life time",
          "classname": "io.lenses.http.routes.JWTRouteTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 13,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.ConsumersRoutesIntegrationTest",
      "timestamp": "2020-09-11T09:14:50",
      "testcase": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.ConsumersRoutesIntegrationTest",
          "time": 13,
          "failure": null,
          "error": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.ConsumersRoutesIntegrationTest.<init>(ConsumersRoutesIntegrationTest.scala:79)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "skipped": false
        }
      ]
    },
    {
      "time": 56,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.UserProfileRoutesTest",
      "timestamp": "2020-09-11T09:14:29",
      "testcase": [
        {
          "name": "get-put-put-del operation on profile",
          "classname": "io.lenses.http.routes.UserProfileRoutesTest",
          "time": 56,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1952,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.LiveTopicCounterWsRoutesTest",
      "timestamp": "2020-09-11T09:14:22",
      "testcase": [
        {
          "name": "TopicCounterWsRoutes should close the stream with a generic error if the topic is not found",
          "classname": "io.lenses.http.routes.LiveTopicCounterWsRoutesTest",
          "time": 1643,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TopicCounterWsRoutes should close the stream with an error if the user has no access",
          "classname": "io.lenses.http.routes.LiveTopicCounterWsRoutesTest",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TopicCounterWsRoutes should return a stream of counts to an authorised used",
          "classname": "io.lenses.http.routes.LiveTopicCounterWsRoutesTest",
          "time": 277,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 31,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 1,
      "name": "io.lenses.http.routes.utils.SortingSpec",
      "timestamp": "2020-09-11T09:14:59",
      "testcase": [
        {
          "name": "sorter should sort in ascending order when requested",
          "classname": "io.lenses.http.routes.utils.SortingSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "sorter should sort in descending order when requested",
          "classname": "io.lenses.http.routes.utils.SortingSpec",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2030,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.LicenseRoutesTests",
      "timestamp": "2020-09-11T09:14:21",
      "testcase": [
        {
          "name": "LicenseRoutes should return 403 when the user is not logged in",
          "classname": "io.lenses.http.routes.LicenseRoutesTests",
          "time": 1400,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LicenseRoutes should return current license info",
          "classname": "io.lenses.http.routes.LicenseRoutesTests",
          "time": 572,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LicenseRoutes should updates the license",
          "classname": "io.lenses.http.routes.LicenseRoutesTests",
          "time": 47,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LicenseRoutes should returns 400 on invalid license",
          "classname": "io.lenses.http.routes.LicenseRoutesTests",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2479,
      "tests": 38,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.AlertRoutesTest",
      "timestamp": "2020-09-11T09:14:33",
      "testcase": [
        {
          "name": "Fail to READ with (Unauthorized) if user is not logged-in",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 257,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Get paged alerts",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Get alerts with filters",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 27,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Get alerts for first page as default",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Fail paged alerts for invalid page number",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 22,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Fail paged alerts for invalid pageSize number",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Fail paged alerts for missing pageSize parameter",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Delete alerts before given timestamp",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 36,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Return BadRequest if request to delete alerts does not contain valid timestamp",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 279,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Be forbidden to delete alerts for user without permission",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 264,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return alerts settings",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 42,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Be forbidden to list alert settings for user without permission",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return 404 when getting conditions for an alert setting not supporting conditions",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 25,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add/delete alert rule conditions with channels",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 83,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Be forbidden to add alert conditions for user without permission",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Be forbidden to update alert conditions for user without permission",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 20,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Be forbidden to delete alert conditions for user without permission",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add a consumer lag alert rule using JSON object payload",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add a data produced alert rule using JSON object payload",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "respond with bad request if any of the supplied channel ids is invalid (conditions)",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 40,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update an alert setting condition",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 49,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update a consumer lag alert rule using JSON object payload",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update a data produced alert rule using JSON object payload",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fail to add conditions for an alert setting not supporting conditions",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 266,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enable/disable an alert setting",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 548,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Be forbidden to update fixed alerts for user without permission",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "add/remove some channels for a fixed alert setting",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 60,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "respond with bad request if any of the supplied channel ids is invalid (setting)",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license check - getting alert events",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license check - deleting alert events",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 39,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license check - getting alert settings",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license check - enabling alert setting",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license check - posting alert setting condition",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license check - posting alert setting condition, max check failing",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enabled not available",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enabled not available",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license check - putting alert setting condition",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license check - deleting alert setting condition",
          "classname": "io.lenses.http.routes.AlertRoutesTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.ConsumersRoutesBlackListTest",
      "timestamp": "2020-09-11T09:14:36",
      "testcase": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.ConsumersRoutesBlackListTest",
          "time": 3,
          "failure": null,
          "error": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.ConsumersRoutesBlackListTest.<init>(ConsumersRoutesBlackListTest.scala:67)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "skipped": false
        }
      ]
    },
    {
      "time": 7,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.websocket.WebSocketMessageEnvelopeSpec",
      "timestamp": "2020-09-11T09:14:47",
      "testcase": [
        {
          "name": "WebSocketMessageEnvelope can create messages should create data message",
          "classname": "io.lenses.http.routes.websocket.WebSocketMessageEnvelopeSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketMessageEnvelope can create messages should create error message",
          "classname": "io.lenses.http.routes.websocket.WebSocketMessageEnvelopeSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketMessageEnvelope can create messages should create heartbeat message",
          "classname": "io.lenses.http.routes.websocket.WebSocketMessageEnvelopeSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketMessageEnvelope can encode JSON should write sample data type to json",
          "classname": "io.lenses.http.routes.websocket.WebSocketMessageEnvelopeSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketMessageEnvelope can encode JSON should write heartbeat type to json",
          "classname": "io.lenses.http.routes.websocket.WebSocketMessageEnvelopeSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketMessageEnvelope can encode JSON should write error message to json",
          "classname": "io.lenses.http.routes.websocket.WebSocketMessageEnvelopeSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 5135,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.AuditSSERoutesTest",
      "timestamp": "2020-09-11T09:14:53",
      "testcase": [
        {
          "name": "Get Audit in real time",
          "classname": "io.lenses.http.routes.AuditSSERoutesTest",
          "time": 77,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Audits are not pushed to the clients if the license disables it",
          "classname": "io.lenses.http.routes.AuditSSERoutesTest",
          "time": 5057,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 7876,
      "tests": 20,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.ApprovalRoutesTest",
      "timestamp": "2020-09-11T09:14:59",
      "testcase": [
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals/:id fetches a single request",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 438,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals/:id 404 on not found",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 388,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals paginates results",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 417,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals filters by entityName",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 421,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals filters by approvalStatus",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 425,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals sorts by entityName",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 410,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals sorts by createdBy",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 468,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals sorts by createdAt",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 390,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals fails without permissions",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 373,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should PUT /api/v1/approvals/:id/reject succeeds with a pending request",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 369,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should PUT /api/v1/approvals/:id/reject fails with an approved request",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 398,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should PUT /api/v1/approvals/:id/approve succeeds with a pending request",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 373,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should PUT /api/v1/approvals/:id/approve fails with an approved request",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 388,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should PUT /api/v1/approvals/:id/approve sets a request to failed when topic creation fails",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 368,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ honours namspaced topic permissions",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 372,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ supplies the topic config default when these are not set",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 368,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ creates a new topic request",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 377,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ fails if topic name already exists",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 371,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ fails if replication > brokers in cluster",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 368,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ fails on invalid topicConfig values",
          "classname": "io.lenses.http.routes.ApprovalRoutesTest",
          "time": 395,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.KafkaConnectorStatusResponseTest",
      "timestamp": "2020-09-11T09:14:40",
      "testcase": [
        {
          "name": "can parse the connect response",
          "classname": "io.lenses.http.KafkaConnectorStatusResponseTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "can parse the connect response with Failed status",
          "classname": "io.lenses.http.KafkaConnectorStatusResponseTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 123,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.DatasetMessageProducedMetricsRoutesSpec",
      "timestamp": "2020-09-11T09:15:01",
      "testcase": [
        {
          "name": "DatasetMessageProducedMetricsRoutes should return 403 when user don't have ShowTopicAction permission",
          "classname": "io.lenses.http.routes.DatasetMessageProducedMetricsRoutesSpec",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMessageProducedMetricsRoutes should forward error from service",
          "classname": "io.lenses.http.routes.DatasetMessageProducedMetricsRoutesSpec",
          "time": 42,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMessageProducedMetricsRoutes should return data for last 30 days",
          "classname": "io.lenses.http.routes.DatasetMessageProducedMetricsRoutesSpec",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 5,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.JdbcRoutesJsonTest",
      "timestamp": "2020-09-11T09:14:40",
      "testcase": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.JdbcRoutesJsonTest",
          "time": 5,
          "failure": null,
          "error": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.JdbcRoutesJsonTest.<init>(JdbcRoutesJsonTest.scala:122)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "skipped": false
        }
      ]
    },
    {
      "time": 2969,
      "tests": 20,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.KafkaConnectProxyTest",
      "timestamp": "2020-09-11T09:14:26",
      "testcase": [
        {
          "name": "returns kafka_cluster_id",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 1892,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns connector plugins when permission allows it",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 66,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns the connectors registered",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 72,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns the sink connector details when the permissions allows it",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 284,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns 403 when trying to get the details of a sink connector when one of the topics is not in the namespace permissions",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Pass successful POST message to kafka, and send audit event",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 51,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Pass pause message to kafka, and send audit event",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 72,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Pass resume message to kafka, and send audit event",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 108,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Pass restart message to kafka, and send audit event",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 67,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Pass restart task message to kafka, and send audit event",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 64,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Don't pass restart message to kafka and return FORBIDDEN if missing ManageConnectorsPermission permission",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 72,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return 403 when updating a sink connector and one of the topics is not in the namespace",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return 403 when updating a sink connector and one of the topics is not allowed to query from",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return 403 when registering a new sink connector if one of the topics is not in the namespace list",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return 403 when registering a new sink connector if one of the topics is not allowed to query from",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return 403 when registering a new source connector if one of the topics is not allowed to insert into",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return 403 when registering a new source connector if one of the topics is not in the namespace permissions",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return 403 when updating a source connector and one of the topics is not allowed to insert into",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns the sink connector status",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 80,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns the sink connector status with worker info obfuscated",
          "classname": "io.lenses.http.routes.KafkaConnectProxyTest",
          "time": 45,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 12967,
      "tests": 19,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
      "timestamp": "2020-09-11T09:14:28",
      "testcase": [
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals/:id fetches a single request",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 4650,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals/:id 404 on not found",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 610,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals paginates results",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 507,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals filters by entityName",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 485,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals filters by approvalStatus",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 570,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals sorts by entityName",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 457,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals sorts by createdBy",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 523,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should GET /api/v1/approvals fails without permissions",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 480,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should PUT /api/v1/approvals/:id/reject succeeds with a pending request",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 442,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should PUT /api/v1/approvals/:id/reject fails with an approved request",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 445,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should PUT /api/v1/approvals/:id/approve succeeds with a pending request",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 420,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should PUT /api/v1/approvals/:id/approve fails with an approved request",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 430,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should PUT /api/v1/approvals/:id/approve sets a request to failed when topic creation fails",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 446,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ honours namespaced topic permissions",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 454,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ supplies the topic config default when these are not set",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 436,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ creates a new topic request",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 415,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ fails if topic name already exists",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 407,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ fails if replication > brokers in cluster",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 409,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRoutes should POST /api/v1/approvals/ fails on invalid topicConfig values",
          "classname": "io.lenses.http.routes.ApprovalRoutesLicenseTest",
          "time": 380,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 247,
      "tests": 11,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.ElasticSearchRoutesTest",
      "timestamp": "2020-09-11T09:14:27",
      "testcase": [
        {
          "name": "ElasticSearchRoutes should Return unauthorised when invalid auth details sent",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 92,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ElasticSearchRoutes should Return 404 for non-existent index",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ElasticSearchRoutes should Return 400 for non-existent connection",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ElasticSearchRoutes should Return detailed info for specific index",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 20,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ElasticSearchRoutes should Return list of indexes for all connections",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ElasticSearchRoutes should Return list of indexes for specific connections",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ElasticSearchRoutes should include system indexes if includeSystemIndexes is true",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ElasticSearchRoutes should exclude system indexes if includeSystemIndexes is false",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ElasticSearchRoutes should Remove schema if necessary",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ElasticSearchRoutes should Exclude inaccessible topics and return only the permissions that the user has",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ElasticSearchRoutes should Returns the health status of known ES connections",
          "classname": "io.lenses.http.routes.ElasticSearchRoutesTest",
          "time": 41,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 51,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.WebSocketRoutesSpec",
      "timestamp": "2020-09-11T09:14:41",
      "testcase": [
        {
          "name": "WebSocketRoutes should return services metrics",
          "classname": "io.lenses.http.routes.WebSocketRoutesSpec",
          "time": 51,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 174,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.DashboardRoutesHideSensitiveInformationTest",
      "timestamp": "2020-09-11T09:14:24",
      "testcase": [
        {
          "name": "hides services sensitive information",
          "classname": "io.lenses.http.routes.DashboardRoutesHideSensitiveInformationTest",
          "time": 174,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 10012,
      "tests": 2,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.PrometheusRoutesTest",
      "timestamp": "2020-09-11T09:14:45",
      "testcase": [
        {
          "name": "fetch prometheus /metrics when no consumer",
          "classname": "io.lenses.http.routes.PrometheusRoutesTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fetch prometheus /metrics with consumer lag",
          "classname": "io.lenses.http.routes.PrometheusRoutesTest",
          "time": 10007,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.http.routes.PrometheusRoutesTest.createTopic(PrometheusRoutesTest.scala:43)\n\tat io.lenses.http.routes.PrometheusRoutesTest.$anonfun$new$3(PrometheusRoutesTest.scala:108)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.PrometheusRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(PrometheusRoutesTest.scala:43)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.PrometheusRoutesTest.run(PrometheusRoutesTest.scala:43)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 105,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.LoginRoutesTest",
      "timestamp": "2020-09-11T09:14:49",
      "testcase": [
        {
          "name": "Login",
          "classname": "io.lenses.http.routes.LoginRoutesTest",
          "time": 49,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Logout",
          "classname": "io.lenses.http.routes.LoginRoutesTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Saml Login Routes should support login and audit the event",
          "classname": "io.lenses.http.routes.LoginRoutesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Enabled SSO paths should offer the mapping of the enabled SSO provider to the SAML path to be used by the FrontEnd",
          "classname": "io.lenses.http.routes.LoginRoutesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Enabled SSO paths should offer an empty map when SAML SSO is not enabled",
          "classname": "io.lenses.http.routes.LoginRoutesTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 21,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.UsageRoutesTest",
      "timestamp": "2020-09-11T09:14:41",
      "testcase": [
        {
          "name": "SSO Usage Routes should return empty if SSO is not enabled",
          "classname": "io.lenses.http.routes.UsageRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "SSO Usage Routes should return the name of the SSO provider mapped to the SSO endpoint when SSO is enabled",
          "classname": "io.lenses.http.routes.UsageRoutesTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 131,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.websocket.IncomingTokenMessageSpec",
      "timestamp": "2020-09-11T09:14:24",
      "testcase": [
        {
          "name": "JSON encoding should decode IncomingTokenMessage from json",
          "classname": "io.lenses.http.routes.websocket.IncomingTokenMessageSpec",
          "time": 131,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 142,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.BasicSecurityTest",
      "timestamp": "2020-09-11T09:14:28",
      "testcase": [
        {
          "name": "AuthManager should return 401 if an invalid token is presented",
          "classname": "io.lenses.http.routes.BasicSecurityTest",
          "time": 34,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuthManager should return 401 if no token is presented",
          "classname": "io.lenses.http.routes.BasicSecurityTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuthManager should return 200 with token when logging in",
          "classname": "io.lenses.http.routes.BasicSecurityTest",
          "time": 83,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuthManager should return 401 if the password is incorrect",
          "classname": "io.lenses.http.routes.BasicSecurityTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuthManager should return 200 for a valid token with permissions",
          "classname": "io.lenses.http.routes.BasicSecurityTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuthManager should logout a user and mark the token as invalid",
          "classname": "io.lenses.http.routes.BasicSecurityTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6961,
      "tests": 11,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
      "timestamp": "2020-09-11T09:14:41",
      "testcase": [
        {
          "name": "WebSocketRoutesFlowCreator should fail in case of getting binary message",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 91,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketRoutesFlowCreator should fail in case of getting streamed message",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 74,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketRoutesFlowCreator should fail in case of getting token message in wrong format",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 102,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketRoutesFlowCreator should fail in case of not getting any message within tokenMaxWaitingTime",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 1095,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketRoutesFlowCreator should fail in case of token being not authenticated",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 98,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketRoutesFlowCreator should fail in case of token being not authorized",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 76,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketRoutesFlowCreator should fail in case of token having only partial authorization",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 71,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketRoutesFlowCreator should fail in case of getting error from source",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 74,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketRoutesFlowCreator should allow custom error handling",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 79,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketRoutesFlowCreator should get correct connection",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 77,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "WebSocketRoutesFlowCreator should get correct connection with message and heartbeat messages",
          "classname": "io.lenses.http.routes.websocket.WebSocketRoutesFlowCreatorSpec",
          "time": 5125,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 5040,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.AlertsWsRoutesTest",
      "timestamp": "2020-09-11T09:14:56",
      "testcase": [
        {
          "name": "Get Alerts in real time",
          "classname": "io.lenses.http.routes.AlertsWsRoutesTest",
          "time": 5040,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 0,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.QuotasRoutesTest",
      "timestamp": "2020-09-11T09:14:24",
      "testcase": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.QuotasRoutesTest",
          "time": 0,
          "failure": null,
          "error": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.QuotasRoutesTest.<init>(QuotaRoutesTest.scala:40)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "skipped": false
        }
      ]
    },
    {
      "time": 0,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.TopicMetadataRoutesTest",
      "timestamp": "2020-09-11T09:14:56",
      "testcase": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.TopicMetadataRoutesTest",
          "time": 0,
          "failure": null,
          "error": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicMetadataRoutesTest.<init>(TopicMetadataRoutesTest.scala:86)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "skipped": false
        }
      ]
    },
    {
      "time": 918,
      "tests": 18,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.AuditRoutesTest",
      "timestamp": "2020-09-11T09:14:48",
      "testcase": [
        {
          "name": "Fail to READ with (Unauthorized) if user is not logged-in",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 37,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Get paginated audits",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 36,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Returns 402 if license does not allow audits",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Get first page of audits if page parameter is not provided",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Fail paged alerts for invalid page number",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Fail paged alerts for invalid pageSize number",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Fail paged alerts for missing pageSize parameter",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "pass filters to auditStore request",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 22,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Return 400 on invalid change filter",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Return 400 on invalid resource filter",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Delete audits before given timestamp",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Rejects 402 for Delete action",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Return BadRequest if request to delete audits does not contain valid timestamp",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 266,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return audit values",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 192,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return 402 for audit values if no license",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 91,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fail for unknown audit value",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 100,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fail for audit value throwing exception",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fail for unauthenticated audit values request",
          "classname": "io.lenses.http.routes.AuditRoutesTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 193,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.DatasetRoutesTest",
      "timestamp": "2020-09-11T09:14:56",
      "testcase": [
        {
          "name": "GET /api/v1/datasets?pageSize=5&page=2 renders a paginated list of datasets from all connections",
          "classname": "io.lenses.http.routes.DatasetRoutesTest",
          "time": 160,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "GET /api/v1/datasets?pageSize=3&page=4 final page shows correct pagesAmount",
          "classname": "io.lenses.http.routes.DatasetRoutesTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "GET /api/v1/datasets?connections=c1&connections=c2 filters datasets by the supplied connection list",
          "classname": "io.lenses.http.routes.DatasetRoutesTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "GET /api/v1/datasets?query=nomatch query with no match returns empty result",
          "classname": "io.lenses.http.routes.DatasetRoutesTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "GET /api/v1/datasets?query=match4",
          "classname": "io.lenses.http.routes.DatasetRoutesTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "GET /api/v1/datasets?includeSystemEntities=true",
          "classname": "io.lenses.http.routes.DatasetRoutesTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 49,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.ConfigRoutesTest",
      "timestamp": "2020-09-11T09:14:49",
      "testcase": [
        {
          "name": "Get the lenses config values exposed to an API",
          "classname": "io.lenses.http.routes.ConfigRoutesTest",
          "time": 49,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 157289,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.SchemaRegistryProxyTest",
      "timestamp": "2020-09-11T09:14:47",
      "testcase": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.SchemaRegistryProxyTest",
          "time": 157289,
          "failure": null,
          "error": {
            "message": "java.lang.InterruptedException",
            "type": "org.apache.kafka.common.errors.InterruptException",
            "stackTrace": "org.apache.kafka.common.errors.InterruptException: java.lang.InterruptedException\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:937)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:856)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:743)\n\tat io.lenses.http.routes.SchemaRegistryProxyTest.$anonfun$createTopic$2(SchemaRegistryProxyTest.scala:110)\n\tat scala.collection.TraversableLike.$anonfun$map$1(TraversableLike.scala:238)\n\tat scala.collection.Iterator.foreach(Iterator.scala:941)\n\tat scala.collection.Iterator.foreach$(Iterator.scala:941)\n\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1429)\n\tat scala.collection.IterableLike.foreach(IterableLike.scala:74)\n\tat scala.collection.IterableLike.foreach$(IterableLike.scala:73)\n\tat scala.collection.AbstractIterable.foreach(Iterable.scala:56)\n\tat scala.collection.TraversableLike.map(TraversableLike.scala:238)\n\tat scala.collection.TraversableLike.map$(TraversableLike.scala:231)\n\tat scala.collection.AbstractTraversable.map(Traversable.scala:108)\n\tat io.lenses.http.routes.SchemaRegistryProxyTest.createTopic(SchemaRegistryProxyTest.scala:108)\n\tat io.lenses.http.routes.SchemaRegistryProxyTest.beforeAll(SchemaRegistryProxyTest.scala:96)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:212)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.SchemaRegistryProxyTest.run(SchemaRegistryProxyTest.scala:30)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.InterruptedException\n\tat java.lang.Object.wait(Native Method)\n\tat org.apache.kafka.common.utils.SystemTime.waitObject(SystemTime.java:60)\n\tat org.apache.kafka.clients.producer.internals.ProducerMetadata.awaitUpdate(ProducerMetadata.java:97)\n\tat org.apache.kafka.clients.producer.KafkaProducer.waitOnMetadata(KafkaProducer.java:999)\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:876)\n\t... 43 more"
          },
          "skipped": false
        }
      ]
    },
    {
      "time": 115198,
      "tests": 31,
      "failures": 31,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.TopicRoutesTest",
      "timestamp": "2020-09-11T09:14:29",
      "testcase": [
        {
          "name": "even when a 401 - due to a authentication token failure, the CORS headers should be in the response",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3713,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$1.<init>(TopicRoutesTest.scala:115)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$1(TopicRoutesTest.scala:115)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "not allow creating a topic for an user who has only read access",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3707,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$2.<init>(TopicRoutesTest.scala:129)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$4(TopicRoutesTest.scala:129)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return topics information based on namespace authorities",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3707,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$3.<init>(TopicRoutesTest.scala:140)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$7(TopicRoutesTest.scala:140)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return paginated short topics information based on namesapce authorities",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3710,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$4.<init>(TopicRoutesTest.scala:177)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$9(TopicRoutesTest.scala:177)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "allow for paginated filtering of the short topics information",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3720,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$5.<init>(TopicRoutesTest.scala:216)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$11(TopicRoutesTest.scala:216)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "include system topics only if includeSystemTopics is set to true",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3717,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$6.<init>(TopicRoutesTest.scala:231)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$13(TopicRoutesTest.scala:231)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "sort results by fields",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3732,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$7.<init>(TopicRoutesTest.scala:291)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$22(TopicRoutesTest.scala:291)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return topics short summary containing allowed actions",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$13.<init>(TopicRoutesTest.scala:318)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$69(TopicRoutesTest.scala:318)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "not allow creating a topic for an user without a Namespace Permission to allow it",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3709,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$14.<init>(TopicRoutesTest.scala:334)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$71(TopicRoutesTest.scala:334)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "not allow deleting a topic if Delete topic Permission is not present",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3708,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$15.<init>(TopicRoutesTest.scala:351)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$74(TopicRoutesTest.scala:351)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "not allow setting a topic configuration if there is no ConfigureTopic Permission present",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3712,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$16.<init>(TopicRoutesTest.scala:375)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$78(TopicRoutesTest.scala:375)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "allow creating a topic for an user with CreateTopic Permission",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$17.<init>(TopicRoutesTest.scala:407)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$83(TopicRoutesTest.scala:407)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "not allow creating a topic for an user without CreateTopic Permission",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3717,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$18.<init>(TopicRoutesTest.scala:424)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$86(TopicRoutesTest.scala:424)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "fail on setting a wrong topic configuration KEY",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3730,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$19.<init>(TopicRoutesTest.scala:441)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$89(TopicRoutesTest.scala:441)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "fail on setting a wrong topic configuration VALUE",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3717,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$20.<init>(TopicRoutesTest.scala:468)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$93(TopicRoutesTest.scala:468)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "get all possible topic configuration options",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3717,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$21.<init>(TopicRoutesTest.scala:483)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$96(TopicRoutesTest.scala:483)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "should get a list of available configs for a topic",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$22.<init>(TopicRoutesTest.scala:511)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$101(TopicRoutesTest.scala:511)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "not allow adding partitions for a user without ConfigureTopic Permission",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$23.<init>(TopicRoutesTest.scala:542)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$106(TopicRoutesTest.scala:542)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return 404 if topic not found on attempt to add partition",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$24.<init>(TopicRoutesTest.scala:561)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$109(TopicRoutesTest.scala:561)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return 400 on attempt to add partition if number of topics is not greater than the existing number",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3717,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$25.<init>(TopicRoutesTest.scala:580)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$112(TopicRoutesTest.scala:580)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return 200 on successfully adding partitions",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$26.<init>(TopicRoutesTest.scala:615)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$116(TopicRoutesTest.scala:615)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "/api/topics/<topic>",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3719,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$27.<init>(TopicRoutesTest.scala:655)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$120(TopicRoutesTest.scala:655)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "v2 partitions endpoint expected payload response",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$28.<init>(TopicRoutesTest.scala:703)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$124(TopicRoutesTest.scala:703)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "v2 partitions endpoint with no JMX reponse return null bytes",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3719,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$29.<init>(TopicRoutesTest.scala:790)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$129(TopicRoutesTest.scala:790)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return effective begin partition for compacted topics",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$30.<init>(TopicRoutesTest.scala:849)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$133(TopicRoutesTest.scala:849)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return 400 on being unable to delete topic messages due to enabled compacting",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3714,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$31.<init>(TopicRoutesTest.scala:901)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$137(TopicRoutesTest.scala:901)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return 400 when offset out of bounds",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3712,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$32.<init>(TopicRoutesTest.scala:931)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$141(TopicRoutesTest.scala:931)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return 400 when topic or partition not found",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$33.<init>(TopicRoutesTest.scala:942)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$143(TopicRoutesTest.scala:942)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return 500 when something mysterious goes wrong",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3713,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$34.<init>(TopicRoutesTest.scala:953)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$145(TopicRoutesTest.scala:953)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return 200 when all is correct",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3712,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$35.<init>(TopicRoutesTest.scala:964)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$147(TopicRoutesTest.scala:964)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return 403 for user without InsertDataAction Permission on that topic",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$36.<init>(TopicRoutesTest.scala:975)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$149(TopicRoutesTest.scala:975)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 995,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.DatasetMetricsRoutesSpec",
      "timestamp": "2020-09-11T09:14:25",
      "testcase": [
        {
          "name": "DatasetMetricsRoutes can ws endpoint should return given stream with initial message when the token is sent from the client in proper time",
          "classname": "io.lenses.http.routes.DatasetMetricsRoutesSpec",
          "time": 460,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMetricsRoutes can ws endpoint should close the stream nicely when the token is NOT sent from the client in proper time",
          "classname": "io.lenses.http.routes.DatasetMetricsRoutesSpec",
          "time": 145,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMetricsRoutes can ws endpoint should return Invalid token received when provided token was not correct",
          "classname": "io.lenses.http.routes.DatasetMetricsRoutesSpec",
          "time": 33,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMetricsRoutes can ws endpoint should return forbidden when user dont have permission for endpoint",
          "classname": "io.lenses.http.routes.DatasetMetricsRoutesSpec",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMetricsRoutes can ws endpoint should close the stream nicely on unexpected client message",
          "classname": "io.lenses.http.routes.DatasetMetricsRoutesSpec",
          "time": 36,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMetricsRoutes can ws endpoint should send HEARTBEAT messages",
          "classname": "io.lenses.http.routes.DatasetMetricsRoutesSpec",
          "time": 257,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DatasetMetricsRoutes can ws endpoint should reject non websocket requests",
          "classname": "io.lenses.http.routes.DatasetMetricsRoutesSpec",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.TopicMetadataRoutesNoSRTest",
      "timestamp": "2020-09-11T09:14:43",
      "testcase": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.TopicMetadataRoutesNoSRTest",
          "time": 1,
          "failure": null,
          "error": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicMetadataRoutesNoSRTest.<init>(TopicMetadataRoutesNoSRTest.scala:58)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "skipped": false
        }
      ]
    },
    {
      "time": 1733,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.DashboardRoutesTest",
      "timestamp": "2020-09-11T09:15:00",
      "testcase": [
        {
          "name": "include audits if user has ViewAuditLogsPermission",
          "classname": "io.lenses.http.routes.DashboardRoutesTest",
          "time": 28,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "include audits if user has RootPermission",
          "classname": "io.lenses.http.routes.DashboardRoutesTest",
          "time": 24,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "exclude audits if user does not have permission",
          "classname": "io.lenses.http.routes.DashboardRoutesTest",
          "time": 25,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "/api/v1/telemetry should return new telemetry payload",
          "classname": "io.lenses.http.routes.DashboardRoutesTest",
          "time": 1656,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 1,
      "name": "io.lenses.http.routes.AlertsSSERoutesTest",
      "timestamp": "2020-09-11T09:14:56",
      "testcase": [
        {
          "name": "Get Alerts in real time",
          "classname": "io.lenses.http.routes.AlertsSSERoutesTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        }
      ]
    },
    {
      "time": 462,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.GroupsTests",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "no settings enables all",
          "classname": "io.lenses.license.GroupsTests",
          "time": 462,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables service account",
          "classname": "io.lenses.license.GroupsTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables service account and sets a limit",
          "classname": "io.lenses.license.GroupsTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when max service account is 0",
          "classname": "io.lenses.license.GroupsTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when enabled is wrong",
          "classname": "io.lenses.license.GroupsTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 10,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.LdapTests",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "no settings enables all",
          "classname": "io.lenses.license.LdapTests",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables service account",
          "classname": "io.lenses.license.LdapTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables service account and sets a limit",
          "classname": "io.lenses.license.LdapTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when max service account is 0",
          "classname": "io.lenses.license.LdapTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when enabled is wrong",
          "classname": "io.lenses.license.LdapTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 38,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.LicenseCheckManagerTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "Default license check manager implementation should check single license property",
          "classname": "io.lenses.license.LicenseCheckManagerTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Default license check manager implementation should perform 'oneOf' license checks",
          "classname": "io.lenses.license.LicenseCheckManagerTest",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 624,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.SQLSettingsTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "no settings enables all",
          "classname": "io.lenses.license.SQLSettingsTest",
          "time": 619,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables all",
          "classname": "io.lenses.license.SQLSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables streaming",
          "classname": "io.lenses.license.SQLSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables sql",
          "classname": "io.lenses.license.SQLSettingsTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "set max processors",
          "classname": "io.lenses.license.SQLSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when the restriction is 0",
          "classname": "io.lenses.license.SQLSettingsTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when the restriction is not valid number",
          "classname": "io.lenses.license.SQLSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when the boolean flags is wrong",
          "classname": "io.lenses.license.SQLSettingsTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.KerberosSecurityTests",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "no settings enables all",
          "classname": "io.lenses.license.KerberosSecurityTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables service account",
          "classname": "io.lenses.license.KerberosSecurityTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables service account and sets a limit",
          "classname": "io.lenses.license.KerberosSecurityTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when max service account is 0",
          "classname": "io.lenses.license.KerberosSecurityTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when enabled is wrong",
          "classname": "io.lenses.license.KerberosSecurityTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2608,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.JsonWebTokenTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "JsonWebToken should generate a license, validate and return the attributes",
          "classname": "io.lenses.license.JsonWebTokenTest",
          "time": 434,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JsonWebToken should generate a license, validate, read the keys from files and return the attributes",
          "classname": "io.lenses.license.JsonWebTokenTest",
          "time": 262,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JsonWebToken should generate a license, validate encrypt and decrypt with AesSah and return the attributes",
          "classname": "io.lenses.license.JsonWebTokenTest",
          "time": 144,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JsonWebToken should generate a license, validate and return false since it expired",
          "classname": "io.lenses.license.JsonWebTokenTest",
          "time": 1179,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JsonWebToken should generate a license, validate and return error when issuer is different",
          "classname": "io.lenses.license.JsonWebTokenTest",
          "time": 75,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JsonWebToken should generate a license, validate and return error when audience is different",
          "classname": "io.lenses.license.JsonWebTokenTest",
          "time": 389,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "JsonWebToken should generate a license, validate and return error when subject is different",
          "classname": "io.lenses.license.JsonWebTokenTest",
          "time": 125,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 598,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.AuditSettingsTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "no setting enables it",
          "classname": "io.lenses.license.AuditSettingsTest",
          "time": 597,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enable audit and integration",
          "classname": "io.lenses.license.AuditSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables all",
          "classname": "io.lenses.license.AuditSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables audits",
          "classname": "io.lenses.license.AuditSettingsTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables integration",
          "classname": "io.lenses.license.AuditSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception if the value is not boolean",
          "classname": "io.lenses.license.AuditSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 128,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.CustomSecurityTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "no setting enables it",
          "classname": "io.lenses.license.CustomSecurityTest",
          "time": 115,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enable approval",
          "classname": "io.lenses.license.CustomSecurityTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables approval",
          "classname": "io.lenses.license.CustomSecurityTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception if the value is not boolean",
          "classname": "io.lenses.license.CustomSecurityTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.RootSecurityTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "no setting enables it",
          "classname": "io.lenses.license.RootSecurityTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enable approval",
          "classname": "io.lenses.license.RootSecurityTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables approval",
          "classname": "io.lenses.license.RootSecurityTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception if the value is not boolean",
          "classname": "io.lenses.license.RootSecurityTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 83,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.ConnectionsSettingsTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "no setting enables it",
          "classname": "io.lenses.license.ConnectionsSettingsTest",
          "time": 67,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enable approval",
          "classname": "io.lenses.license.ConnectionsSettingsTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables approval",
          "classname": "io.lenses.license.ConnectionsSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception if the value is not boolean",
          "classname": "io.lenses.license.ConnectionsSettingsTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 116,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.SSOSecurityTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "no setting enables it",
          "classname": "io.lenses.license.SSOSecurityTest",
          "time": 103,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enable approval",
          "classname": "io.lenses.license.SSOSecurityTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables approval",
          "classname": "io.lenses.license.SSOSecurityTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception if the value is not boolean",
          "classname": "io.lenses.license.SSOSecurityTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 120,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.ApprovalSettingsTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "no setting enables it",
          "classname": "io.lenses.license.ApprovalSettingsTest",
          "time": 101,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enable approval",
          "classname": "io.lenses.license.ApprovalSettingsTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables approval",
          "classname": "io.lenses.license.ApprovalSettingsTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception if the value is not boolean",
          "classname": "io.lenses.license.ApprovalSettingsTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 612,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.DataSettingsTests",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "no settings default to enabled",
          "classname": "io.lenses.license.DataSettingsTests",
          "time": 611,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "sets the flags to false",
          "classname": "io.lenses.license.DataSettingsTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws LicenseException when invalid value is provied",
          "classname": "io.lenses.license.DataSettingsTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 56,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.ReadLicensePbkTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "BasicLicenseToken should read the primary key token",
          "classname": "io.lenses.license.ReadLicensePbkTest",
          "time": 56,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 452,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.ServiceAccountTests",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "no settings enables all",
          "classname": "io.lenses.license.ServiceAccountTests",
          "time": 452,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables service account",
          "classname": "io.lenses.license.ServiceAccountTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables service account and sets a limit",
          "classname": "io.lenses.license.ServiceAccountTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when max service account is 0",
          "classname": "io.lenses.license.ServiceAccountTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when enabled is wrong",
          "classname": "io.lenses.license.ServiceAccountTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 606,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.KafkaSettingsTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "no setting enables it",
          "classname": "io.lenses.license.KafkaSettingsTest",
          "time": 605,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enable all",
          "classname": "io.lenses.license.KafkaSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables all",
          "classname": "io.lenses.license.KafkaSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables acls",
          "classname": "io.lenses.license.KafkaSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables quotas",
          "classname": "io.lenses.license.KafkaSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables consumers offsets",
          "classname": "io.lenses.license.KafkaSettingsTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception if the value is not boolean",
          "classname": "io.lenses.license.KafkaSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 519,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.BasicSecurityTests",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "no settings enables all",
          "classname": "io.lenses.license.BasicSecurityTests",
          "time": 515,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables service account",
          "classname": "io.lenses.license.BasicSecurityTests",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables service account and sets a limit",
          "classname": "io.lenses.license.BasicSecurityTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when max service account is 0",
          "classname": "io.lenses.license.BasicSecurityTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception when enabled is wrong",
          "classname": "io.lenses.license.BasicSecurityTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3220,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.LicenseReaderTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "license parameters are kept based on the JWT settings",
          "classname": "io.lenses.license.LicenseReaderTest",
          "time": 644,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license parameters are kept based on the JWT settings when License has expired",
          "classname": "io.lenses.license.LicenseReaderTest",
          "time": 2267,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license parameters are kept based on the JWT settings for 1 Broker with Max messages",
          "classname": "io.lenses.license.LicenseReaderTest",
          "time": 127,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "read from a file",
          "classname": "io.lenses.license.LicenseReaderTest",
          "time": 183,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 613,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.ApplicationSettingsTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "no setting enables it",
          "classname": "io.lenses.license.ApplicationSettingsTest",
          "time": 609,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enable topology and connectors on K8",
          "classname": "io.lenses.license.ApplicationSettingsTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables topology and connectors on K8",
          "classname": "io.lenses.license.ApplicationSettingsTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables topology",
          "classname": "io.lenses.license.ApplicationSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disables connectors on K8",
          "classname": "io.lenses.license.ApplicationSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws exception if the value is not boolean",
          "classname": "io.lenses.license.ApplicationSettingsTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 532,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.SecuritySettingsTests",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "disable all settings",
          "classname": "io.lenses.license.SecuritySettingsTests",
          "time": 532,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "no settings enables all",
          "classname": "io.lenses.license.SecuritySettingsTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 634,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.LicenseSettingsTests",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "no settings enables everything",
          "classname": "io.lenses.license.LicenseSettingsTests",
          "time": 632,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disable everything",
          "classname": "io.lenses.license.LicenseSettingsTests",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 601,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.AlertSettingsTests",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "no settings default to enabled",
          "classname": "io.lenses.license.AlertSettingsTests",
          "time": 595,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disable integration",
          "classname": "io.lenses.license.AlertSettingsTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enables integration and set the channels and sets a  max of 9",
          "classname": "io.lenses.license.AlertSettingsTests",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "throws an exception if max integration is 0",
          "classname": "io.lenses.license.AlertSettingsTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "enable alerts but not integration",
          "classname": "io.lenses.license.AlertSettingsTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 52,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.LicenseCheckTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "License checks should check if license property is enabled",
          "classname": "io.lenses.license.LicenseCheckTest",
          "time": 47,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "License checks should check if license property is disabled",
          "classname": "io.lenses.license.LicenseCheckTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "License checks should check if max alert rules is reached",
          "classname": "io.lenses.license.LicenseCheckTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1245,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.license.LicenseDirectiveTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "License directive should verify license requirements with license verification manager when license is valid",
          "classname": "io.lenses.license.LicenseDirectiveTest",
          "time": 1180,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "License directive should verify license requirements with license verification manager when license is valid with multiple props",
          "classname": "io.lenses.license.LicenseDirectiveTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "License directive should verify license requirements with license verification manager when license is not valid",
          "classname": "io.lenses.license.LicenseDirectiveTest",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "License directive should verify license requirements with license verification manager when license is not valid for at least one key returns first unsatisfied key",
          "classname": "io.lenses.license.LicenseDirectiveTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "License directive should verify license requirements with license verification manager when license verification fails",
          "classname": "io.lenses.license.LicenseDirectiveTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 297,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.UsernamePasswordAuthenticationProviderTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "UsernamePasswordAuthenticationProvider should authenticate against the password service",
          "classname": "io.lenses.security.authentication.UsernamePasswordAuthenticationProviderTest",
          "time": 292,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UsernamePasswordAuthenticationProvider should skip for missing credentials",
          "classname": "io.lenses.security.authentication.UsernamePasswordAuthenticationProviderTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 273,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.AuthenticationManagerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "AuthManager should search through all AuthenticationProviders until it finds one that succeeds",
          "classname": "io.lenses.security.authentication.AuthenticationManagerTest",
          "time": 60,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuthManager should return a rejection when no AuthenticationProvider succeeds",
          "classname": "io.lenses.security.authentication.AuthenticationManagerTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuthManager should include the implied permissions received from both the authenticationProvider and the permissionProviders",
          "classname": "io.lenses.security.authentication.AuthenticationManagerTest",
          "time": 148,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Managing external authentication providers should allow retrieving a managed provider by its class",
          "classname": "io.lenses.security.authentication.AuthenticationManagerTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Managing external authentication providers should return None if the provider is not managed by this manager",
          "classname": "io.lenses.security.authentication.AuthenticationManagerTest",
          "time": 31,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "External authentication management should delegate external login to the requested provider",
          "classname": "io.lenses.security.authentication.AuthenticationManagerTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "External authentication management should delegate external login callback to the requested provider",
          "classname": "io.lenses.security.authentication.AuthenticationManagerTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "External authentication management should delegate external logout to the requested provider",
          "classname": "io.lenses.security.authentication.AuthenticationManagerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2048,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.InMemoryAccountLockoutStoreTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "return None for a non-existing token",
          "classname": "io.lenses.security.authentication.InMemoryAccountLockoutStoreTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "register a token multiple times",
          "classname": "io.lenses.security.authentication.InMemoryAccountLockoutStoreTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "register a token multiple times until it reaches the max",
          "classname": "io.lenses.security.authentication.InMemoryAccountLockoutStoreTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "register a token multiple times below the max and confirm it's cleanup once the expiry period is completed",
          "classname": "io.lenses.security.authentication.InMemoryAccountLockoutStoreTest",
          "time": 1031,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "register a token multiple times reaching the max and confirm it's cleanup once the expiry period is completed",
          "classname": "io.lenses.security.authentication.InMemoryAccountLockoutStoreTest",
          "time": 1008,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.SchemasAuthorizerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "SchemasAuthorizer should allow ManageSchemasAction if auth has manage schemas permission",
          "classname": "io.lenses.security.authorization.SchemasAuthorizerTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "SchemasAuthorizer should allow ViewSchemasAction if auth has view schemas permission",
          "classname": "io.lenses.security.authorization.SchemasAuthorizerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 724,
      "tests": 11,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.modules.RootSecurityModuleTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "the hashing function returns None if the protocol is not valid",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "the hashing function returns the plain text one if the protocol is missing",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "the hashing function returns the plain text one if the protocol is PLAIN",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "the hashing function returns the plain text one if the protocol is PLaIN",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "the hashing function returns the plain text one if the protocol is plain",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "the hashing function returns the plain text one if the protocol is SHA256",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "the hashing function returns the plain text one if the protocol is sha256",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "test hashing function sha256, hash with leading zero",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RootSecurityModule validates a plain text password",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 648,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RootSecurityModule does not validate a bad password when plain text is used",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "RootSecurityModule validates a sha256 password",
          "classname": "io.lenses.security.modules.RootSecurityModuleTest",
          "time": 20,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 19,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.HttpPluginAuthenticationProviderTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "provider should populate authentication from plugins result",
          "classname": "io.lenses.security.authentication.HttpPluginAuthenticationProviderTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "provider should return failed future if the plugin throws",
          "classname": "io.lenses.security.authentication.HttpPluginAuthenticationProviderTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 0,
      "tests": 0,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.LensesHeaderTokenAuthenticationTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": []
    },
    {
      "time": 295,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.QueryParameterUsernamePasswordExtractorTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "QueryParameterUsernamePasswordExtractor should extract credentials from the query parameters",
          "classname": "io.lenses.security.authentication.QueryParameterUsernamePasswordExtractorTest",
          "time": 292,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "QueryParameterUsernamePasswordExtractor should skip for missing creds",
          "classname": "io.lenses.security.authentication.QueryParameterUsernamePasswordExtractorTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.SQLProcessorsAuthorizerTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "SQLProcessorsAuthorizer should allow ManageSQLProcessorsAction if auth has manage sql permission",
          "classname": "io.lenses.security.authorization.SQLProcessorsAuthorizerTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "SQLProcessorsAuthorizer should allow ViewSqlProcessorspermission if auth has view sql permission",
          "classname": "io.lenses.security.authorization.SQLProcessorsAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 215,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.GroupBasedPermissionProviderTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "GroupBasedPermissionProvider should supplement an authentication",
          "classname": "io.lenses.security.authentication.GroupBasedPermissionProviderTest",
          "time": 215,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 115,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.AuthorizationManagerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "AuthorizationManager should return false when a denied is present",
          "classname": "io.lenses.security.authorization.AuthorizationManagerTest",
          "time": 113,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuthorizationManager should return false when a denied is present regardless of alloweds",
          "classname": "io.lenses.security.authorization.AuthorizationManagerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuthorizationManager should return true when no denied's and at least one allowed",
          "classname": "io.lenses.security.authorization.AuthorizationManagerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuthorizationManager should return false when no denieds and no alloweds",
          "classname": "io.lenses.security.authorization.AuthorizationManagerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 4,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.ManageAuditLogAuthorizerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "ManageAuditLogAuthorizerTest should allow ManageAuditLogsAction if auth has manage audit logs permission",
          "classname": "io.lenses.security.authorization.ManageAuditLogAuthorizerTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 9,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.KafkaSettingsAuthorizerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "KafkaSettingsAuthorizer should allow ManageKafkaSettingsAction if auth has manage Kafka settings permission",
          "classname": "io.lenses.security.authorization.KafkaSettingsAuthorizerTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaSettingsAuthorizer should allow ViewKafkaSettingsAction if auth has view Kafka settings permission",
          "classname": "io.lenses.security.authorization.KafkaSettingsAuthorizerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3473,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.UsernamePasswordAuthenticationProviderAccountLockoutTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "UsernamePasswordAuthenticationProvider enforces the account lock",
          "classname": "io.lenses.security.authentication.UsernamePasswordAuthenticationProviderAccountLockoutTest",
          "time": 3468,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UsernamePasswordAuthenticationProvider resets the attempts on successful login",
          "classname": "io.lenses.security.authentication.UsernamePasswordAuthenticationProviderAccountLockoutTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 4,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.ConnectorsAuthorizerTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "ConnectorsAuthorizer should allow ManageConnectorsAction if auth has manage connectors permission",
          "classname": "io.lenses.security.authorization.ConnectorsAuthorizerTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectorsAuthorizer should allow ViewConnectorsAction if auth has view connectors permission",
          "classname": "io.lenses.security.authorization.ConnectorsAuthorizerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 114,
      "tests": 18,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "topic authorizer should allow CreateTopicAction for any topic if a Namespace has a wildcard",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 78,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should allow CreateTopicAction if an permission has an exact match",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should allow CreateTopicAction if an permission has a wildcard match",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should Pass CreateTopicAction if no applicable authorities",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should allow DropTopicAction for any topic if an permission has a wildcard",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should allow DropTopicAction if an permission has an exact match",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should allow DropTopicAction if an permission has a wildcard match",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should Pass for DropTopicAction if no applicable authorities",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should allow ConfigureTopicAction for any topic if a Namespace has a wildcard",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should allow ConfigureTopicAction if an permission has an exact match",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should allow UpdateSchemaAction for any topic if a Namespace has a wildcard",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should allow UpdateSchemaAction if an permission has an exact match",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should use allow CreateTopic since a wildcard is matching the topic completely",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer should use allow ShowTopic since [foo_b*] is closer to foo_boo than [*oo_b*] and [*]",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "topic authorizer not allow QueryTopic since [foo] only matching [*]",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return Pass if the connection doesn't match",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "support Elasticsearch permissions",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "non-kafka connections should not affect kafka-specific permissions",
          "classname": "io.lenses.security.authorization.KafkaTopicAuthorizerTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 4005,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.ActivityTrackerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "should return active users since date",
          "classname": "io.lenses.security.ActivityTrackerTest",
          "time": 4005,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 7,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.ConnectionsAuthorizerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "ConnectionsAuthorizer should always allow ViewConnectionAction",
          "classname": "io.lenses.security.authorization.ConnectionsAuthorizerTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsAuthorizer should allow ViewConnectionSecretsAction only if auth has manage connections permission",
          "classname": "io.lenses.security.authorization.ConnectionsAuthorizerTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ConnectionsAuthorizer should allow ManageConnectionAction only if auth has manage connections permission",
          "classname": "io.lenses.security.authorization.ConnectionsAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.TopologyAuthorizerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "TopologyAuthorizer should allow ManageTopologyAction if auth has manage topology permission",
          "classname": "io.lenses.security.authorization.TopologyAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TopologyAuthorizer should allow ViewTopologyAction if auth has view topology permission",
          "classname": "io.lenses.security.authorization.TopologyAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 5,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.UserManagementAuthorizerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "UserManagementAuthorizer should allow ManageUsersAction if an permission has ManageUsers",
          "classname": "io.lenses.security.authorization.UserManagementAuthorizerTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserManagementAuthorizer should allow ViewUsersAction if auth has ViewUsers",
          "classname": "io.lenses.security.authorization.UserManagementAuthorizerTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 279,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.StaticPermissionProviderTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "Provider should supplement an authentication",
          "classname": "io.lenses.security.authentication.StaticPermissionProviderTest",
          "time": 279,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 4,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.KafkaConsumersAuthorizerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "KafkaConsumersAuthorizer should allow ManageKafkaConsumersAction if auth has manage Kafka consumers permission",
          "classname": "io.lenses.security.authorization.KafkaConsumersAuthorizerTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaConsumersAuthorizer should allow ViewKafkaConsumersAction if auth has view Kafka consumers permission",
          "classname": "io.lenses.security.authorization.KafkaConsumersAuthorizerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.ViewAuditLogAuthorizerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "ViewAuditLogAuthorizer should allow ViewAuditAction if auth has view audit log permission",
          "classname": "io.lenses.security.authorization.ViewAuditLogAuthorizerTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 279,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.UsernamePermissionProviderTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "UsernamePermissionProvider should supplement an authentication",
          "classname": "io.lenses.security.authentication.UsernamePermissionProviderTest",
          "time": 279,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.BasicUsernamePasswordServiceTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "should check password",
          "classname": "io.lenses.security.authentication.BasicUsernamePasswordServiceTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "should return none for valid user invalid pass",
          "classname": "io.lenses.security.authentication.BasicUsernamePasswordServiceTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "should return none for invalid user invalid pass",
          "classname": "io.lenses.security.authentication.BasicUsernamePasswordServiceTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 321,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.SessionTokenValidatorTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "login directive should add token to the session store",
          "classname": "io.lenses.security.authentication.SessionTokenValidatorTest",
          "time": 304,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "logout directive should remove token from the session store",
          "classname": "io.lenses.security.authentication.SessionTokenValidatorTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.ViewLogAuthorizerTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "ViewLogAuthorizer should allow ViewLogAction if auth has view log permission",
          "classname": "io.lenses.security.authorization.ViewLogAuthorizerTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 5,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.DataPolicyAuthorizerTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "DataPolicyAuthorizer should allow ManageDataPolicyAction if auth has manage data policies permission",
          "classname": "io.lenses.security.authorization.DataPolicyAuthorizerTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DataPolicyAuthorizer should allow ViewDataPolicyAction if auth has view data policies permission",
          "classname": "io.lenses.security.authorization.DataPolicyAuthorizerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 289,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.PermissionHierarchyTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "return expected implicit permissions",
          "classname": "io.lenses.security.authentication.PermissionHierarchyTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "authorization manager adds implicit authorities automatically",
          "classname": "io.lenses.security.authentication.PermissionHierarchyTest",
          "time": 280,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "All Kafka topic permissions return ShowTopicPermission",
          "classname": "io.lenses.security.authentication.PermissionHierarchyTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ViewSchema implies both ShowTopic and ShowIndex",
          "classname": "io.lenses.security.authentication.PermissionHierarchyTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "All Elasticsearch permissions return ShowIndex permission",
          "classname": "io.lenses.security.authentication.PermissionHierarchyTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "All WildcardPermissions return ShowTopicPermission",
          "classname": "io.lenses.security.authentication.PermissionHierarchyTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 0,
      "tests": 0,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.ExpiringTokenStoreTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": []
    },
    {
      "time": 9,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authorization.AlertRulesAuthorizerTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "AlertRulesAuthorizer should allow ManageAlertRulesAction if auth has manage alert settings permission",
          "classname": "io.lenses.security.authorization.AlertRulesAuthorizerTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRulesAuthorizer should allow ManageAlertRulesAction if auth has view alert settings permission",
          "classname": "io.lenses.security.authorization.AlertRulesAuthorizerTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 353,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.HeaderUsernamePasswordExtractorTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "UsernamePasswordAuthenticationProvider should support HeaderUsernamePasswordExtractor",
          "classname": "io.lenses.security.authentication.HeaderUsernamePasswordExtractorTest",
          "time": 295,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UsernamePasswordAuthenticationProvider should return 400 if json is invalid",
          "classname": "io.lenses.security.authentication.HeaderUsernamePasswordExtractorTest",
          "time": 54,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UsernamePasswordAuthenticationProvider should return 401 if credentials are invalid",
          "classname": "io.lenses.security.authentication.HeaderUsernamePasswordExtractorTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 392,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.authentication.AuthenticateDirectiveTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "Auth directives should supply principal via auth manager",
          "classname": "io.lenses.security.authentication.AuthenticateDirectiveTest",
          "time": 279,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Auth directives should return 401 if the credentials are invalid",
          "classname": "io.lenses.security.authentication.AuthenticateDirectiveTest",
          "time": 57,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Auth directives should return 401 if the credentials are missing",
          "classname": "io.lenses.security.authentication.AuthenticateDirectiveTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "External login directive should supply the existing auth info if user already authenticated",
          "classname": "io.lenses.security.authentication.AuthenticateDirectiveTest",
          "time": 34,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "External login directive should short-circuit with the provider-managed response if user not logged in",
          "classname": "io.lenses.security.authentication.AuthenticateDirectiveTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "External logout directive should match when logout has been successful",
          "classname": "io.lenses.security.authentication.AuthenticateDirectiveTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2720,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.kerberos.KerberosAuthenticationTest",
      "timestamp": "2020-09-11T09:13:14",
      "testcase": [
        {
          "name": "kerberos provider should return 401 with negotiation",
          "classname": "io.lenses.security.kerberos.KerberosAuthenticationTest",
          "time": 2720,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 153,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.ldap.LdapConfigTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "reads with correct ignore impartial errors",
          "classname": "io.lenses.security.ldap.LdapConfigTest",
          "time": 143,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "reads from a configuration with all settings provided correctly with default plugin",
          "classname": "io.lenses.security.ldap.LdapConfigTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "raises an exception if the use service user flag is incorrect",
          "classname": "io.lenses.security.ldap.LdapConfigTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "raises an exception if the plugin class is not a class implementing the LdapUserGroupsPlugin interface",
          "classname": "io.lenses.security.ldap.LdapConfigTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 318,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.ldap.LdapAuthProviderMappedUserTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "LdapUsernamePasswordService should map a user group based on the user LDAP entry not the groups from LDAP",
          "classname": "io.lenses.security.ldap.LdapAuthProviderMappedUserTest",
          "time": 318,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3952,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.ldap.LdapAuthProviderUseServiceAccountLockoutTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "LdapAuthProvider should lock the account after max attempts",
          "classname": "io.lenses.security.ldap.LdapAuthProviderUseServiceAccountLockoutTest",
          "time": 3952,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 681,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.ldap.LdapAuthProviderTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "LdapUsernamePasswordService should populate groups",
          "classname": "io.lenses.security.ldap.LdapAuthProviderTest",
          "time": 328,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LdapAuthProvider should authenticate against an ldap server",
          "classname": "io.lenses.security.ldap.LdapAuthProviderTest",
          "time": 245,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LdapAuthProvider should fail if the password is incorrect",
          "classname": "io.lenses.security.ldap.LdapAuthProviderTest",
          "time": 108,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 681,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.ldap.LdapAuthProviderUseServiceAccountTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "LdapUsernamePasswordService should populate groups",
          "classname": "io.lenses.security.ldap.LdapAuthProviderUseServiceAccountTest",
          "time": 327,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LdapAuthProvider should authenticate against an ldap server",
          "classname": "io.lenses.security.ldap.LdapAuthProviderUseServiceAccountTest",
          "time": 246,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LdapAuthProvider should fail if the password is incorrect",
          "classname": "io.lenses.security.ldap.LdapAuthProviderUseServiceAccountTest",
          "time": 108,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 23,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.SecurityManagerUsernamePasswordServiceTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "SecurityManagerUsernamePasswordService should lookup user",
          "classname": "io.lenses.security.management.SecurityManagerUsernamePasswordServiceTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "SecurityManagerUsernamePasswordService should not return a user not set for Basic",
          "classname": "io.lenses.security.management.SecurityManagerUsernamePasswordServiceTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "SecurityManagerUsernamePasswordService should return not a user not set for Basic even if the password hash matches",
          "classname": "io.lenses.security.management.SecurityManagerUsernamePasswordServiceTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "SecurityManagerUsernamePasswordService should reject user if password hashes do not match",
          "classname": "io.lenses.security.management.SecurityManagerUsernamePasswordServiceTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "SecurityManagerUsernamePasswordService should return user using correct hash",
          "classname": "io.lenses.security.management.SecurityManagerUsernamePasswordServiceTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 62,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.SecurityManagerTokenValidatorTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "validate returns matching service account",
          "classname": "io.lenses.security.management.SecurityManagerTokenValidatorTest",
          "time": 59,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validates returns None if no matching service accounts",
          "classname": "io.lenses.security.management.SecurityManagerTokenValidatorTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "extracts the account name and the token from a token",
          "classname": "io.lenses.security.management.SecurityManagerTokenValidatorTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns None when the token is not valid",
          "classname": "io.lenses.security.management.SecurityManagerTokenValidatorTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 36,
      "tests": 14,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.SecurityLicenseChecksTests",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "Security license checks should perform groups enabled check when groups are enabled",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform groups enabled check when groups are disabled",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform max groups check when max groups limit is not reached",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform max groups check when max groups limit is reached => no additional groups can be created",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform max basic users check when max basic users limit is not reached",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform max basic users check when max basic users limit is reached => no additional users can be created",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform max ldap users check when max ldap users limit is not reached",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform max ldap users check when max ldap users limit is reached => no additional users can be created",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform max kerberos users check when max kerberos users limit is not reached",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform max kerberos users check when max kerberos users limit is reached => no additional users can be created",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform service accounts enabled check when service accounts are enabled",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform service accounts enabled check when service accounts are disabled",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform max service accounts check when max service accounts limit is not reached",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Security license checks should perform max service accounts check when max service accounts limit is reached => no additional service accounts can be created",
          "classname": "io.lenses.security.management.SecurityLicenseChecksTests",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1026,
      "tests": 14,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.SecurityValidatorTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "validateInsertServiceAccount passes valid instances",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 906,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateInsertServiceAccount rejects duplicate names",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 22,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateInsertServiceAccount generates random token",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Rejects invalid service account inserts",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 48,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Rejects invalid service account updates",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateUpdateServiceAccount passes valid instances",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateAddGroup should allow empty namespace/permission lists (for namespaces, this happens when somebody adds a namespace in the UI and removes it before submitting the form)",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateAddGroup should allow null namespace/permission lists (for namespaces, this happens when the user doesn't specify any namespaces)",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateAddGroup should reject groups with namespaces containing more than * when license disables data namespace",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateAddGroup should accept groups with namespaces containing only * when license disables data namespace",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateAddGroup should allow no namespaces groups when license disables data namespaces",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateAddUser should enforce password rules",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateAddUser should reject if the password contains the account name",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "validateUpdateUserPassword should reject if the password contains the account name",
          "classname": "io.lenses.security.management.SecurityValidatorTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 284,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.pac4j.CookiesTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "A cookie should [AC-494][BUG] not be set to HTTPOnly so that the FrontEnd can delete it",
          "classname": "io.lenses.security.pac4j.CookiesTest",
          "time": 284,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 92,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.saml.profiles.MsAzureProfileAdapterTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "The Azure profile adapter without plugin should use the Azure Display Name as the principal",
          "classname": "io.lenses.security.saml.profiles.MsAzureProfileAdapterTest",
          "time": 91,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "The Azure profile adapter without plugin should extract the groups from the Azure group claims SAML attribute",
          "classname": "io.lenses.security.saml.profiles.MsAzureProfileAdapterTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "The Azure profile adapter with a groups plugin should use the Azure Display Name as the principal",
          "classname": "io.lenses.security.saml.profiles.MsAzureProfileAdapterTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "The Azure profile adapter with a groups plugin should extract the groups from plugin, ignoring the SAML response",
          "classname": "io.lenses.security.saml.profiles.MsAzureProfileAdapterTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 11333,
      "tests": 9,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.saml.SamlAuthenticationProviderTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "A SAML Authenticator upon authenticating should return the existing authentication info if the user is already authenticated",
          "classname": "io.lenses.security.saml.SamlAuthenticationProviderTest",
          "time": 2612,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A SAML Authenticator upon authenticating should reject further processing if the user is not authenticated",
          "classname": "io.lenses.security.saml.SamlAuthenticationProviderTest",
          "time": 795,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A SAML Authenticator upon authenticating should reject further processing if the user's session is not found",
          "classname": "io.lenses.security.saml.SamlAuthenticationProviderTest",
          "time": 646,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A SAML Authenticator upon authenticating should not fail when not able to extract form fields from the request entity",
          "classname": "io.lenses.security.saml.SamlAuthenticationProviderTest",
          "time": 776,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A SAML Authenticator upon external login should return the existing authentication info if the user is already authenticated",
          "classname": "io.lenses.security.saml.SamlAuthenticationProviderTest",
          "time": 1160,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A SAML Authenticator upon external login should delegate the login the SAML Identity Provider via a redirect, if the user is not authenticated",
          "classname": "io.lenses.security.saml.SamlAuthenticationProviderTest",
          "time": 1429,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A SAML Authenticator upon external login should delegate the login the SAML Identity Provider via a redirect, if the user's session is not found",
          "classname": "io.lenses.security.saml.SamlAuthenticationProviderTest",
          "time": 1251,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A SAML Authenticator upon logout should cleanup the session state it holds for that user",
          "classname": "io.lenses.security.saml.SamlAuthenticationProviderTest",
          "time": 1274,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A SAML Authenticator's Service Provider (SP) Metadata should be available in XML string format",
          "classname": "io.lenses.security.saml.SamlAuthenticationProviderTest",
          "time": 1389,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 975,
      "tests": 8,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.pac4j.InMemorySessionStoreTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "Creating a new session should be stored in the store",
          "classname": "io.lenses.security.pac4j.InMemorySessionStoreTest",
          "time": 200,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting or creating a session ID should return the session ID assigned to the context if it already exists",
          "classname": "io.lenses.security.pac4j.InMemorySessionStoreTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Getting or creating a session ID should return the ID of a newly created session and set it on the context if the context's ID is not found in the store",
          "classname": "io.lenses.security.pac4j.InMemorySessionStoreTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Store should allow setting and getting arbitrary values on multiple sessions",
          "classname": "io.lenses.security.pac4j.InMemorySessionStoreTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Store should allow destroying sessions",
          "classname": "io.lenses.security.pac4j.InMemorySessionStoreTest",
          "time": 44,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Store should allow renewing sessions",
          "classname": "io.lenses.security.pac4j.InMemorySessionStoreTest",
          "time": 719,
          "failure": {
            "message": "false was not true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$ShouldMethodHelperClass.shouldMatcher(Matchers.scala:6783)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.should(Matchers.scala:6822)\n\tat io.lenses.security.pac4j.InMemorySessionStoreTest$$anon$6.<init>(InMemorySessionStoreTest.scala:84)\n\tat io.lenses.security.pac4j.InMemorySessionStoreTest.$anonfun$new$9(InMemorySessionStoreTest.scala:71)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat org.scalatest.wordspec.AnyWordSpec.run(AnyWordSpec.scala:1879)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "Trackable sessions should map to the underlying session IDs",
          "classname": "io.lenses.security.pac4j.InMemorySessionStoreTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Trackable sessions should be buildable from session IDs and be fresh sessions",
          "classname": "io.lenses.security.pac4j.InMemorySessionStoreTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.saml.profiles.GroupAttributeProfileAdapterTest",
      "timestamp": "2020-09-11T09:12:53",
      "testcase": [
        {
          "name": "A profile adapter using group attributes should offer the principal from PAC4J directly",
          "classname": "io.lenses.security.saml.profiles.GroupAttributeProfileAdapterTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A profile adapter using group attributes should extract the groups from the configured SAML attribute",
          "classname": "io.lenses.security.saml.profiles.GroupAttributeProfileAdapterTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 877,
      "tests": 15,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
      "timestamp": "2020-09-11T09:12:52",
      "testcase": [
        {
          "name": "A PAC4J Web Context Session should be a fresh session if there is no session cookie",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 292,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A PAC4J Web Context Session should be a fresh session if the session cookie does not exist in the store",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A PAC4J Web Context Session should be initialised from the request cookie only if it exists in the session store",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A PAC4J Web Context Session should expose its session lifetime",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "A PAC4J Web Context Session should be mutable for the store to change it without affecting the store back",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Managing the associated request should allow accessing request parameters",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 350,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Managing the associated request should allow accessing request headers (case-insensitive)",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Managing the associated request should allow accessing request cookies",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Managing the associated request should allow accessing request server name and port",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Managing the associated request should allow accessing request method",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Managing the associated request should allow querying about request URL",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Performing context changes should allow setting the response content and type",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 182,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Performing context changes should allow adding response cookies",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Performing context changes should allow adding response headers",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Performing context changes should allow adding arbitrary attributes",
          "classname": "io.lenses.security.pac4j.AkkaHttpWebContextTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 111,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.ListUsersRouteTest",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.ListUsersRouteTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.ListUsersRouteTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "check the correct license property",
          "classname": "io.lenses.security.management.ListUsersRouteTest",
          "time": 27,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "disabled due to license returns 402",
          "classname": "io.lenses.security.management.ListUsersRouteTest",
          "time": 22,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "list should return all users as DTOs",
          "classname": "io.lenses.security.management.ListUsersRouteTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "passwords should NOT be included",
          "classname": "io.lenses.security.management.ListUsersRouteTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 115,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.GetServiceAccountRouteTest",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "unauthenticated user returns 401",
          "classname": "io.lenses.security.management.GetServiceAccountRouteTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid license should return 402",
          "classname": "io.lenses.security.management.GetServiceAccountRouteTest",
          "time": 35,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized user returns 403",
          "classname": "io.lenses.security.management.GetServiceAccountRouteTest",
          "time": 24,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unknown group should return 404",
          "classname": "io.lenses.security.management.GetServiceAccountRouteTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful get service account",
          "classname": "io.lenses.security.management.GetServiceAccountRouteTest",
          "time": 29,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1993,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.AdminPermissionsRouteTest",
      "timestamp": "2020-09-11T09:13:26",
      "testcase": [
        {
          "name": "unauthenticated user returns 401",
          "classname": "io.lenses.security.management.AdminPermissionsRouteTest",
          "time": 1626,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized user returns 403",
          "classname": "io.lenses.security.management.AdminPermissionsRouteTest",
          "time": 156,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "namespace permissions as string list",
          "classname": "io.lenses.security.management.AdminPermissionsRouteTest",
          "time": 210,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 799,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.RevokeServiceAccountRouteTest",
      "timestamp": "2020-09-11T09:13:29",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.RevokeServiceAccountRouteTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns 403 when the user does not have manage user management permission",
          "classname": "io.lenses.security.management.RevokeServiceAccountRouteTest",
          "time": 723,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns 402 when license is not valid",
          "classname": "io.lenses.security.management.RevokeServiceAccountRouteTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns 200 when the service account token is revoked",
          "classname": "io.lenses.security.management.RevokeServiceAccountRouteTest",
          "time": 66,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 910,
      "tests": 13,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.AddGroupRouteTest",
      "timestamp": "2020-09-11T09:13:29",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license not valid returns 402",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 529,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful upsert returns 200",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 192,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successfully upserts when the group has no namespaces",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "duplicate group name returns 400",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid group name returns 400",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 37,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "null group name returns 400",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 20,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "missing namespace wildcard returns 400",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "empty namespace wildcard returns 400",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "multiple errors returns all as 400",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "multiple namespace errors returns all as 400",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "rejects adding the group when license disables data namespace and the namespace entries break it",
          "classname": "io.lenses.security.management.AddGroupRouteTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1374,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.UpdateUserPasswordRulesRouteTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "returns 400 if the password is not matching the rules",
          "classname": "io.lenses.security.management.UpdateUserPasswordRulesRouteTest",
          "time": 1244,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns 200 if the password is  matching the rules",
          "classname": "io.lenses.security.management.UpdateUserPasswordRulesRouteTest",
          "time": 73,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns 400 if the password does not meet the rules",
          "classname": "io.lenses.security.management.UpdateUserPasswordRulesRouteTest",
          "time": 31,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns 200 if the password meets the rules",
          "classname": "io.lenses.security.management.UpdateUserPasswordRulesRouteTest",
          "time": 26,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 56,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.ListServiceAccountsRouteTest",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.ListServiceAccountsRouteTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.ListServiceAccountsRouteTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid license returns 402",
          "classname": "io.lenses.security.management.ListServiceAccountsRouteTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "list should return all service accounts as DTOs",
          "classname": "io.lenses.security.management.ListServiceAccountsRouteTest",
          "time": 28,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "list should allow filter",
          "classname": "io.lenses.security.management.ListServiceAccountsRouteTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2874,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.DeleteServiceAccountRouteTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.DeleteServiceAccountRouteTest",
          "time": 1626,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.DeleteServiceAccountRouteTest",
          "time": 154,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting a service account returns 200",
          "classname": "io.lenses.security.management.DeleteServiceAccountRouteTest",
          "time": 1013,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting unknown service account returns 400",
          "classname": "io.lenses.security.management.DeleteServiceAccountRouteTest",
          "time": 72,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid license returns 402",
          "classname": "io.lenses.security.management.DeleteServiceAccountRouteTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 855,
      "tests": 12,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.AddServiceAccountRouteTest",
      "timestamp": "2020-09-11T09:13:29",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 26,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful upsert returns 200",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 652,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful upsert with multiple groups 200",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 30,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "duplicate name returns 400",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid name returns 400",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "null name returns 400",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid group name returns 400",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "null group name returns 400",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "multiple errors returns all as 400",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 29,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unknown group returns 400",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 42,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid license returns 402",
          "classname": "io.lenses.security.management.AddServiceAccountRouteTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 74,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.NamespacePermissionsRouteTest",
      "timestamp": "2020-09-11T09:13:29",
      "testcase": [
        {
          "name": "unauthenticated user returns 401",
          "classname": "io.lenses.security.management.NamespacePermissionsRouteTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized user returns 403",
          "classname": "io.lenses.security.management.NamespacePermissionsRouteTest",
          "time": 21,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "namespace permissions as string list",
          "classname": "io.lenses.security.management.NamespacePermissionsRouteTest",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 335,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.AddUserRoutePasswordRulesTest",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "returns 400 if the password is not aligned with the rules",
          "classname": "io.lenses.security.management.AddUserRoutePasswordRulesTest",
          "time": 293,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns 200 if the password is aligned with the rules",
          "classname": "io.lenses.security.management.AddUserRoutePasswordRulesTest",
          "time": 42,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3157,
      "tests": 21,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.AddUserRouteTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 1623,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 157,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license requirement for basic auth not met returns 402",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 1000,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license requirement for ldap auth not met returns 402",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 34,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license requirement for kerberos auth not met returns 402",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 59,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful upsert returns 200",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 28,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful upsert with multiple groups returns 200",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "duplicate user name returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid username returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "null username returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid password returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "null password returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "null group returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 39,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "multiple errors returns all as 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unknown group returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "null type returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "password on type Kerberos returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns 400 when trying to add a Kerberos user with password",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "request with no groups returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 45,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "request with null groups returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "inserting a user with the same name as the default admin user returns 400",
          "classname": "io.lenses.security.management.AddUserRouteTest",
          "time": 26,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.UserAuditExtensionTest",
      "timestamp": "2020-09-11T09:13:29",
      "testcase": [
        {
          "name": "returns the list of group names for the audit, email,type, password and name",
          "classname": "io.lenses.security.management.UserAuditExtensionTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 733,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.UpdateUserRouteTest",
      "timestamp": "2020-09-11T09:13:29",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.UpdateUserRouteTest",
          "time": 31,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.UpdateUserRouteTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful update returns 200",
          "classname": "io.lenses.security.management.UpdateUserRouteTest",
          "time": 591,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful update with multiple groups returns 200",
          "classname": "io.lenses.security.management.UpdateUserRouteTest",
          "time": 30,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "non existing user returns 404",
          "classname": "io.lenses.security.management.UpdateUserRouteTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unknown group returns 400",
          "classname": "io.lenses.security.management.UpdateUserRouteTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "request with no groups returns 400",
          "classname": "io.lenses.security.management.UpdateUserRouteTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "request without groups returns 400",
          "classname": "io.lenses.security.management.UpdateUserRouteTest",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2032,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.GetUserRouteTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "unauthenticated user returns 401",
          "classname": "io.lenses.security.management.GetUserRouteTest",
          "time": 1626,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized user returns 403",
          "classname": "io.lenses.security.management.GetUserRouteTest",
          "time": 161,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unknown user should return 404",
          "classname": "io.lenses.security.management.GetUserRouteTest",
          "time": 35,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful get a Basic user",
          "classname": "io.lenses.security.management.GetUserRouteTest",
          "time": 170,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "prevents an homonymous service user to read another user detail (without ViewUsersPermission)",
          "classname": "io.lenses.security.management.GetUserRouteTest",
          "time": 22,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful get principal user (without ViewUsers)",
          "classname": "io.lenses.security.management.GetUserRouteTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful get a Kerberos user",
          "classname": "io.lenses.security.management.GetUserRouteTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 119,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.CloneGroupRouteTest",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.CloneGroupRouteTest",
          "time": 21,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.CloneGroupRouteTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license not valid returns 402",
          "classname": "io.lenses.security.management.CloneGroupRouteTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful clone returns 200",
          "classname": "io.lenses.security.management.CloneGroupRouteTest",
          "time": 21,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unknown group returns 400 with error message",
          "classname": "io.lenses.security.management.CloneGroupRouteTest",
          "time": 31,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "cloning target name exists returns 400",
          "classname": "io.lenses.security.management.CloneGroupRouteTest",
          "time": 29,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 32,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.ListUserTypeTest",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.ListUserTypeTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.ListUserTypeTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful retrieve the user types returns 200",
          "classname": "io.lenses.security.management.ListUserTypeTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2879,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.DeleteGroupRouteTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.DeleteGroupRouteTest",
          "time": 1623,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.DeleteGroupRouteTest",
          "time": 157,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license not valid returns 402",
          "classname": "io.lenses.security.management.DeleteGroupRouteTest",
          "time": 984,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting a group returns 200",
          "classname": "io.lenses.security.management.DeleteGroupRouteTest",
          "time": 60,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unknown group returns 400 with error message",
          "classname": "io.lenses.security.management.DeleteGroupRouteTest",
          "time": 47,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting a group with users returns 400",
          "classname": "io.lenses.security.management.DeleteGroupRouteTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 509,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.UpdateServiceAccountRouteTest",
      "timestamp": "2020-09-11T09:13:29",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.UpdateServiceAccountRouteTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.UpdateServiceAccountRouteTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "service account name not found returns 404",
          "classname": "io.lenses.security.management.UpdateServiceAccountRouteTest",
          "time": 389,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid license returns 402",
          "classname": "io.lenses.security.management.UpdateServiceAccountRouteTest",
          "time": 22,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updating the service account returns 200",
          "classname": "io.lenses.security.management.UpdateServiceAccountRouteTest",
          "time": 47,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "invalid group name returns 400",
          "classname": "io.lenses.security.management.UpdateServiceAccountRouteTest",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "null group name returns 400",
          "classname": "io.lenses.security.management.UpdateServiceAccountRouteTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unknown group returns 400",
          "classname": "io.lenses.security.management.UpdateServiceAccountRouteTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2420,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.ConnectionPermissionsAndDatasetsRouteTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "unauthenticated user returns 401",
          "classname": "io.lenses.security.management.ConnectionPermissionsAndDatasetsRouteTest",
          "time": 1253,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized user returns 403",
          "classname": "io.lenses.security.management.ConnectionPermissionsAndDatasetsRouteTest",
          "time": 157,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "list of permissions for each connection",
          "classname": "io.lenses.security.management.ConnectionPermissionsAndDatasetsRouteTest",
          "time": 1010,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1836,
      "tests": 11,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.UpdateGroupRouteTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 463,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 157,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license not valid returns 402",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 989,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns 404 if the group is not present",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "empty group name returns 400",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 61,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "null group name returns 400",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 93,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "missing namespace wildcard returns 400",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "empty namespace wildcard returns 400",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 39,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "multiple errors returns all as 400",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "multiple namespace errors returns all as 400",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updates the group",
          "classname": "io.lenses.security.management.UpdateGroupRouteTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1810,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.DeleteUserRouteTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.DeleteUserRouteTest",
          "time": 1628,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.DeleteUserRouteTest",
          "time": 137,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting a user returns 200",
          "classname": "io.lenses.security.management.DeleteUserRouteTest",
          "time": 21,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleting a user which is not basic returns 200",
          "classname": "io.lenses.security.management.DeleteUserRouteTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unknown user returns 400",
          "classname": "io.lenses.security.management.DeleteUserRouteTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1456,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.UpdateUserPasswordRouteTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "unauthenticated request returns 401",
          "classname": "io.lenses.security.management.UpdateUserPasswordRouteTest",
          "time": 1210,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized request returns 403",
          "classname": "io.lenses.security.management.UpdateUserPasswordRouteTest",
          "time": 156,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful update by the owner user returns 200",
          "classname": "io.lenses.security.management.UpdateUserPasswordRouteTest",
          "time": 22,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "rejects updating a Kerberos user password",
          "classname": "io.lenses.security.management.UpdateUserPasswordRouteTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "prevents an homonymous service user to change another user's password",
          "classname": "io.lenses.security.management.UpdateUserPasswordRouteTest",
          "time": 45,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful update user password returns 200",
          "classname": "io.lenses.security.management.UpdateUserPasswordRouteTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 136,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.GetGroupRouteTest",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "unauthenticated user returns 401",
          "classname": "io.lenses.security.management.GetGroupRouteTest",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized user returns 403",
          "classname": "io.lenses.security.management.GetGroupRouteTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license not valid returns 402",
          "classname": "io.lenses.security.management.GetGroupRouteTest",
          "time": 22,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unknown group should return 404",
          "classname": "io.lenses.security.management.GetGroupRouteTest",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "successful get group",
          "classname": "io.lenses.security.management.GetGroupRouteTest",
          "time": 42,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "include count for accounts",
          "classname": "io.lenses.security.management.GetGroupRouteTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 21,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.ScopedPermissionsRouteTest",
      "timestamp": "2020-09-11T09:13:30",
      "testcase": [
        {
          "name": "unauthenticated user returns 401",
          "classname": "io.lenses.security.management.ScopedPermissionsRouteTest",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized user returns 403",
          "classname": "io.lenses.security.management.ScopedPermissionsRouteTest",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "namespace permissions as string list",
          "classname": "io.lenses.security.management.ScopedPermissionsRouteTest",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 968,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.ListGroupsRouteTest",
      "timestamp": "2020-09-11T09:13:29",
      "testcase": [
        {
          "name": "unauthenticated user returns 401",
          "classname": "io.lenses.security.management.ListGroupsRouteTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unauthorized user returns 403",
          "classname": "io.lenses.security.management.ListGroupsRouteTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "license not valid returns 402",
          "classname": "io.lenses.security.management.ListGroupsRouteTest",
          "time": 521,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "list should return all groups as DTOs",
          "classname": "io.lenses.security.management.ListGroupsRouteTest",
          "time": 321,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "groups should allow filter",
          "classname": "io.lenses.security.management.ListGroupsRouteTest",
          "time": 60,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "include count for accounts",
          "classname": "io.lenses.security.management.ListGroupsRouteTest",
          "time": 35,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1603,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.management.NamespaceForEntityPermissionsRouteTest",
      "timestamp": "2020-09-11T09:13:25",
      "testcase": [
        {
          "name": "unauthenticated user returns 401",
          "classname": "io.lenses.security.management.NamespaceForEntityPermissionsRouteTest",
          "time": 1206,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "only kafka connection is supported for now",
          "classname": "io.lenses.security.management.NamespaceForEntityPermissionsRouteTest",
          "time": 27,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "user with all privileges returns all permissions",
          "classname": "io.lenses.security.management.NamespaceForEntityPermissionsRouteTest",
          "time": 352,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "user with limited privileges sees limited permissions",
          "classname": "io.lenses.security.management.NamespaceForEntityPermissionsRouteTest",
          "time": 18,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 0,
      "tests": 0,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.kafka.jolokia.ConnectJolokiaMetricsReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "testcase": []
    },
    {
      "time": 62,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.schemaregistry.jmx.SchemaRegistryMetricsJMXReaderTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "returns the metrics",
          "classname": "io.lenses.services.metrics.schemaregistry.jmx.SchemaRegistryMetricsJMXReaderTest",
          "time": 62,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.schemaregistry.jmx.SchemaRegistryMetricsJMXReaderTest.$anonfun$new$1(SchemaRegistryMetricsJMXReaderTest.scala:15)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 196,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.prometheus.BlockParserTest",
      "timestamp": "2020-09-11T09:13:22",
      "testcase": [
        {
          "name": "Invalid or empty lines and comments should Be ignored",
          "classname": "io.lenses.prometheus.BlockParserTest",
          "time": 154,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "_sum handler should Should remove _sum suffix and add Sum modifier for Histogram",
          "classname": "io.lenses.prometheus.BlockParserTest",
          "time": 32,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "_sum handler should Should remove _sum suffix and add Sum modifier for Summary",
          "classname": "io.lenses.prometheus.BlockParserTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "_sum handler should Should treat sum as separate metric name for other types",
          "classname": "io.lenses.prometheus.BlockParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "_count handler should Should remove _count suffix and add Count modifier for Histogram",
          "classname": "io.lenses.prometheus.BlockParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "_count handler should Should remove _count suffix and add Sum modifier for Summary",
          "classname": "io.lenses.prometheus.BlockParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "_count handler should Should treat count as separate metric name for other types",
          "classname": "io.lenses.prometheus.BlockParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "_bucket handler should Remove _bucket suffix and add Bucket modifier for histogram",
          "classname": "io.lenses.prometheus.BlockParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "_bucket handler should Treat _bucket as a part of metric for summary",
          "classname": "io.lenses.prometheus.BlockParserTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "_bucket handler should Treat _bucket as a part of metric for other types",
          "classname": "io.lenses.prometheus.BlockParserTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 427,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.zookeeper.jmx.ZookeeperJMXReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "testcase": [
        {
          "name": "return the zookeeper metrics",
          "classname": "io.lenses.services.metrics.zookeeper.jmx.ZookeeperJMXReaderTest",
          "time": 427,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.zookeeper.jmx.ZookeeperJMXReaderTest.$anonfun$new$1(ZookeeperJMXReaderTest.scala:16)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 4,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.prometheus.LabelsParserTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "Labels should Not be present if missing",
          "classname": "io.lenses.prometheus.LabelsParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Labels should Not be present if only brackets and spaces found",
          "classname": "io.lenses.prometheus.LabelsParserTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Labels should Be present",
          "classname": "io.lenses.prometheus.LabelsParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Labels should Be present without labels with incorrect name",
          "classname": "io.lenses.prometheus.LabelsParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Labels should Be present with quotation marks in value if escaped",
          "classname": "io.lenses.prometheus.LabelsParserTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Labels should Be present with unescaped backslashes in value",
          "classname": "io.lenses.prometheus.LabelsParserTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Labels should Be present with unescaped new lines in value",
          "classname": "io.lenses.prometheus.LabelsParserTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1300,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.zookeeper.jolokia.ZookeeperHttpReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "testcase": [
        {
          "name": "return the zookeeper metrics",
          "classname": "io.lenses.services.metrics.zookeeper.jolokia.ZookeeperHttpReaderTest",
          "time": 1300,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.zookeeper.jolokia.ZookeeperHttpReaderTest.$anonfun$new$1(ZookeeperHttpReaderTest.scala:20)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 427,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.kafka.jmx.ConnectMetricsJMXReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "testcase": [
        {
          "name": "return metrics",
          "classname": "io.lenses.services.metrics.kafka.jmx.ConnectMetricsJMXReaderTest",
          "time": 427,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.kafka.jmx.ConnectMetricsJMXReaderTest.$anonfun$new$1(ConnectMetricsJMXReaderTest.scala:17)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 450,
      "tests": 2,
      "failures": 2,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.kafka.jmx.BrokerMetricsJMXReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "testcase": [
        {
          "name": "returns the kafka version",
          "classname": "io.lenses.services.metrics.kafka.jmx.BrokerMetricsJMXReaderTest",
          "time": 421,
          "failure": {
            "message": "None was not equal to Some(\"2.3.0-L0\")",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: None was not equal to Some(\"2.3.0-L0\")\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.kafka.jmx.BrokerMetricsJMXReaderTest.$anonfun$new$1(BrokerMetricsJMXReaderTest.scala:14)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return the broker metrics",
          "classname": "io.lenses.services.metrics.kafka.jmx.BrokerMetricsJMXReaderTest",
          "time": 29,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.kafka.jmx.BrokerMetricsJMXReaderTest.$anonfun$new$2(BrokerMetricsJMXReaderTest.scala:20)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1284,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.schemaregistry.jolokia.SchemaRegistryJolokiaMetricsReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "testcase": [
        {
          "name": "returns the metrics",
          "classname": "io.lenses.services.metrics.schemaregistry.jolokia.SchemaRegistryJolokiaMetricsReaderTest",
          "time": 1284,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.schemaregistry.jolokia.SchemaRegistryJolokiaMetricsReaderTest.$anonfun$new$1(SchemaRegistryJolokiaMetricsReaderTest.scala:18)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3824,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsReaderTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "returns the kafka version",
          "classname": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsReaderTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "return the broker metrics",
          "classname": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsReaderTest",
          "time": 1756,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "caches the broker metrics for the supplied ttl duration",
          "classname": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsReaderTest",
          "time": 2050,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1306,
      "tests": 3,
      "failures": 3,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "testcase": [
        {
          "name": "returns the kafka version",
          "classname": "io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest",
          "time": 1284,
          "failure": {
            "message": "None was not equal to Some(\"2.3.0-L0\")",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: None was not equal to Some(\"2.3.0-L0\")\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest.$anonfun$new$1(BrokerJolokiaMetricsReaderTest.scala:18)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return the kafka broker id",
          "classname": "io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest",
          "time": 3,
          "failure": {
            "message": "Connect to localhost:10089 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused (Connection refused)",
            "type": "org.apache.http.conn.HttpHostConnectException",
            "stackTrace": "org.apache.http.conn.HttpHostConnectException: Connect to localhost:10089 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused (Connection refused)\n\tat org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:159)\n\tat org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:373)\n\tat org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:394)\n\tat org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:237)\n\tat org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:185)\n\tat org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)\n\tat org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)\n\tat org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:108)\n\tat io.lenses.services.metrics.http.JolokiaMetrics.get(JolokiaMetrics.scala:49)\n\tat io.lenses.services.metrics.http.JolokiaMetrics.execute(JolokiaMetrics.scala:137)\n\tat io.lenses.services.metrics.http.JolokiaMetrics.execute$(JolokiaMetrics.scala:135)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest.execute(BrokerJolokiaMetricsReaderTest.scala:13)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerMetricsHttpReaderHelper.getBrokerID(BrokerMetricsHttpReader.scala:159)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerMetricsHttpReaderHelper.getBrokerID$(BrokerMetricsHttpReader.scala:158)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest.getBrokerID(BrokerJolokiaMetricsReaderTest.scala:13)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest.$anonfun$new$2(BrokerJolokiaMetricsReaderTest.scala:22)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.net.ConnectException: Connection refused (Connection refused)\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\n\tat java.net.Socket.connect(Socket.java:607)\n\tat org.apache.http.conn.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:75)\n\tat org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:142)\n\t... 73 more"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "return the broker metrics",
          "classname": "io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest",
          "time": 19,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest.$anonfun$new$3(BrokerJolokiaMetricsReaderTest.scala:28)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 151,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 3,
      "name": "io.lenses.prometheus.BaseResponseTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "parseE should Return Right with metrics",
          "classname": "io.lenses.prometheus.BaseResponseTest",
          "time": 151,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "parseE should Return Left with error",
          "classname": "io.lenses.prometheus.BaseResponseTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "parseOpt should Return Right with metrics",
          "classname": "io.lenses.prometheus.BaseResponseTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "parseOpt should Return Left with error",
          "classname": "io.lenses.prometheus.BaseResponseTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        },
        {
          "name": "unsafeParse should Return Right with metrics",
          "classname": "io.lenses.prometheus.BaseResponseTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "unsafeParse should Return Left with error",
          "classname": "io.lenses.prometheus.BaseResponseTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        }
      ]
    },
    {
      "time": 2338,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.prometheus.KafkaMskPayloadTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "txt",
          "classname": "io.lenses.prometheus.KafkaMskPayloadTest",
          "time": 1286,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "txt",
          "classname": "io.lenses.prometheus.KafkaMskPayloadTest",
          "time": 1051,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 146,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsPayloadTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "get UnderReplicatedPartitions",
          "classname": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsPayloadTest",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get OfflinePartitionsCount",
          "classname": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsPayloadTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get getReplicationManagerLeaderCount",
          "classname": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsPayloadTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get ActiveControllerCount",
          "classname": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsPayloadTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get topic partition size",
          "classname": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsPayloadTest",
          "time": 80,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get OS metrics",
          "classname": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsPayloadTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "get runtime metrics",
          "classname": "io.lenses.services.metrics.kafka.aws.BrokerAwsMetricsPayloadTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 45,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 1,
      "name": "io.lenses.prometheus.ParserErrorTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "MultipleHelpLines should Be present when multiple help lines exists for single metric",
          "classname": "io.lenses.prometheus.ParserErrorTest",
          "time": 25,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MultipleTypeLines should Be present when multiple type lines exists for single metric",
          "classname": "io.lenses.prometheus.ParserErrorTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TypeNotAtTheBeginning should Be present when metric value recorded before type line",
          "classname": "io.lenses.prometheus.ParserErrorTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TypeNotAtTheBeginning should Not be present when only help and comment recorded before type line",
          "classname": "io.lenses.prometheus.ParserErrorTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MultipleGroupsOfMetrics should Be present if metric exists in multiple groups",
          "classname": "io.lenses.prometheus.ParserErrorTest",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "DuplicatedLabels should Be present on multiple occurrences of metric with the same labels",
          "classname": "io.lenses.prometheus.ParserErrorTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": true
        }
      ]
    },
    {
      "time": 10,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.prometheus.ExamplePayloadTest",
      "timestamp": "2020-09-11T09:13:23",
      "testcase": [
        {
          "name": "Parser should parse example from Prometheus doc",
          "classname": "io.lenses.prometheus.ExamplePayloadTest",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 71,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.ConstraintViolationErrorSpec",
      "timestamp": "2020-09-11T09:12:50",
      "testcase": [
        {
          "name": "translate an error for index or primary key violation",
          "classname": "io.lenses.store.ConstraintViolationErrorSpec",
          "time": 69,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "translate an error regarding referential integrity constraint violation should for usual error message",
          "classname": "io.lenses.store.ConstraintViolationErrorSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "translate an error regarding referential integrity constraint violation should for unusual LOCALE settings",
          "classname": "io.lenses.store.ConstraintViolationErrorSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "translate an error not recognized by its message",
          "classname": "io.lenses.store.ConstraintViolationErrorSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 37,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.external_apps.dto.AppMetadataSpec",
      "timestamp": "2020-09-11T09:12:50",
      "testcase": [
        {
          "name": "isEmpty should be true for all empty fields",
          "classname": "io.lenses.store.external_apps.dto.AppMetadataSpec",
          "time": 36,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "isEmpty should be false for at least one Some",
          "classname": "io.lenses.store.external_apps.dto.AppMetadataSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "isEmpty should be false for non-empty set of tags",
          "classname": "io.lenses.store.external_apps.dto.AppMetadataSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 12104,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
      "timestamp": "2020-09-11T09:13:10",
      "testcase": [
        {
          "name": "MetricsSqlStore should insertValues should insert end offset keys and values",
          "classname": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
          "time": 2444,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSqlStore should insertValues should use existing end offset keys",
          "classname": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
          "time": 1590,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSqlStore should insertValues should truncate milliseconds from timestamp",
          "classname": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
          "time": 1276,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSqlStore should insertValues should fail if incorrect selection causes conflict",
          "classname": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
          "time": 1182,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSqlStore should insertValues should only return keys that were inserted",
          "classname": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
          "time": 957,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSqlStore should deleteMetricValues should delete specific values (and keys that have no values anymore)",
          "classname": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
          "time": 898,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSqlStore should deleteMetricValuesBefore should delete values before a timestamp (and keys that have no values anymore)",
          "classname": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
          "time": 1102,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSqlStore should streamMetricValuesAfter should streams values after passed time",
          "classname": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
          "time": 1023,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSqlStore should streamMetricValuesAfter should stream multiple topics at once",
          "classname": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
          "time": 719,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsSqlStore should getMetricValuesRange should retrieves values within range",
          "classname": "io.lenses.store.jdbc.metrics.MetricsSqlStoreSpec",
          "time": 911,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 29138,
      "tests": 25,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.migration.ChangelogTest",
      "timestamp": "2020-09-11T09:13:11",
      "testcase": [
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 611,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 189,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 362,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 2098,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 1465,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 2252,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0->latest vs empty->latest",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 2908,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 118,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 102,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 690,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 1052,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 1510,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0->latest vs empty->latest",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 2354,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 654,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 611,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 630,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 1197,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0->latest vs empty->latest",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 2061,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 757,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 630,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 1064,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0->latest vs empty->latest",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 1922,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 1194,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 1016,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "0->latest vs empty->latest",
          "classname": "io.lenses.store.jdbc.migration.ChangelogTest",
          "time": 1688,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 12166,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
      "timestamp": "2020-09-11T09:13:09",
      "testcase": [
        {
          "name": "keyValueH2Store should can retrieve a list from empty Db",
          "classname": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
          "time": 1648,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "keyValueH2Store should can save an app by id, and see it in a list",
          "classname": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
          "time": 1394,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "keyValueH2Store should save two apps, get two back in the list",
          "classname": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
          "time": 1812,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "keyValueH2Store should update should given a saved app, we can update it",
          "classname": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
          "time": 1511,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "keyValueH2Store should update should given saved app, we can update it and get the update",
          "classname": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
          "time": 1402,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "keyValueH2Store should update should upsert - given no saved app, update will insert, and return true if it inserted",
          "classname": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
          "time": 858,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "keyValueH2Store should getById  should given a couple of saved apps, we can get 1 by id",
          "classname": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
          "time": 1011,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "keyValueH2Store should delete   should given saved app, we can delete it and see that it is not there",
          "classname": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
          "time": 1077,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "keyValueH2Store should delete   should given saved app, when we delete it returns true",
          "classname": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
          "time": 783,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "keyValueH2Store should delete   should when we delete an appId that does not exist, return false",
          "classname": "io.lenses.store.jdbc.engines.SqlAppH2StoreSpec",
          "time": 667,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 19274,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.table.H2TableStoreSpec",
      "timestamp": "2020-09-11T09:12:55",
      "testcase": [
        {
          "name": "H2TableStore should readAll() should return all records for the given connection using insert/update",
          "classname": "io.lenses.store.jdbc.table.H2TableStoreSpec",
          "time": 8725,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "H2TableStore should readAll() should return all records for the given connection",
          "classname": "io.lenses.store.jdbc.table.H2TableStoreSpec",
          "time": 1592,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "H2TableStore should readAll() should return no records when given a connection name with no records",
          "classname": "io.lenses.store.jdbc.table.H2TableStoreSpec",
          "time": 1666,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "H2TableStore should delete() should delete the specified records",
          "classname": "io.lenses.store.jdbc.table.H2TableStoreSpec",
          "time": 1228,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "H2TableStore should delete() should not delete records that don't match the connection name",
          "classname": "io.lenses.store.jdbc.table.H2TableStoreSpec",
          "time": 1618,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "H2TableStore should deleteAll() should delete records for the given connection name",
          "classname": "io.lenses.store.jdbc.table.H2TableStoreSpec",
          "time": 1542,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "H2TableStore should should update the record when called when a table with the given name already exists",
          "classname": "io.lenses.store.jdbc.table.H2TableStoreSpec",
          "time": 1467,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "H2TableStore should insertOrUpdate() should update the record when called when a table with the given name already exists",
          "classname": "io.lenses.store.jdbc.table.H2TableStoreSpec",
          "time": 1434,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 33589,
      "tests": 25,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
      "timestamp": "2020-09-11T09:12:57",
      "testcase": [
        {
          "name": "ChannelSqlStore should addChannel should fail if channel name already exists",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 7919,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should addChannel should succeed for duplicate channel name but different template type",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 2193,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should return none when no channel config exists",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 1338,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should return some value when both channel config and properties exist",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 1396,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should getAllChannels should return a paginated list all the channel configurations with given type",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 1748,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should getAllChannels should filter by template name",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 1730,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should getAllChannels should filter by partial channel name",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 1602,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should getAllChannels should sort results by name",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 1394,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should getAllChannels should sort results by templateName",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 1320,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should sort results by createdAt",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 1270,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should getAllChannelsWithTemplateForTemplateType should return a list of all the channel configs with given template type",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 1070,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should getChannelsWithTemplateForTemplateType should return a list of all the channel configs with given template type / ids",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 807,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should updateChannel should returns none if the channel configuration doesn't exist",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 725,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should updateChannel should reset channel property values when the configuration exists",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 796,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should updateChannel should fail if channel name already exists",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 831,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should updateChannel should succeed when channel name not updated",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 1038,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should updateChannel should succeed for duplicate channel name but different template type",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 855,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should patchChannel should return none if channel configuration doesn't exist",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 747,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should patchChannel should patch configuration if vales are present",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 694,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should patchChannel should patch only modifiedBy if values are absent",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 730,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should deleteChannel should returns none if the channel configuration doesn't exist",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 686,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should deleteChannel should removes an existing channel record",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 615,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should getChannelTemplate should return non when no template exists",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 618,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should getChannelTemplate should return some template config when it does exist",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 739,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ChannelSqlStore should getChannel should getAllChannelTemplatesForTemplateType should return a list of the existing channel templates",
          "classname": "io.lenses.store.jdbc.channel.ChannelSqlStoreSpec",
          "time": 727,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 2107,
      "tests": 22,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
      "timestamp": "2020-09-11T09:13:07",
      "testcase": [
        {
          "name": "insertRegisteredApplication",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 1488,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getRegisteredApplicationByUID",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 56,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleteRegisteredApplicationByUID",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getRegisteredApplications",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 124,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertPropertyValue",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 57,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updatePropertyValue",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 48,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "footprintUpdateOnAppRegistered",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 30,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fetchApplicationReferences",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fetchApplicationValues",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 28,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fetchDeploymentValues",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 56,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertCreatorType",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 82,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getAllCreatorTypes",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertApplicationTag",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getApplicationTags",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertKeyValueMetadata",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 26,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getKeyValueMetadataById",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getKeyValueMetadataByKeyValue",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getApplicationKeyValueMetadata",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertApplicationMetadataLink",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 21,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertAppPropertyValue",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fetchDeploymentProvidedValuesByAppId",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "fetchApplicationProvidedValuesByAppId",
          "classname": "io.lenses.store.jdbc.application.ApplicationQueriesSpec",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6585,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.user.h2.KafkaConnectorTest",
      "timestamp": "2020-09-11T09:13:13",
      "testcase": [
        {
          "name": "UserProfileH2Store should returns empty Kafka connectors records for a user without any entries",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaConnectorTest",
          "time": 1547,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert and read a kafka connector",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaConnectorTest",
          "time": 1396,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert the same record twice will appear twice",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaConnectorTest",
          "time": 766,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert multiple Kafka connectors for one user and then delete one",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaConnectorTest",
          "time": 1006,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert and delete records for multiple users",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaConnectorTest",
          "time": 993,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert multiple Connectors and delete one globally",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaConnectorTest",
          "time": 878,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1756,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.approval.queries.ApprovalRequestQueriesTest",
      "timestamp": "2020-09-11T09:13:05",
      "testcase": [
        {
          "name": "ApprovalRequestQueries should insertNewRequest",
          "classname": "io.lenses.store.jdbc.approval.queries.ApprovalRequestQueriesTest",
          "time": 1400,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRequestQueries should setToRejected",
          "classname": "io.lenses.store.jdbc.approval.queries.ApprovalRequestQueriesTest",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRequestQueries should setToApproved",
          "classname": "io.lenses.store.jdbc.approval.queries.ApprovalRequestQueriesTest",
          "time": 42,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRequestQueries should setToFailed",
          "classname": "io.lenses.store.jdbc.approval.queries.ApprovalRequestQueriesTest",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRequestQueries should selectAll",
          "classname": "io.lenses.store.jdbc.approval.queries.ApprovalRequestQueriesTest",
          "time": 259,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ApprovalRequestQueries should selectOne",
          "classname": "io.lenses.store.jdbc.approval.queries.ApprovalRequestQueriesTest",
          "time": 30,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 9293,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.kafka.cluster.KafkaClusterH2StoreTest",
      "timestamp": "2020-09-11T09:12:58",
      "testcase": [
        {
          "name": "KafkaClusterH2Store should returns empty for a non existing key",
          "classname": "io.lenses.store.jdbc.kafka.cluster.KafkaClusterH2StoreTest",
          "time": 4960,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaClusterH2Store should returns 0 entries when the store is empty",
          "classname": "io.lenses.store.jdbc.kafka.cluster.KafkaClusterH2StoreTest",
          "time": 1550,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaClusterH2Store should insert a Broker entry and retrieve it then delete it",
          "classname": "io.lenses.store.jdbc.kafka.cluster.KafkaClusterH2StoreTest",
          "time": 1621,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "KafkaClusterH2Store should update a Broker entry",
          "classname": "io.lenses.store.jdbc.kafka.cluster.KafkaClusterH2StoreTest",
          "time": 1160,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 20502,
      "tests": 9,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.flows.data.LensesBuiltInDataSpec",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "LensesBuiltInData should Pre populated application languages are present in migrations",
          "classname": "io.lenses.store.jdbc.flows.data.LensesBuiltInDataSpec",
          "time": 8583,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesBuiltInData should Pre populated template categories are present in migrations",
          "classname": "io.lenses.store.jdbc.flows.data.LensesBuiltInDataSpec",
          "time": 1526,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesBuiltInData should Pre populated template types are present in migrations",
          "classname": "io.lenses.store.jdbc.flows.data.LensesBuiltInDataSpec",
          "time": 1643,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesBuiltInData should Pre populated key categories are present in migrations",
          "classname": "io.lenses.store.jdbc.flows.data.LensesBuiltInDataSpec",
          "time": 1370,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesBuiltInData should Pre populated key data types are present in migrations",
          "classname": "io.lenses.store.jdbc.flows.data.LensesBuiltInDataSpec",
          "time": 1376,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesBuiltInData should Pre populated built-in templates are present in migrations",
          "classname": "io.lenses.store.jdbc.flows.data.LensesBuiltInDataSpec",
          "time": 1460,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesBuiltInData should Configuration keys for pre populated built-in templates are present in migrations",
          "classname": "io.lenses.store.jdbc.flows.data.LensesBuiltInDataSpec",
          "time": 1384,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesBuiltInData should Pre populated key mappings for channel templates are present in migrations",
          "classname": "io.lenses.store.jdbc.flows.data.LensesBuiltInDataSpec",
          "time": 1700,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LensesBuiltInData should Pre populated enum values for channel templates are present",
          "classname": "io.lenses.store.jdbc.flows.data.LensesBuiltInDataSpec",
          "time": 1457,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1664,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.common.TemplateXMLGenerationTest",
      "timestamp": "2020-09-11T09:13:09",
      "testcase": [
        {
          "name": "TemplateXMLGeneration should generateLiquibaseInserts should not generate provided values for reference properties",
          "classname": "io.lenses.store.jdbc.common.TemplateXMLGenerationTest",
          "time": 988,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TemplateXMLGeneration should generateLiquibaseInserts should only generate enum values for non-reference, non-provided properties",
          "classname": "io.lenses.store.jdbc.common.TemplateXMLGenerationTest",
          "time": 676,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 45792,
      "tests": 15,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
      "timestamp": "2020-09-11T09:13:08",
      "testcase": [
        {
          "name": "registering external app should register entity if it was not there before",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 12703,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "registering external app should return an error if the app with given name exists and upsert = false",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 7545,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "registering external app should update entity if the app with given name exists and upsert = true",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 6959,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "registering runners should register runner if it was not there before (url as unique identifier)",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 738,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "registering runners should update modified_at and modified_by fields",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 736,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "registering runners should return an error if a runner with given name already exists",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 665,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "registering runners should return an error if there is no app with given name",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 725,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "removing external app should remove an existing app",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 822,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "removing external app should return an error if the app with given name does not exist",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 6869,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "removing runners should remove existing runners",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 705,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "removing runners should update modified_at and modified_by fields",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 543,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "reading all external apps should return all apps that were added",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 5346,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "reading all external apps should return empty list if no apps were added",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 512,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "reading external app by name should return an app if it exists",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 510,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "reading external app by name should return none if there is no app with given name",
          "classname": "io.lenses.store.jdbc.external_apps.ExternalAppsSqlStoreSpec",
          "time": 414,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1493,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.alert.AlertRuleChannelQueriesSpec",
      "timestamp": "2020-09-11T09:13:10",
      "testcase": [
        {
          "name": "AlertRuleChannelQueries should insertAlertRuleFixedChannels",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleChannelQueriesSpec",
          "time": 1368,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleChannelQueries should insertAlertRuleConditionChannels",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleChannelQueriesSpec",
          "time": 33,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleChannelQueries should selectAlertRuleFixed",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleChannelQueriesSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleChannelQueries should selectAlertRuleCondition",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleChannelQueriesSpec",
          "time": 83,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleChannelQueries should deleteAlertRuleFixed",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleChannelQueriesSpec",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleChannelQueries should deleteAlertRuleCondition",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleChannelQueriesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 8194,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.alert.AlertQueriesSpec",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "AlertQueries should insertAlertQuery",
          "classname": "io.lenses.store.jdbc.alert.AlertQueriesSpec",
          "time": 8056,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertQueries should deleteBeforeTimestampQuery",
          "classname": "io.lenses.store.jdbc.alert.AlertQueriesSpec",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertQueries should getAllQuery",
          "classname": "io.lenses.store.jdbc.alert.AlertQueriesSpec",
          "time": 120,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 11968,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.security.SecuritySqlStoreUserTest",
      "timestamp": "2020-09-11T09:13:04",
      "testcase": [
        {
          "name": "inserts users",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreUserTest",
          "time": 1539,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "inserting the same user again raises error",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreUserTest",
          "time": 1306,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update users",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreUserTest",
          "time": 1569,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns no records when there are no entries",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreUserTest",
          "time": 1516,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns None when for a given user name when there are no users",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreUserTest",
          "time": 1408,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns user detail",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreUserTest",
          "time": 1858,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deletes a user",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreUserTest",
          "time": 1534,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns false when deleting a user which does not exists",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreUserTest",
          "time": 1236,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 4629,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.settings.LensesSettingsDatabaseStoreLicenseTest",
      "timestamp": "2020-09-11T09:13:03",
      "testcase": [
        {
          "name": "returns None when there is no License",
          "classname": "io.lenses.store.jdbc.settings.LensesSettingsDatabaseStoreLicenseTest",
          "time": 1640,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "inserts and retrieves the license",
          "classname": "io.lenses.store.jdbc.settings.LensesSettingsDatabaseStoreLicenseTest",
          "time": 1495,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "inserts and update the license",
          "classname": "io.lenses.store.jdbc.settings.LensesSettingsDatabaseStoreLicenseTest",
          "time": 1494,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 26606,
      "tests": 12,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
      "timestamp": "2020-09-11T09:12:55",
      "testcase": [
        {
          "name": "Applications should add a new registered application for valid data",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 10739,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should allow to add label and annotations with equal keys and values and reuse metadata in proper way",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 1852,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should fail with IdentifierNotFoundError if ApplicationTemplateName does not exist",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 1297,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should fail with IdentifierNotFoundError if DeploymentTemplateName does not exist",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 1268,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should fail with IdentifierNotFoundError if there is an invalid connection reference",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 1649,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should delete an existing application",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 1998,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should get all existing applications",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 2217,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should return None when the record does not exist on delete",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 929,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should update existing property with new value",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 1594,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should insert optinal template field if previously not set",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 1105,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should return none if trying to update a non existing application",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 997,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Applications should return none if trying to update a non existing key",
          "classname": "io.lenses.store.jdbc.application.ApplicationSqlStoreSpec",
          "time": 960,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 8871,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.user.h2.UserProfileH2StoreTest",
      "timestamp": "2020-09-11T09:12:59",
      "testcase": [
        {
          "name": "UserProfileH2Store should returns empty Kafka connectors records for a user without any entries",
          "classname": "io.lenses.store.jdbc.user.h2.UserProfileH2StoreTest",
          "time": 3756,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert all possible data for a user",
          "classname": "io.lenses.store.jdbc.user.h2.UserProfileH2StoreTest",
          "time": 2078,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert the same records for two users but deleting one entry for first user does not impact the second user",
          "classname": "io.lenses.store.jdbc.user.h2.UserProfileH2StoreTest",
          "time": 1606,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert the same records for two users and deleting one entry globally it will impact both profiles",
          "classname": "io.lenses.store.jdbc.user.h2.UserProfileH2StoreTest",
          "time": 1430,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 8562,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.user.h2.SchemaRegistryTest",
      "timestamp": "2020-09-11T09:13:07",
      "testcase": [
        {
          "name": "UserProfileH2Store should returns empty SR for a user without any entries",
          "classname": "io.lenses.store.jdbc.user.h2.SchemaRegistryTest",
          "time": 1532,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert and read a SR subject",
          "classname": "io.lenses.store.jdbc.user.h2.SchemaRegistryTest",
          "time": 1386,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert the same record twice is possible for the same user",
          "classname": "io.lenses.store.jdbc.user.h2.SchemaRegistryTest",
          "time": 1326,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert multiple SR entries for one user and then delete one",
          "classname": "io.lenses.store.jdbc.user.h2.SchemaRegistryTest",
          "time": 1623,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert and delete records for multiple users",
          "classname": "io.lenses.store.jdbc.user.h2.SchemaRegistryTest",
          "time": 1454,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert multiple SR entries and delete one globally",
          "classname": "io.lenses.store.jdbc.user.h2.SchemaRegistryTest",
          "time": 1240,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 18736,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.security.SecuritySqlStoreGroupTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "inserts groups",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreGroupTest",
          "time": 7902,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "inserting the same group again raises error",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreGroupTest",
          "time": 1786,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update groups",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreGroupTest",
          "time": 1773,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns no records when there are no entries",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreGroupTest",
          "time": 1401,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns None when for a given group name when there are no groups",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreGroupTest",
          "time": 1512,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns group detail",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreGroupTest",
          "time": 1474,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deletes a group",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreGroupTest",
          "time": 1374,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns false when deleting a group which does not exists",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreGroupTest",
          "time": 1513,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 28458,
      "tests": 18,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
      "timestamp": "2020-09-11T09:12:56",
      "testcase": [
        {
          "name": "AlertRuleH2Store should getFixedAlertRule should return default rule if not persisted yet",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 7053,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should updateFixedAlertRule should persist updates",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 2608,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should updateFixedAlertRule should not prevent deletion of associated channels",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 1576,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should patchFixedAlertRule should persist updates",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 1438,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should patchFixedAlertRule should insert default enabled record when only defining channels initially",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 1613,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should getConditionalAlertRule should return default rule if not persisted yet",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 1580,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should addAlertRuleCondition should add new conditions",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 2042,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should addAlertRuleCondition should not prevent deletion of associated channels",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 1776,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should updateAlertRuleCondition should return None if condition doesn't exist",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 1190,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should updateAlertRuleCondition should update an existing condition",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 958,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should updateAlertRuleCondition should trigger conditions to be sorted to top",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 925,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should updateAlertRuleCondition should return None if condition deleted",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 1003,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should deleteAlertRuleCondition should return None if condition doesn't exist",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 799,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should deleteAlertRuleCondition should delete an existing condition",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 655,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should getAlertRule should return the default rule corresponding to the type of the ID",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 700,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should getAlertRule should return the correct type of persisted rule",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 735,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should getAlertRules should return the default rules corresponding to the type of the IDs",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 775,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleH2Store should getAlertRules should return up to date rules",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleH2StoreSpec",
          "time": 1030,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 12505,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
      "timestamp": "2020-09-11T09:13:08",
      "testcase": [
        {
          "name": "AlertH2Store should get() returns an empty list when there are no records",
          "classname": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
          "time": 1602,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertH2Store should insert a new alert",
          "classname": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
          "time": 1530,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertH2Store should get() returns the inserted element",
          "classname": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
          "time": 1756,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertH2Store should get() returns multiple events, in order they were added",
          "classname": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
          "time": 1304,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertH2Store should get() filters by partial case-insensitive summary",
          "classname": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
          "time": 1508,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertH2Store should get() filters by exact category match",
          "classname": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
          "time": 1264,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertH2Store should get() filters by alert level",
          "classname": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
          "time": 911,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertH2Store should get() filters by alertId",
          "classname": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
          "time": 871,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertH2Store should get() only returns requested page",
          "classname": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
          "time": 995,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertH2Store should delete records older than a certain timestamp",
          "classname": "io.lenses.store.jdbc.alert.AlertH2StoreSpec",
          "time": 763,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 18332,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.security.SecuritySqlStoreServiceAccountTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "inserts sa",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreServiceAccountTest",
          "time": 7893,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "inserting the same sa again raises error",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreServiceAccountTest",
          "time": 1779,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "update sa",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreServiceAccountTest",
          "time": 1710,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns no records when there are no entries",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreServiceAccountTest",
          "time": 1384,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns None when for a given sa when there are no entries",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreServiceAccountTest",
          "time": 1335,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns sa account detail",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreServiceAccountTest",
          "time": 1445,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deletes a sa",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreServiceAccountTest",
          "time": 1104,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "returns false when deleting a sa does not exists",
          "classname": "io.lenses.store.jdbc.security.SecuritySqlStoreServiceAccountTest",
          "time": 1680,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 37221,
      "tests": 35,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
      "timestamp": "2020-09-11T09:12:58",
      "testcase": [
        {
          "name": "FlowsSqlStore should Get None when fetching a non existing credentials by name",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 4989,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should getAll returns build in Lenses credentials when there are no records added",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1616,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should Insert a new element",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1848,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should generate new element Id n Insert",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1458,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should Retrieve an existing element",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1414,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should Retrieve all elements",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1508,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should Fails when inserting credentials with existing name",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1376,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should return updated record index if it exists on update",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1577,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should update credentials on update",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1434,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should return None when the record does not exist on update",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1176,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should fail when the credential of given type exists with given name",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1095,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should fail when the credential of different type exists with given name",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 1023,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should not create credentials on update when row does not exist",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 852,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should delete credentials should delete existing credentials on delete",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 889,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should delete credentials should fail to remove credentials with connection assigned to it",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 748,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should delete credentials should return None when the record does not exist on delete",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 655,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should delete connection should delete existing connection on delete",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 802,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should delete connection should return None when the connection does not exist on delete",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 767,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should delete connection should fail to remove connection that is in use",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 896,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should get connections by credentials id",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 798,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should get all connections",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 790,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should Get None when fetching by name a non existing connection",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 646,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should Retrieve an existing connection",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 710,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should fail to add connections with invalid credentials id",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 667,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should fail to add connections with invalid template details (name - version)",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 590,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should fail to add connection with already existing name",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 641,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should return updated connection index if it exists on update",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 698,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should update connection on update",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 833,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should return None when the connection does not exist on update",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 708,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "FlowsSqlStore should not create connection on update when row does not exist",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 605,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Lenses Key Vault Secrets should return None if they do not exist on getFromLensesKeyVault",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 648,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Lenses Key Vault Secrets should be added when it does not exist on setInLensesKeyVault",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 693,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Lenses Key Vault Secrets should be updated when it exists on setInLensesKeyVault",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 707,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Lenses Key Vault Secrets should be removed on deleteFromLensesKeyVault",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 682,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Lenses Key Vault Secrets should return None if they do not exist on deleteFromLensesKeyVault",
          "classname": "io.lenses.store.jdbc.flows.FlowsSqlStoreSpec",
          "time": 681,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1848,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.engines.WindowedTypesMigrationSpec",
      "timestamp": "2020-09-11T09:13:13",
      "testcase": [
        {
          "name": "Migration script should migrate correctly existing data to timed window key types",
          "classname": "io.lenses.store.jdbc.engines.WindowedTypesMigrationSpec",
          "time": 1848,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 5425,
      "tests": 4,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.H2StoreTest",
      "timestamp": "2020-09-11T09:13:11",
      "testcase": [
        {
          "name": "H2Store should open a db connection to H2",
          "classname": "io.lenses.store.jdbc.H2StoreTest",
          "time": 1384,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "H2Store should store a key and return it",
          "classname": "io.lenses.store.jdbc.H2StoreTest",
          "time": 1394,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "H2Store should store a key and update it",
          "classname": "io.lenses.store.jdbc.H2StoreTest",
          "time": 1335,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "H2Store should store a keys in multiple namespaces and return them",
          "classname": "io.lenses.store.jdbc.H2StoreTest",
          "time": 1312,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 13670,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.user.h2.SqlProcessorTest",
      "timestamp": "2020-09-11T09:12:55",
      "testcase": [
        {
          "name": "UserProfileH2Store should returns empty processors for a user without any entries",
          "classname": "io.lenses.store.jdbc.user.h2.SqlProcessorTest",
          "time": 7360,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert and read a sql processor",
          "classname": "io.lenses.store.jdbc.user.h2.SqlProcessorTest",
          "time": 1718,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert multiple sql processors and delete one for the user",
          "classname": "io.lenses.store.jdbc.user.h2.SqlProcessorTest",
          "time": 1664,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert and delete records for multiple users",
          "classname": "io.lenses.store.jdbc.user.h2.SqlProcessorTest",
          "time": 1442,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert multiple sql processors and delete one globally",
          "classname": "io.lenses.store.jdbc.user.h2.SqlProcessorTest",
          "time": 1484,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 15678,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.user.h2.KafkaTopicTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "UserProfileH2Store should returns empty Kafka topics for a user without any entries",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaTopicTest",
          "time": 7908,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert and read a kafka topic",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaTopicTest",
          "time": 1688,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert the same record twice is possible for the same user",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaTopicTest",
          "time": 1598,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert multiple Kafka topics for one user and then delete one",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaTopicTest",
          "time": 1366,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert and delete records for multiple users",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaTopicTest",
          "time": 1422,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "UserProfileH2Store should insert multiple topics and delete one globally",
          "classname": "io.lenses.store.jdbc.user.h2.KafkaTopicTest",
          "time": 1692,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 13093,
      "tests": 3,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.audits.h2.AuditH2StoreTest",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "AuditH2Store should store records",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StoreTest",
          "time": 8786,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should delete records older than a certain timestamp",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StoreTest",
          "time": 2657,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should returns the list of distinct values for change, resource and user ignoring unknown values",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StoreTest",
          "time": 1648,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 3676,
      "tests": 46,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
      "timestamp": "2020-09-11T09:13:03",
      "testcase": [
        {
          "name": "insertCredential",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 1574,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updateCredential",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getCredentialByName",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getAllCredentials",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleteCredential",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 2,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertTag",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getTagByName",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getTagById",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertCredentialsTag",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 79,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertConnectionTag",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 124,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getCredentialsTags",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getConnectionTags(1)",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleteCredentialTagsLinks",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 38,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleteConnectionTagsLinks",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertTemplate",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 166,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertTemplateCategory",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 254,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getAllTemplateCategories",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertApplicationLanguage",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 111,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getAllApplicationLanguages",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertTemplateType",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 63,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getAllTemplateTypes",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 28,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertConfigurationKey",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 72,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertPropertyKeyEnum",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 55,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getConnectionPropertiesByTemplateId",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getConnectionPropertiesByTemplateIds",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 106,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getConnectionPropertyByTemplateIdAndKey",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getTemplatesByCategoryName",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getTemplateByIdAndType",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 64,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getVersionTemplateByNameAndCategory",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 8,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertKeyDataType",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 208,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getAllKeyDataTypes",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 33,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertKeyCategory",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 80,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getAllKeyCategories",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 42,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertConnection",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getConnections",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 108,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getConnectionsByCredentialsId",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 40,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getConnectionByName",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 30,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updateConnection",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertIntoLensesKeyVault",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updateLensesKeyVault",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getFromLensesKeyVault",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 59,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleteFromLensesKeyVault",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertTemplatePropertyLink",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getPropertyProvidedValuesByPropertyKeyId",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 54,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "getPropertyProvidedValuesByPropertyKeyIds",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 116,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertPropertyProvidedValue",
          "classname": "io.lenses.store.jdbc.flows.FlowsQueriesSpec",
          "time": 9,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 9102,
      "tests": 15,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "insertChannel",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 8071,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "selectAllChannels",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 270,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "selectAllChannelsByTemplateTypeName",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 211,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "selectAllChannelsByTemplateTypeNameAndIds",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 57,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "selectChannelById",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 17,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "updateChannel",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "patchChannel",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 46,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleteChannel",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "selectChannelTemplateById",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 66,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "selectAllChannelTemplates",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 83,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "selectAllChannelTemplatesByTemplateTypeName",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "insertChannelProperties",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 218,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "selectChannelPropertiesByChannelId",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 13,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "deleteChannelProperties",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "selectTemplatePropertyBridgeByTemplateId",
          "classname": "io.lenses.store.jdbc.channel.ChannelQueriesSpec",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1708,
      "tests": 7,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.alert.AlertRuleQueriesSpec",
      "timestamp": "2020-09-11T09:13:08",
      "testcase": [
        {
          "name": "AlertRuleQueries should upsertFixedAlertRuleStatus",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleQueriesSpec",
          "time": 1519,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleQueries should insert + update FixedAlertRuleStatus",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleQueriesSpec",
          "time": 5,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleQueries should addAlertRuleCondition",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleQueriesSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleQueries should updateAlertRuleCondition",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleQueriesSpec",
          "time": 40,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleQueries should deleteAlertRuleCondition",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleQueriesSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleQueries should getFixedAlertRule",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleQueriesSpec",
          "time": 24,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AlertRuleQueries should getAlertRuleConditions",
          "classname": "io.lenses.store.jdbc.alert.AlertRuleQueriesSpec",
          "time": 114,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6904,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
      "timestamp": "2020-09-11T09:12:54",
      "testcase": [
        {
          "name": "MetricsQueries should selectMetricsKeys",
          "classname": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
          "time": 6442,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsQueries should insertMetricsKey",
          "classname": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
          "time": 34,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsQueries should insertMetricsValue",
          "classname": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
          "time": 49,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsQueries should deleteMetricsValues",
          "classname": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsQueries should deleteMetricsValuesBefore",
          "classname": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsQueries should deleteUnusedMetricsKeys",
          "classname": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsQueries should selectMetricsValues",
          "classname": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
          "time": 280,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsQueries should selectMetricsValuesForKeys",
          "classname": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
          "time": 48,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsQueries should selectAllMetricKeys",
          "classname": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
          "time": 19,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "MetricsQueries should selectAllMetricValues",
          "classname": "io.lenses.store.jdbc.metrics.MetricsQueriesSpec",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 6098,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.H2StoreFactorySpec",
      "timestamp": "2020-09-11T09:13:09",
      "testcase": [
        {
          "name": "store provider should initialise the store without errors",
          "classname": "io.lenses.store.jdbc.H2StoreFactorySpec",
          "time": 3711,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "store provider should prepopulate the DB with proper templates",
          "classname": "io.lenses.store.jdbc.H2StoreFactorySpec",
          "time": 2388,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1520,
      "tests": 10,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
      "timestamp": "2020-09-11T09:13:07",
      "testcase": [
        {
          "name": "AuditQueries should writeSql",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
          "time": 1374,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditQueries should deleteBeforeTimestampQuery",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditQueries should countGroupedByUserSql",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
          "time": 4,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditQueries should getAllQuery",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
          "time": 61,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditQueries should getByResourceIdQuery",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
          "time": 40,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditQueries should countSql",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
          "time": 10,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditQueries should truncateSql",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditQueries should usersSql",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditQueries should changeSql",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
          "time": 12,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditQueries should resourceSql",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditQueriesSpec",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 23778,
      "tests": 11,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
      "timestamp": "2020-09-11T09:12:55",
      "testcase": [
        {
          "name": "AuditH2Store should returns 0 data for audits when there are no records",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 7189,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should returns 1 data for audits when there is 1 record",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 2076,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should returns 9 items for audits and two pages when there are 11 records and page size is 9",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 1516,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should returns pageCount = 1, when number of records = pageSize",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 3186,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should returns the data paginated",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 2437,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should returns 5 records for audits when there are 11 records and there's a filter on TOPIC resource and there are 6 records like that",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 1550,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should returns 2 records for audits when there are 11 records and there's a filter on TOPIC resource and change type UPDATE and there are 3 records matching the filter",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 1552,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should returns 2 records for audits when there are 11 records and there's a filter on resource, change, user, and there are 3 records matching the filter",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 1420,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should returns the data when filtering on users, change, resource type and resourceId",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 862,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should returns count of distinct users with",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 954,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "AuditH2Store should setting invertedFilter to true inverts the results",
          "classname": "io.lenses.store.jdbc.audits.h2.AuditH2StorePaginationTest",
          "time": 1034,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1524,
      "tests": 5,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyPermissionActorTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "Apply authentication to given nodes and publish to subscribers",
          "classname": "io.lenses.topology.TopologyPermissionActorTest",
          "time": 358,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Publish an update to connector metrics if user is allowed to see the node",
          "classname": "io.lenses.topology.TopologyPermissionActorTest",
          "time": 304,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Publish an update to processor metrics if user is allowed to see the node",
          "classname": "io.lenses.topology.TopologyPermissionActorTest",
          "time": 288,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Publish an update to topic stats if user is allowed to see the node",
          "classname": "io.lenses.topology.TopologyPermissionActorTest",
          "time": 289,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Publish an update to node status if user is allowed to see the node",
          "classname": "io.lenses.topology.TopologyPermissionActorTest",
          "time": 285,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 220,
      "tests": 8,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyRenderTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "render empty topology",
          "classname": "io.lenses.topology.TopologyRenderTest",
          "time": 117,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "render a topic",
          "classname": "io.lenses.topology.TopologyRenderTest",
          "time": 88,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "render a producer->topic",
          "classname": "io.lenses.topology.TopologyRenderTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "render a producer->topic->consumer",
          "classname": "io.lenses.topology.TopologyRenderTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "render a producer->topic->consumer1/consumer2",
          "classname": "io.lenses.topology.TopologyRenderTest",
          "time": 1,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "render a 2X producer->topic->consumer",
          "classname": "io.lenses.topology.TopologyRenderTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "render a producer->topicA->consumer1 and topicA->processor->topicB->consumer2",
          "classname": "io.lenses.topology.TopologyRenderTest",
          "time": 3,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "render correctly multi topics source file sink",
          "classname": "io.lenses.topology.TopologyRenderTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 219481,
      "tests": 2,
      "failures": 2,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyMetricsTaskTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "TopologyMetricsTask should detect metrics from the kafka metrics topic",
          "classname": "io.lenses.topology.TopologyMetricsTaskTest",
          "time": 61796,
          "failure": {
            "message": "org.apache.kafka.common.errors.TimeoutException: Topic top_metric_2630fab5-a75c-4388-bf72-0c29a03d2b65 not present in metadata after 60000 ms.",
            "type": "java.util.concurrent.ExecutionException",
            "stackTrace": "java.util.concurrent.ExecutionException: org.apache.kafka.common.errors.TimeoutException: Topic top_metric_2630fab5-a75c-4388-bf72-0c29a03d2b65 not present in metadata after 60000 ms.\n\tat org.apache.kafka.clients.producer.KafkaProducer$FutureFailure.<init>(KafkaProducer.java:1269)\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:933)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:856)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:743)\n\tat io.lenses.topology.TopologyMetricsTaskTest.$anonfun$new$2(TopologyMetricsTaskTest.scala:61)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat org.scalatest.wordspec.AnyWordSpec.run(AnyWordSpec.scala:1879)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: org.apache.kafka.common.errors.TimeoutException: Topic top_metric_2630fab5-a75c-4388-bf72-0c29a03d2b65 not present in metadata after 60000 ms."
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "TopologyMetricsTask should combine metrics for the same app",
          "classname": "io.lenses.topology.TopologyMetricsTaskTest",
          "time": 157684,
          "failure": {
            "message": "assertion failed: timeout (37500 milliseconds) during expectMsgClass waiting for class io.lenses.domain.topology.TopologySqlStreamMetricsUpdate",
            "type": "java.lang.AssertionError",
            "stackTrace": "java.lang.AssertionError: assertion failed: timeout (37500 milliseconds) during expectMsgClass waiting for class io.lenses.domain.topology.TopologySqlStreamMetricsUpdate\n\tat scala.Predef$.assert(Predef.scala:223)\n\tat akka.testkit.TestKitBase.expectMsgClass_internal(TestKit.scala:529)\n\tat akka.testkit.TestKitBase.expectMsgType(TestKit.scala:511)\n\tat akka.testkit.TestKitBase.expectMsgType$(TestKit.scala:510)\n\tat akka.testkit.TestKit.expectMsgType(TestKit.scala:929)\n\tat io.lenses.topology.TopologyMetricsTaskTest.$anonfun$new$3(TopologyMetricsTaskTest.scala:97)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat org.scalatest.wordspec.AnyWordSpec.run(AnyWordSpec.scala:1879)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 90779,
      "tests": 10,
      "failures": 9,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyActorTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "TopologyActor should return global topology",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10439,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$2(TopologyActorTest.scala:113)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "TopologyActor should render only topics that are referenced",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10017,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$21(TopologyActorTest.scala:300)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "TopologyActor should correctly get topology of a Mongo sink once it has been updated",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10012,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$26(TopologyActorTest.scala:400)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "TopologyActor should correctly get topology of a File Sink sink once it has been updated",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10007,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$34(TopologyActorTest.scala:467)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$34$adapted(TopologyActorTest.scala:467)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$33(TopologyActorTest.scala:467)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "TopologyActor should handle producer - consumer",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 273,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TopologyActor should do not duplicate topic nodes",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10005,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$43(TopologyActorTest.scala:633)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "TopologyActor should forward events to permission actor so that they eventually reach the output actor",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10008,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$46(TopologyActorTest.scala:729)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "TopologyActor should handles closed loop processor INSERT INTO B SELECT STREAM * FROM A; INSERT INTO A SELECT STREAM * FROM B",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10003,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$47(TopologyActorTest.scala:785)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "TopologyActor should handles closed loop processor INSERT INTO B SELECT STREAM * FROM A; INSERT INTO A SELECT STREAM * FROM B;INSERT INTO A SELECT STREAM * FROM A",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10005,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$57(TopologyActorTest.scala:863)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        },
        {
          "name": "handles updates of the number of runners",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10005,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$69(TopologyActorTest.scala:962)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 102,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyMetricsSemigroupTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "monoid should combine",
          "classname": "io.lenses.topology.TopologyMetricsSemigroupTest",
          "time": 102,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "should ignore empty monoid",
          "classname": "io.lenses.topology.TopologyMetricsSemigroupTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 350,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyPermissionRulesTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "Topology with connect source/sink, multiple topics and two sql processors",
          "classname": "io.lenses.topology.TopologyPermissionRulesTest",
          "time": 350,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 61795,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyTaskTest",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "TopologyTask should read topology from a kafka topic",
          "classname": "io.lenses.topology.TopologyTaskTest",
          "time": 61795,
          "failure": {
            "message": "org.apache.kafka.common.errors.TimeoutException: Topic top1_1599812024173 not present in metadata after 60000 ms.",
            "type": "java.util.concurrent.ExecutionException",
            "stackTrace": "java.util.concurrent.ExecutionException: org.apache.kafka.common.errors.TimeoutException: Topic top1_1599812024173 not present in metadata after 60000 ms.\n\tat org.apache.kafka.clients.producer.KafkaProducer$FutureFailure.<init>(KafkaProducer.java:1269)\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:933)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:856)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:743)\n\tat io.lenses.topology.TopologyTaskTest.$anonfun$new$2(TopologyTaskTest.scala:62)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyTaskTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyTaskTest.scala:23)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyTaskTest.run(TopologyTaskTest.scala:23)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: org.apache.kafka.common.errors.TimeoutException: Topic top1_1599812024173 not present in metadata after 60000 ms."
          },
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1069,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyFormatsSpec",
      "timestamp": "2020-09-11T09:13:43",
      "testcase": [
        {
          "name": "TopologyFormats should encode ExternalAppSourceType as plain value",
          "classname": "io.lenses.topology.TopologyFormatsSpec",
          "time": 1069,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 38,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.registry.units.StorageUnitsTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "handle 0 bytes",
          "classname": "io.lenses.registry.units.StorageUnitsTest",
          "time": 23,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "render as human readable",
          "classname": "io.lenses.registry.units.StorageUnitsTest",
          "time": 15,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 22,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.registry.LoadWithSnapshotTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "LoadWithSnapshot should does not remove items added after the load from source started",
          "classname": "io.lenses.registry.LoadWithSnapshotTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "LoadWithSnapshot should remove items which are not in the source anymore",
          "classname": "io.lenses.registry.LoadWithSnapshotTest",
          "time": 6,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 25,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.registry.TableMetadataLoaderFromStorageWithRetryTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "TableMetadataLoaderFromStorageWithRetry should retry 3 times",
          "classname": "io.lenses.registry.TableMetadataLoaderFromStorageWithRetryTest",
          "time": 14,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "TableMetadataLoaderFromStorageWithRetry should returns the exception from onFailureF",
          "classname": "io.lenses.registry.TableMetadataLoaderFromStorageWithRetryTest",
          "time": 11,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 131,
      "tests": 2,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.registry.RetryTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "Retry should return if the function succeeds",
          "classname": "io.lenses.registry.RetryTest",
          "time": 29,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Retry should return once it succeeds",
          "classname": "io.lenses.registry.RetryTest",
          "time": 102,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 31,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.registry.units.TimeUnitsTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "translate to human readable",
          "classname": "io.lenses.registry.units.TimeUnitsTest",
          "time": 31,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 66,
      "tests": 6,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.registry.kafka.FormatKafkaValuesTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "ms = -1 it returns infinite",
          "classname": "io.lenses.registry.kafka.FormatKafkaValuesTest",
          "time": 43,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Max it returns more than 1000y",
          "classname": "io.lenses.registry.kafka.FormatKafkaValuesTest",
          "time": 16,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "ms = 2 it returns 2d",
          "classname": "io.lenses.registry.kafka.FormatKafkaValuesTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "bytes = -1 it returns infinite",
          "classname": "io.lenses.registry.kafka.FormatKafkaValuesTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "bytes = 2 it returns 2",
          "classname": "io.lenses.registry.kafka.FormatKafkaValuesTest",
          "time": 7,
          "failure": null,
          "error": null,
          "skipped": false
        },
        {
          "name": "Max it returns more than 1000y",
          "classname": "io.lenses.registry.kafka.FormatKafkaValuesTest",
          "time": 0,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    },
    {
      "time": 1146,
      "tests": 1,
      "failures": 0,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.registry.kafka.KafkaTableRepositoryTest",
      "timestamp": "2020-09-11T09:12:51",
      "testcase": [
        {
          "name": "load initial values from storage",
          "classname": "io.lenses.registry.kafka.KafkaTableRepositoryTest",
          "time": 1146,
          "failure": null,
          "error": null,
          "skipped": false
        }
      ]
    }
  ],
  "failed": [
    {
      "time": 65329,
      "tests": 11,
      "failures": 3,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.TopicCommandTest",
      "timestamp": "2020-09-11T09:14:07",
      "failedTestcases": [
        {
          "name": "createTopic should create a topic with compact cleanup policy",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 20011,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.core.kafka.TopicCommand$.$anonfun$createTopic$1(TopicCommand.scala:90)\n\tat io.lenses.domain.logging.MetricsSupport.timed(MetricsSupport.scala:22)\n\tat io.lenses.domain.logging.MetricsSupport.timed$(MetricsSupport.scala:20)\n\tat io.lenses.core.kafka.TopicCommand$.timed(TopicCommand.scala:44)\n\tat io.lenses.core.kafka.TopicCommand$.createTopic(TopicCommand.scala:55)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$8(TopicCommandTest.scala:106)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$8$adapted(TopicCommandTest.scala:97)\n\tat io.lenses.core.kafka.TopicCommandTest.testEnvironment$1(TopicCommandTest.scala:68)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$6(TopicCommandTest.scala:97)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.kafka.TopicCommandTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicCommandTest.scala:54)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.core.kafka.TopicCommandTest.run(TopicCommandTest.scala:54)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "type CreateTime",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 20013,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.core.kafka.TopicCommand$.$anonfun$createTopic$1(TopicCommand.scala:90)\n\tat io.lenses.domain.logging.MetricsSupport.timed(MetricsSupport.scala:22)\n\tat io.lenses.domain.logging.MetricsSupport.timed$(MetricsSupport.scala:20)\n\tat io.lenses.core.kafka.TopicCommand$.timed(TopicCommand.scala:44)\n\tat io.lenses.core.kafka.TopicCommand$.createTopic(TopicCommand.scala:55)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$13(TopicCommandTest.scala:126)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$13$adapted(TopicCommandTest.scala:119)\n\tat io.lenses.core.kafka.TopicCommandTest.testEnvironment$1(TopicCommandTest.scala:68)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$11(TopicCommandTest.scala:119)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.kafka.TopicCommandTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicCommandTest.scala:54)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.core.kafka.TopicCommandTest.run(TopicCommandTest.scala:54)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "createTopic should update topic config, preserving default values",
          "classname": "io.lenses.core.kafka.TopicCommandTest",
          "time": 25048,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.core.kafka.TopicCommand$.$anonfun$createTopic$1(TopicCommand.scala:90)\n\tat io.lenses.domain.logging.MetricsSupport.timed(MetricsSupport.scala:22)\n\tat io.lenses.domain.logging.MetricsSupport.timed$(MetricsSupport.scala:20)\n\tat io.lenses.core.kafka.TopicCommand$.timed(TopicCommand.scala:44)\n\tat io.lenses.core.kafka.TopicCommand$.createTopic(TopicCommand.scala:55)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$19(TopicCommandTest.scala:146)\n\tat io.lenses.core.kafka.TopicCommandTest.withKafkaTableRepository(TopicCommandTest.scala:344)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$18(TopicCommandTest.scala:145)\n\tat io.lenses.core.kafka.TopicCommandTest.testEnvironment$1(TopicCommandTest.scala:68)\n\tat io.lenses.core.kafka.TopicCommandTest.$anonfun$new$16(TopicCommandTest.scala:139)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.kafka.TopicCommandTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicCommandTest.scala:54)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.core.kafka.TopicCommandTest.run(TopicCommandTest.scala:54)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 120049,
      "tests": 6,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.lsql.JdbcRoutesControllerInsertStatementTest",
      "timestamp": "2020-09-11T09:14:11",
      "failedTestcases": [
        {
          "name": "handlePrepareStatementData should return partition and offset info",
          "classname": "io.lenses.core.lsql.JdbcRoutesControllerInsertStatementTest",
          "time": 120027,
          "failure": {
            "message": "Topic myTopic not present in metadata after 60000 ms.",
            "type": "org.apache.kafka.common.errors.TimeoutException",
            "stackTrace": "org.apache.kafka.common.errors.TimeoutException: Topic myTopic not present in metadata after 60000 ms."
          }
        }
      ]
    },
    {
      "time": 192931,
      "tests": 5,
      "failures": 4,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
      "timestamp": "2020-09-11T09:14:12",
      "failedTestcases": [
        {
          "name": "describeCluster should returns the Kafka cluster description",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
          "time": 5008,
          "failure": {
            "message": "Timed out waiting for a node assignment.",
            "type": "org.apache.kafka.common.errors.TimeoutException",
            "stackTrace": "org.apache.kafka.common.errors.TimeoutException: Timed out waiting for a node assignment."
          }
        },
        {
          "name": "describeLogDirs should returns logDir info by broker id",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
          "time": 5008,
          "failure": {
            "message": "Set() was not equal to Set(0)",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: Set() was not equal to Set(0)\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImplSpec.$anonfun$new$8(KafkaAdminClientImplSpec.scala:34)\n\tat cats.effect.IO$Map.apply(IO.scala:1504)\n\tat cats.effect.IO$Map.apply(IO.scala:1502)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:142)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:361)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.run(Callback.scala:130)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.apply(Callback.scala:136)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.apply(Callback.scala:125)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImpl.$anonfun$describeLogDirs$8(KafkaAdminClientImpl.scala:162)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImpl.$anonfun$describeLogDirs$8$adapted(KafkaAdminClientImpl.scala:162)\n\tat io.lenses.core.kafka.KafkaFutureOps$Wrapper.$anonfun$asyncComplete$1(KafkaFutureOps.scala:48)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer.accept(KafkaFutureImpl.java:175)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer.accept(KafkaFutureImpl.java:162)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.completeExceptionally(KafkaFutureImpl.java:238)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient.completeAllExceptionally(KafkaAdminClient.java:287)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient.access$2300(KafkaAdminClient.java:181)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$14.handleFailure(KafkaAdminClient.java:2134)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$Call.fail(KafkaAdminClient.java:641)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor.handleTimeouts(KafkaAdminClient.java:757)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable.timeoutPendingCalls(KafkaAdminClient.java:825)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable.run(KafkaAdminClient.java:1119)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "describeLogDirs should omits the log dir info when a broker lookup fails",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
          "time": 5005,
          "failure": {
            "message": "Set() was not equal to Set(0)",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: Set() was not equal to Set(0)\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImplSpec.$anonfun$new$11(KafkaAdminClientImplSpec.scala:41)\n\tat cats.effect.IO$Map.apply(IO.scala:1504)\n\tat cats.effect.IO$Map.apply(IO.scala:1502)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:142)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:361)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.run(Callback.scala:130)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.apply(Callback.scala:136)\n\tat cats.effect.internals.Callback$AsyncIdempotentCallback.apply(Callback.scala:125)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImpl.$anonfun$describeLogDirs$8(KafkaAdminClientImpl.scala:162)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImpl.$anonfun$describeLogDirs$8$adapted(KafkaAdminClientImpl.scala:162)\n\tat io.lenses.core.kafka.KafkaFutureOps$Wrapper.$anonfun$asyncComplete$1(KafkaFutureOps.scala:48)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer.accept(KafkaFutureImpl.java:175)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer.accept(KafkaFutureImpl.java:162)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.completeExceptionally(KafkaFutureImpl.java:238)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient.completeAllExceptionally(KafkaAdminClient.java:287)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient.access$2300(KafkaAdminClient.java:181)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$14.handleFailure(KafkaAdminClient.java:2134)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$Call.fail(KafkaAdminClient.java:641)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor.handleTimeouts(KafkaAdminClient.java:757)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable.timeoutPendingCalls(KafkaAdminClient.java:825)\n\tat org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable.run(KafkaAdminClient.java:1119)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "describeTopics should return a key for an existing topic",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientImplSpec",
          "time": 57900,
          "failure": {
            "message": null,
            "type": "java.lang.InterruptedException",
            "stackTrace": "java.lang.InterruptedException\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:998)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\n\tat cats.effect.internals.IOPlatform$.$anonfun$unsafeResync$2(IOPlatform.scala:51)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$DefaultBlockContext$.blockOn(BlockContext.scala:57)\n\tat scala.concurrent.package$.blocking(package.scala:146)\n\tat cats.effect.internals.IOPlatform$.unsafeResync(IOPlatform.scala:51)\n\tat cats.effect.IO.unsafeRunTimed(IO.scala:325)\n\tat cats.effect.IO.unsafeRunSync(IO.scala:240)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImplSpec.withAdminClient(KafkaAdminClientImplSpec.scala:69)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientImplSpec.$anonfun$new$16(KafkaAdminClientImplSpec.scala:55)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat org.scalatest.wordspec.AnyWordSpec.run(AnyWordSpec.scala:1879)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 192588,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.migration.AuditMigrationIntegrationTest",
      "timestamp": "2020-09-11T09:14:12",
      "failedTestcases": [
        {
          "name": "migrate audits to AuditStore",
          "classname": "io.lenses.core.migration.AuditMigrationIntegrationTest",
          "time": 192588,
          "failure": {
            "message": "java.lang.InterruptedException",
            "type": "org.apache.kafka.common.errors.InterruptException",
            "stackTrace": "org.apache.kafka.common.errors.InterruptException: java.lang.InterruptedException\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:937)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:856)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:743)\n\tat io.lenses.core.migration.AuditMigrationIntegrationTest.$anonfun$new$2(AuditMigrationIntegrationTest.scala:67)\n\tat scala.collection.immutable.Stream.foreach(Stream.scala:533)\n\tat io.lenses.core.migration.AuditMigrationIntegrationTest.$anonfun$new$1(AuditMigrationIntegrationTest.scala:60)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.InterruptedException\n\tat java.lang.Object.wait(Native Method)\n\tat org.apache.kafka.common.utils.SystemTime.waitObject(SystemTime.java:60)\n\tat org.apache.kafka.clients.producer.internals.ProducerMetadata.awaitUpdate(ProducerMetadata.java:97)\n\tat org.apache.kafka.clients.producer.KafkaProducer.waitOnMetadata(KafkaProducer.java:999)\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:876)\n\t... 61 more"
          }
        }
      ]
    },
    {
      "time": 196804,
      "tests": 2,
      "failures": 2,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.admin.KafkaAdminClientCreateAndDeleteSpec",
      "timestamp": "2020-09-11T09:14:08",
      "failedTestcases": [
        {
          "name": "createTopics and deleteTopics should work as expected when all topics new",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientCreateAndDeleteSpec",
          "time": 120021,
          "failure": {
            "message": "Timed out waiting for a node assignment.",
            "type": "org.apache.kafka.common.errors.TimeoutException",
            "stackTrace": "org.apache.kafka.common.errors.TimeoutException: Timed out waiting for a node assignment."
          }
        },
        {
          "name": "createTopics and deleteTopics should fail creating topics that are already present",
          "classname": "io.lenses.core.kafka.admin.KafkaAdminClientCreateAndDeleteSpec",
          "time": 76783,
          "failure": {
            "message": null,
            "type": "java.lang.InterruptedException",
            "stackTrace": "java.lang.InterruptedException\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:998)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\n\tat cats.effect.internals.IOPlatform$.$anonfun$unsafeResync$2(IOPlatform.scala:51)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$DefaultBlockContext$.blockOn(BlockContext.scala:57)\n\tat scala.concurrent.package$.blocking(package.scala:146)\n\tat cats.effect.internals.IOPlatform$.unsafeResync(IOPlatform.scala:51)\n\tat cats.effect.IO.unsafeRunTimed(IO.scala:325)\n\tat cats.effect.IO.unsafeRunSync(IO.scala:240)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientCreateAndDeleteSpec.withAdminClient(KafkaAdminClientCreateAndDeleteSpec.scala:79)\n\tat io.lenses.core.kafka.admin.KafkaAdminClientCreateAndDeleteSpec.$anonfun$new$9(KafkaAdminClientCreateAndDeleteSpec.scala:53)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat org.scalatest.wordspec.AnyWordSpec.run(AnyWordSpec.scala:1879)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 204154,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.migration.AlertMigrationIntegrationTest",
      "timestamp": "2020-09-11T09:14:00",
      "failedTestcases": [
        {
          "name": "migrate alerts to AlertStore",
          "classname": "io.lenses.core.migration.AlertMigrationIntegrationTest",
          "time": 204154,
          "failure": {
            "message": "java.lang.InterruptedException",
            "type": "org.apache.kafka.common.errors.InterruptException",
            "stackTrace": "org.apache.kafka.common.errors.InterruptException: java.lang.InterruptedException\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:937)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:856)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:743)\n\tat io.lenses.core.migration.AlertMigrationIntegrationTest.$anonfun$new$2(AlertMigrationIntegrationTest.scala:70)\n\tat scala.collection.immutable.Stream.foreach(Stream.scala:533)\n\tat io.lenses.core.migration.AlertMigrationIntegrationTest.$anonfun$new$1(AlertMigrationIntegrationTest.scala:62)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.InterruptedException\n\tat java.lang.Object.wait(Native Method)\n\tat org.apache.kafka.common.utils.SystemTime.waitObject(SystemTime.java:60)\n\tat org.apache.kafka.clients.producer.internals.ProducerMetadata.awaitUpdate(ProducerMetadata.java:97)\n\tat org.apache.kafka.clients.producer.KafkaProducer.waitOnMetadata(KafkaProducer.java:999)\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:876)\n\t... 61 more"
          }
        }
      ]
    },
    {
      "time": 10001,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.FetcherWrapperTest",
      "timestamp": "2020-09-11T09:14:14",
      "failedTestcases": [
        {
          "name": "should read last offset",
          "classname": "io.lenses.core.kafka.FetcherWrapperTest",
          "time": 10001,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.kafka.FetcherWrapperTest.createTopic(FetcherWrapperTest.scala:24)\n\tat io.lenses.core.kafka.FetcherWrapperTest.$anonfun$new$1(FetcherWrapperTest.scala:37)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.core.kafka.FetcherWrapperTest.withFixture(FetcherWrapperTest.scala:24)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.core.kafka.FetcherWrapperTest.runTest(FetcherWrapperTest.scala:24)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.core.kafka.FetcherWrapperTest.runTests(FetcherWrapperTest.scala:24)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.core.kafka.FetcherWrapperTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(FetcherWrapperTest.scala:24)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.kafka.FetcherWrapperTest.org$scalatest$BeforeAndAfterAll$$super$run(FetcherWrapperTest.scala:24)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.core.kafka.FetcherWrapperTest.run(FetcherWrapperTest.scala:24)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 205953,
      "tests": 2,
      "failures": 2,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.topics.TopicCreateServiceTest",
      "timestamp": "2020-09-11T09:13:58",
      "failedTestcases": [
        {
          "name": "createTopic should be able to create a topic and emit a single new dataset event",
          "classname": "io.lenses.core.kafka.topics.TopicCreateServiceTest",
          "time": 121176,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.core.kafka.TopicCommand$.$anonfun$createTopic$1(TopicCommand.scala:90)\n\tat io.lenses.domain.logging.MetricsSupport.timed(MetricsSupport.scala:22)\n\tat io.lenses.domain.logging.MetricsSupport.timed$(MetricsSupport.scala:20)\n\tat io.lenses.core.kafka.TopicCommand$.timed(TopicCommand.scala:44)\n\tat io.lenses.core.kafka.TopicCommand$.createTopic(TopicCommand.scala:55)\n\tat io.lenses.core.kafka.topics.TopicCreateServiceImpl.$anonfun$createTopic$2(TopicCreateService.scala:81)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:87)\n\tat cats.effect.internals.IORunLoop$.startCancelable(IORunLoop.scala:41)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:88)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "createTopic should be unable to create topic due to InvalidReplicationFactorException",
          "classname": "io.lenses.core.kafka.topics.TopicCreateServiceTest",
          "time": 84776,
          "failure": {
            "message": null,
            "type": "java.lang.InterruptedException",
            "stackTrace": "java.lang.InterruptedException\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:998)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\n\tat cats.effect.internals.IOPlatform$.$anonfun$unsafeResync$2(IOPlatform.scala:51)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$DefaultBlockContext$.blockOn(BlockContext.scala:57)\n\tat scala.concurrent.package$.blocking(package.scala:146)\n\tat cats.effect.internals.IOPlatform$.unsafeResync(IOPlatform.scala:51)\n\tat cats.effect.IO.unsafeRunTimed(IO.scala:325)\n\tat cats.effect.IO.unsafeRunSync(IO.scala:240)\n\tat io.lenses.core.kafka.topics.TopicCreateServiceTest.createTopicResultWithDatasetEvents(TopicCreateServiceTest.scala:99)\n\tat io.lenses.core.kafka.topics.TopicCreateServiceTest.$anonfun$new$2(TopicCreateServiceTest.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.flatspec.AnyFlatSpecLike$$anon$5.apply(AnyFlatSpecLike.scala:1683)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.flatspec.AnyFlatSpec.withFixture(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.invokeWithFixture$1(AnyFlatSpecLike.scala:1681)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTest$1(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest$(AnyFlatSpecLike.scala:1675)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTest(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTests$1(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests$(AnyFlatSpecLike.scala:1750)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTests(AnyFlatSpec.scala:1685)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.flatspec.AnyFlatSpec.org$scalatest$flatspec$AnyFlatSpecLike$$super$run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$run$1(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run$(AnyFlatSpecLike.scala:1794)\n\tat org.scalatest.flatspec.AnyFlatSpec.run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 45041,
      "tests": 4,
      "failures": 3,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.kafka.topics.TopicMessageResenderTest",
      "timestamp": "2020-09-11T09:14:11",
      "failedTestcases": [
        {
          "name": "resend should copy existing String message",
          "classname": "io.lenses.core.kafka.topics.TopicMessageResenderTest",
          "time": 10005,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createTopic(TopicMessageResenderTest.scala:30)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createUniqueTopic(TopicMessageResenderTest.scala:112)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.$anonfun$new$1(TopicMessageResenderTest.scala:48)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.flatspec.AnyFlatSpecLike$$anon$5.apply(AnyFlatSpecLike.scala:1683)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.flatspec.AnyFlatSpec.withFixture(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.invokeWithFixture$1(AnyFlatSpecLike.scala:1681)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTest$1(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest$(AnyFlatSpecLike.scala:1675)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTest(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTests$1(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests$(AnyFlatSpecLike.scala:1750)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTests(AnyFlatSpec.scala:1685)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.flatspec.AnyFlatSpec.org$scalatest$flatspec$AnyFlatSpecLike$$super$run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$run$1(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run$(AnyFlatSpecLike.scala:1794)\n\tat org.scalatest.flatspec.AnyFlatSpec.run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "resend should fail when partition does not exist",
          "classname": "io.lenses.core.kafka.topics.TopicMessageResenderTest",
          "time": 10001,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createTopic(TopicMessageResenderTest.scala:30)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createUniqueTopic(TopicMessageResenderTest.scala:112)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.$anonfun$new$5(TopicMessageResenderTest.scala:78)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.flatspec.AnyFlatSpecLike$$anon$5.apply(AnyFlatSpecLike.scala:1683)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.flatspec.AnyFlatSpec.withFixture(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.invokeWithFixture$1(AnyFlatSpecLike.scala:1681)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTest$1(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest$(AnyFlatSpecLike.scala:1675)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTest(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTests$1(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests$(AnyFlatSpecLike.scala:1750)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTests(AnyFlatSpec.scala:1685)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.flatspec.AnyFlatSpec.org$scalatest$flatspec$AnyFlatSpecLike$$super$run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$run$1(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run$(AnyFlatSpecLike.scala:1794)\n\tat org.scalatest.flatspec.AnyFlatSpec.run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "resend should fail when offset out of bounds",
          "classname": "io.lenses.core.kafka.topics.TopicMessageResenderTest",
          "time": 10003,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createTopic(TopicMessageResenderTest.scala:30)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.createUniqueTopic(TopicMessageResenderTest.scala:112)\n\tat io.lenses.core.kafka.topics.TopicMessageResenderTest.$anonfun$new$7(TopicMessageResenderTest.scala:91)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.flatspec.AnyFlatSpecLike$$anon$5.apply(AnyFlatSpecLike.scala:1683)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.flatspec.AnyFlatSpec.withFixture(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.invokeWithFixture$1(AnyFlatSpecLike.scala:1681)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTest$1(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest(AnyFlatSpecLike.scala:1693)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTest$(AnyFlatSpecLike.scala:1675)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTest(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$runTests$1(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests(AnyFlatSpecLike.scala:1751)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.runTests$(AnyFlatSpecLike.scala:1750)\n\tat org.scalatest.flatspec.AnyFlatSpec.runTests(AnyFlatSpec.scala:1685)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.flatspec.AnyFlatSpec.org$scalatest$flatspec$AnyFlatSpecLike$$super$run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.$anonfun$run$1(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run(AnyFlatSpecLike.scala:1796)\n\tat org.scalatest.flatspec.AnyFlatSpecLike.run$(AnyFlatSpecLike.scala:1794)\n\tat org.scalatest.flatspec.AnyFlatSpec.run(AnyFlatSpec.scala:1685)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 30766,
      "tests": 4,
      "failures": 3,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.KafkaTopicsActorSpec",
      "timestamp": "2020-09-11T09:14:02",
      "failedTestcases": [
        {
          "name": "ScheduleTopicPartitionsStatistics should handle DeleteFromTopicToOffset message for compacting topics by preventing deletion",
          "classname": "io.lenses.core.actors.KafkaTopicsActorSpec",
          "time": 10194,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.createTopic(KafkaTopicsActorSpec.scala:75)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.io$lenses$core$actors$KafkaTopicsActorSpec$$createTopicAndSetConfiguration(KafkaTopicsActorSpec.scala:232)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec$$anon$3.$anonfun$new$6(KafkaTopicsActorSpec.scala:140)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec$TestContext.$anonfun$withActor$4(KafkaTopicsActorSpec.scala:306)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:87)\n\tat cats.effect.internals.IORunLoop$.startCancelable(IORunLoop.scala:41)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:88)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat akka.dispatch.TaskInvocation.run(AbstractDispatcher.scala:47)\n\tat akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask.exec(ForkJoinExecutorConfigurator.scala:47)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          }
        },
        {
          "name": "ScheduleTopicPartitionsStatistics should handle DeleteFromTopicToOffset message for non-compacting topics by allowing deletion",
          "classname": "io.lenses.core.actors.KafkaTopicsActorSpec",
          "time": 10138,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.createTopic(KafkaTopicsActorSpec.scala:75)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.io$lenses$core$actors$KafkaTopicsActorSpec$$createTopicAndSetConfiguration(KafkaTopicsActorSpec.scala:232)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec$$anon$4.$anonfun$new$9(KafkaTopicsActorSpec.scala:162)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec$TestContext.$anonfun$withActor$4(KafkaTopicsActorSpec.scala:306)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:87)\n\tat cats.effect.internals.IORunLoop$.startCancelable(IORunLoop.scala:41)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:88)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat akka.dispatch.TaskInvocation.run(AbstractDispatcher.scala:47)\n\tat akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask.exec(ForkJoinExecutorConfigurator.scala:47)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          }
        },
        {
          "name": "ScheduleTopicPartitionsStatistics should send a dataset changed event on topic deletion",
          "classname": "io.lenses.core.actors.KafkaTopicsActorSpec",
          "time": 10101,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.createTopic(KafkaTopicsActorSpec.scala:75)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec$$anon$5.<init>(KafkaTopicsActorSpec.scala:179)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.$anonfun$new$11(KafkaTopicsActorSpec.scala:175)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.withFixture(KafkaTopicsActorSpec.scala:75)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.runTest(KafkaTopicsActorSpec.scala:75)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.runTests(KafkaTopicsActorSpec.scala:75)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(KafkaTopicsActorSpec.scala:75)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.actors.KafkaTopicsActorSpec.run(KafkaTopicsActorSpec.scala:75)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 60366,
      "tests": 6,
      "failures": 6,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.TopicStatsWorkerTest",
      "timestamp": "2020-09-11T09:14:02",
      "failedTestcases": [
        {
          "name": "handle identify topic when there are no messages on the topic",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10259,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$1.$anonfun$run$2(TopicStatsWorkerTest.scala:62)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          }
        },
        {
          "name": "handle identify topic when there are no messages on the topic and there is no topic attributes",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10032,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$2.$anonfun$run$5(TopicStatsWorkerTest.scala:76)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          }
        },
        {
          "name": "handle identify topic when there are no messages on the topic and no end offsets available",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10010,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$3.$anonfun$run$8(TopicStatsWorkerTest.scala:91)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          }
        },
        {
          "name": "handle data on the partition with 1 record",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10014,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$4.$anonfun$run$11(TopicStatsWorkerTest.scala:119)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          }
        },
        {
          "name": "handle data on the partition with 1 record after data has been deleted up to the record",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10027,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$8.$anonfun$run$19(TopicStatsWorkerTest.scala:162)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          }
        },
        {
          "name": "handle data on the partition with 1 record after data has been deleted",
          "classname": "io.lenses.core.actors.TopicStatsWorkerTest",
          "time": 10024,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.createTopic(TopicStatsWorkerTest.scala:48)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.$anonfun$createDeleteTopic$1(TopicStatsWorkerTest.scala:263)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.util.Try$.apply(Try.scala:213)\n\tat io.lenses.core.actors.TopicStatsWorkerTest.io$lenses$core$actors$TopicStatsWorkerTest$$createDeleteTopic(TopicStatsWorkerTest.scala:263)\n\tat io.lenses.core.actors.TopicStatsWorkerTest$$anon$12.$anonfun$run$31(TopicStatsWorkerTest.scala:224)\n\tat cats.effect.Resource.$anonfun$fold$1(Resource.scala:118)\n\tat cats.effect.internals.IOBracket$BracketStart.liftedTree1$1(IOBracket.scala:83)\n\tat cats.effect.internals.IOBracket$BracketStart.run(IOBracket.scala:83)\n\tat cats.effect.internals.Trampoline.cats$effect$internals$Trampoline$$immediateLoop(Trampoline.scala:67)\n\tat cats.effect.internals.Trampoline.startLoop(Trampoline.scala:35)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.super$startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.$anonfun$startLoop$1(TrampolineEC.scala:89)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:85)\n\tat cats.effect.internals.TrampolineEC$JVMTrampoline.startLoop(TrampolineEC.scala:89)\n\tat cats.effect.internals.Trampoline.execute(Trampoline.scala:43)\n\tat cats.effect.internals.TrampolineEC.execute(TrampolineEC.scala:42)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:69)\n\tat cats.effect.internals.IOBracket$BracketStart.apply(IOBracket.scala:49)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IORunLoop$.cats$effect$internals$IORunLoop$$loop(IORunLoop.scala:139)\n\tat cats.effect.internals.IORunLoop$RestartCallback.signal(IORunLoop.scala:359)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:380)\n\tat cats.effect.internals.IORunLoop$RestartCallback.apply(IORunLoop.scala:323)\n\tat cats.effect.internals.IOShift$Tick.run(IOShift.scala:35)\n\tat java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)"
          }
        }
      ]
    },
    {
      "time": 10023,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.core.actors.ConnectStatusActorTest",
      "timestamp": "2020-09-11T09:14:03",
      "failedTestcases": [
        {
          "name": "should read task status",
          "classname": "io.lenses.core.actors.ConnectStatusActorTest",
          "time": 10023,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.core.actors.ConnectStatusActorTest.createTopic(ConnectStatusActorTest.scala:31)\n\tat io.lenses.core.actors.ConnectStatusActorTest.$anonfun$new$1(ConnectStatusActorTest.scala:55)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.core.actors.ConnectStatusActorTest.withFixture(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.core.actors.ConnectStatusActorTest.runTest(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.core.actors.ConnectStatusActorTest.runTests(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.core.actors.ConnectStatusActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.core.actors.ConnectStatusActorTest.org$scalatest$BeforeAndAfterAll$$super$run(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.core.actors.ConnectStatusActorTest.run(ConnectStatusActorTest.scala:31)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 13,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.ConsumersRoutesIntegrationTest",
      "timestamp": "2020-09-11T09:14:50",
      "failedTestcases": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.ConsumersRoutesIntegrationTest",
          "time": 13,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.ConsumersRoutesIntegrationTest.<init>(ConsumersRoutesIntegrationTest.scala:79)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 3,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.ConsumersRoutesBlackListTest",
      "timestamp": "2020-09-11T09:14:36",
      "failedTestcases": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.ConsumersRoutesBlackListTest",
          "time": 3,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.ConsumersRoutesBlackListTest.<init>(ConsumersRoutesBlackListTest.scala:67)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 5,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.JdbcRoutesJsonTest",
      "timestamp": "2020-09-11T09:14:40",
      "failedTestcases": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.JdbcRoutesJsonTest",
          "time": 5,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.JdbcRoutesJsonTest.<init>(JdbcRoutesJsonTest.scala:122)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 10012,
      "tests": 2,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.PrometheusRoutesTest",
      "timestamp": "2020-09-11T09:14:45",
      "failedTestcases": [
        {
          "name": "fetch prometheus /metrics with consumer lag",
          "classname": "io.lenses.http.routes.PrometheusRoutesTest",
          "time": 10007,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.http.routes.PrometheusRoutesTest.createTopic(PrometheusRoutesTest.scala:43)\n\tat io.lenses.http.routes.PrometheusRoutesTest.$anonfun$new$3(PrometheusRoutesTest.scala:108)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.PrometheusRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(PrometheusRoutesTest.scala:43)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.PrometheusRoutesTest.run(PrometheusRoutesTest.scala:43)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 0,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.QuotasRoutesTest",
      "timestamp": "2020-09-11T09:14:24",
      "failedTestcases": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.QuotasRoutesTest",
          "time": 0,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.QuotasRoutesTest.<init>(QuotaRoutesTest.scala:40)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 0,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.TopicMetadataRoutesTest",
      "timestamp": "2020-09-11T09:14:56",
      "failedTestcases": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.TopicMetadataRoutesTest",
          "time": 0,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicMetadataRoutesTest.<init>(TopicMetadataRoutesTest.scala:86)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 157289,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.SchemaRegistryProxyTest",
      "timestamp": "2020-09-11T09:14:47",
      "failedTestcases": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.SchemaRegistryProxyTest",
          "time": 157289,
          "failure": {
            "message": "java.lang.InterruptedException",
            "type": "org.apache.kafka.common.errors.InterruptException",
            "stackTrace": "org.apache.kafka.common.errors.InterruptException: java.lang.InterruptedException\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:937)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:856)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:743)\n\tat io.lenses.http.routes.SchemaRegistryProxyTest.$anonfun$createTopic$2(SchemaRegistryProxyTest.scala:110)\n\tat scala.collection.TraversableLike.$anonfun$map$1(TraversableLike.scala:238)\n\tat scala.collection.Iterator.foreach(Iterator.scala:941)\n\tat scala.collection.Iterator.foreach$(Iterator.scala:941)\n\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1429)\n\tat scala.collection.IterableLike.foreach(IterableLike.scala:74)\n\tat scala.collection.IterableLike.foreach$(IterableLike.scala:73)\n\tat scala.collection.AbstractIterable.foreach(Iterable.scala:56)\n\tat scala.collection.TraversableLike.map(TraversableLike.scala:238)\n\tat scala.collection.TraversableLike.map$(TraversableLike.scala:231)\n\tat scala.collection.AbstractTraversable.map(Traversable.scala:108)\n\tat io.lenses.http.routes.SchemaRegistryProxyTest.createTopic(SchemaRegistryProxyTest.scala:108)\n\tat io.lenses.http.routes.SchemaRegistryProxyTest.beforeAll(SchemaRegistryProxyTest.scala:96)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:212)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.SchemaRegistryProxyTest.run(SchemaRegistryProxyTest.scala:30)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.InterruptedException\n\tat java.lang.Object.wait(Native Method)\n\tat org.apache.kafka.common.utils.SystemTime.waitObject(SystemTime.java:60)\n\tat org.apache.kafka.clients.producer.internals.ProducerMetadata.awaitUpdate(ProducerMetadata.java:97)\n\tat org.apache.kafka.clients.producer.KafkaProducer.waitOnMetadata(KafkaProducer.java:999)\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:876)\n\t... 43 more"
          }
        }
      ]
    },
    {
      "time": 115198,
      "tests": 31,
      "failures": 31,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.http.routes.TopicRoutesTest",
      "timestamp": "2020-09-11T09:14:29",
      "failedTestcases": [
        {
          "name": "even when a 401 - due to a authentication token failure, the CORS headers should be in the response",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3713,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$1.<init>(TopicRoutesTest.scala:115)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$1(TopicRoutesTest.scala:115)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "not allow creating a topic for an user who has only read access",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3707,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$2.<init>(TopicRoutesTest.scala:129)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$4(TopicRoutesTest.scala:129)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return topics information based on namespace authorities",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3707,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$3.<init>(TopicRoutesTest.scala:140)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$7(TopicRoutesTest.scala:140)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return paginated short topics information based on namesapce authorities",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3710,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$4.<init>(TopicRoutesTest.scala:177)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$9(TopicRoutesTest.scala:177)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "allow for paginated filtering of the short topics information",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3720,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$5.<init>(TopicRoutesTest.scala:216)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$11(TopicRoutesTest.scala:216)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "include system topics only if includeSystemTopics is set to true",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3717,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$6.<init>(TopicRoutesTest.scala:231)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$13(TopicRoutesTest.scala:231)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "sort results by fields",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3732,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$7.<init>(TopicRoutesTest.scala:291)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$22(TopicRoutesTest.scala:291)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return topics short summary containing allowed actions",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$13.<init>(TopicRoutesTest.scala:318)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$69(TopicRoutesTest.scala:318)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "not allow creating a topic for an user without a Namespace Permission to allow it",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3709,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$14.<init>(TopicRoutesTest.scala:334)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$71(TopicRoutesTest.scala:334)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "not allow deleting a topic if Delete topic Permission is not present",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3708,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$15.<init>(TopicRoutesTest.scala:351)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$74(TopicRoutesTest.scala:351)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "not allow setting a topic configuration if there is no ConfigureTopic Permission present",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3712,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$16.<init>(TopicRoutesTest.scala:375)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$78(TopicRoutesTest.scala:375)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "allow creating a topic for an user with CreateTopic Permission",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$17.<init>(TopicRoutesTest.scala:407)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$83(TopicRoutesTest.scala:407)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "not allow creating a topic for an user without CreateTopic Permission",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3717,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$18.<init>(TopicRoutesTest.scala:424)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$86(TopicRoutesTest.scala:424)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "fail on setting a wrong topic configuration KEY",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3730,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$19.<init>(TopicRoutesTest.scala:441)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$89(TopicRoutesTest.scala:441)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "fail on setting a wrong topic configuration VALUE",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3717,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$20.<init>(TopicRoutesTest.scala:468)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$93(TopicRoutesTest.scala:468)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "get all possible topic configuration options",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3717,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$21.<init>(TopicRoutesTest.scala:483)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$96(TopicRoutesTest.scala:483)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "should get a list of available configs for a topic",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$22.<init>(TopicRoutesTest.scala:511)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$101(TopicRoutesTest.scala:511)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "not allow adding partitions for a user without ConfigureTopic Permission",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$23.<init>(TopicRoutesTest.scala:542)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$106(TopicRoutesTest.scala:542)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return 404 if topic not found on attempt to add partition",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$24.<init>(TopicRoutesTest.scala:561)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$109(TopicRoutesTest.scala:561)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return 400 on attempt to add partition if number of topics is not greater than the existing number",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3717,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$25.<init>(TopicRoutesTest.scala:580)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$112(TopicRoutesTest.scala:580)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return 200 on successfully adding partitions",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$26.<init>(TopicRoutesTest.scala:615)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$116(TopicRoutesTest.scala:615)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "/api/topics/<topic>",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3719,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$27.<init>(TopicRoutesTest.scala:655)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$120(TopicRoutesTest.scala:655)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "v2 partitions endpoint expected payload response",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$28.<init>(TopicRoutesTest.scala:703)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$124(TopicRoutesTest.scala:703)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "v2 partitions endpoint with no JMX reponse return null bytes",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3719,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$29.<init>(TopicRoutesTest.scala:790)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$129(TopicRoutesTest.scala:790)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return effective begin partition for compacted topics",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$30.<init>(TopicRoutesTest.scala:849)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$133(TopicRoutesTest.scala:849)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return 400 on being unable to delete topic messages due to enabled compacting",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3714,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$31.<init>(TopicRoutesTest.scala:901)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$137(TopicRoutesTest.scala:901)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return 400 when offset out of bounds",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3712,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$32.<init>(TopicRoutesTest.scala:931)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$141(TopicRoutesTest.scala:931)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return 400 when topic or partition not found",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$33.<init>(TopicRoutesTest.scala:942)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$143(TopicRoutesTest.scala:942)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return 500 when something mysterious goes wrong",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3713,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$34.<init>(TopicRoutesTest.scala:953)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$145(TopicRoutesTest.scala:953)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return 200 when all is correct",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3712,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$35.<init>(TopicRoutesTest.scala:964)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$147(TopicRoutesTest.scala:964)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return 403 for user without InsertDataAction Permission on that topic",
          "classname": "io.lenses.http.routes.TopicRoutesTest",
          "time": 3716,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicRoutesTest$TestContext.$init$(TopicRoutesTest.scala:993)\n\tat io.lenses.http.routes.TopicRoutesTest$$anon$36.<init>(TopicRoutesTest.scala:975)\n\tat io.lenses.http.routes.TopicRoutesTest.$anonfun$new$149(TopicRoutesTest.scala:975)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.http.routes.TopicRoutesTest.org$scalatest$BeforeAndAfterAll$$super$run(TopicRoutesTest.scala:104)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.http.routes.TopicRoutesTest.run(TopicRoutesTest.scala:104)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 1,
      "tests": 1,
      "failures": 0,
      "errors": 1,
      "skipped": 0,
      "name": "io.lenses.http.routes.TopicMetadataRoutesNoSRTest",
      "timestamp": "2020-09-11T09:14:43",
      "failedTestcases": [
        {
          "name": "(It is not a test it is a sbt.testing.SuiteSelector)",
          "classname": "io.lenses.http.routes.TopicMetadataRoutesNoSRTest",
          "time": 1,
          "failure": {
            "message": "Timed out waiting for connection while in state: CONNECTING",
            "type": "kafka.zookeeper.ZooKeeperClientTimeoutException",
            "stackTrace": "kafka.zookeeper.ZooKeeperClientTimeoutException: Timed out waiting for connection while in state: CONNECTING\n\tat kafka.zookeeper.ZooKeeperClient.$anonfun$waitUntilConnected$3(ZooKeeperClient.scala:258)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:253)\n\tat kafka.zookeeper.ZooKeeperClient.waitUntilConnected(ZooKeeperClient.scala:254)\n\tat kafka.zookeeper.ZooKeeperClient.<init>(ZooKeeperClient.scala:112)\n\tat kafka.zk.KafkaZkClient$.apply(KafkaZkClient.scala:1826)\n\tat io.lenses.core.kafka.KafkaZookeeperClientBuilder$.apply(KafkaZookeeperClientBuilder.scala:16)\n\tat io.lenses.http.routes.TopicMetadataRoutesNoSRTest.<init>(TopicMetadataRoutesNoSRTest.scala:58)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:450)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 975,
      "tests": 8,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.security.pac4j.InMemorySessionStoreTest",
      "timestamp": "2020-09-11T09:12:52",
      "failedTestcases": [
        {
          "name": "Store should allow renewing sessions",
          "classname": "io.lenses.security.pac4j.InMemorySessionStoreTest",
          "time": 719,
          "failure": {
            "message": "false was not true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$ShouldMethodHelperClass.shouldMatcher(Matchers.scala:6783)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.should(Matchers.scala:6822)\n\tat io.lenses.security.pac4j.InMemorySessionStoreTest$$anon$6.<init>(InMemorySessionStoreTest.scala:84)\n\tat io.lenses.security.pac4j.InMemorySessionStoreTest.$anonfun$new$9(InMemorySessionStoreTest.scala:71)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat org.scalatest.wordspec.AnyWordSpec.run(AnyWordSpec.scala:1879)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 62,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.schemaregistry.jmx.SchemaRegistryMetricsJMXReaderTest",
      "timestamp": "2020-09-11T09:13:23",
      "failedTestcases": [
        {
          "name": "returns the metrics",
          "classname": "io.lenses.services.metrics.schemaregistry.jmx.SchemaRegistryMetricsJMXReaderTest",
          "time": 62,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.schemaregistry.jmx.SchemaRegistryMetricsJMXReaderTest.$anonfun$new$1(SchemaRegistryMetricsJMXReaderTest.scala:15)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 427,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.zookeeper.jmx.ZookeeperJMXReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "failedTestcases": [
        {
          "name": "return the zookeeper metrics",
          "classname": "io.lenses.services.metrics.zookeeper.jmx.ZookeeperJMXReaderTest",
          "time": 427,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.zookeeper.jmx.ZookeeperJMXReaderTest.$anonfun$new$1(ZookeeperJMXReaderTest.scala:16)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 1300,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.zookeeper.jolokia.ZookeeperHttpReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "failedTestcases": [
        {
          "name": "return the zookeeper metrics",
          "classname": "io.lenses.services.metrics.zookeeper.jolokia.ZookeeperHttpReaderTest",
          "time": 1300,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.zookeeper.jolokia.ZookeeperHttpReaderTest.$anonfun$new$1(ZookeeperHttpReaderTest.scala:20)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 427,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.kafka.jmx.ConnectMetricsJMXReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "failedTestcases": [
        {
          "name": "return metrics",
          "classname": "io.lenses.services.metrics.kafka.jmx.ConnectMetricsJMXReaderTest",
          "time": 427,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.kafka.jmx.ConnectMetricsJMXReaderTest.$anonfun$new$1(ConnectMetricsJMXReaderTest.scala:17)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 450,
      "tests": 2,
      "failures": 2,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.kafka.jmx.BrokerMetricsJMXReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "failedTestcases": [
        {
          "name": "returns the kafka version",
          "classname": "io.lenses.services.metrics.kafka.jmx.BrokerMetricsJMXReaderTest",
          "time": 421,
          "failure": {
            "message": "None was not equal to Some(\"2.3.0-L0\")",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: None was not equal to Some(\"2.3.0-L0\")\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.kafka.jmx.BrokerMetricsJMXReaderTest.$anonfun$new$1(BrokerMetricsJMXReaderTest.scala:14)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return the broker metrics",
          "classname": "io.lenses.services.metrics.kafka.jmx.BrokerMetricsJMXReaderTest",
          "time": 29,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.kafka.jmx.BrokerMetricsJMXReaderTest.$anonfun$new$2(BrokerMetricsJMXReaderTest.scala:20)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 1284,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.schemaregistry.jolokia.SchemaRegistryJolokiaMetricsReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "failedTestcases": [
        {
          "name": "returns the metrics",
          "classname": "io.lenses.services.metrics.schemaregistry.jolokia.SchemaRegistryJolokiaMetricsReaderTest",
          "time": 1284,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.schemaregistry.jolokia.SchemaRegistryJolokiaMetricsReaderTest.$anonfun$new$1(SchemaRegistryJolokiaMetricsReaderTest.scala:18)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 1306,
      "tests": 3,
      "failures": 3,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest",
      "timestamp": "2020-09-11T09:13:22",
      "failedTestcases": [
        {
          "name": "returns the kafka version",
          "classname": "io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest",
          "time": 1284,
          "failure": {
            "message": "None was not equal to Some(\"2.3.0-L0\")",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: None was not equal to Some(\"2.3.0-L0\")\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest.$anonfun$new$1(BrokerJolokiaMetricsReaderTest.scala:18)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "return the kafka broker id",
          "classname": "io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest",
          "time": 3,
          "failure": {
            "message": "Connect to localhost:10089 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused (Connection refused)",
            "type": "org.apache.http.conn.HttpHostConnectException",
            "stackTrace": "org.apache.http.conn.HttpHostConnectException: Connect to localhost:10089 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused (Connection refused)\n\tat org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:159)\n\tat org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:373)\n\tat org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:394)\n\tat org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:237)\n\tat org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:185)\n\tat org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)\n\tat org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)\n\tat org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:108)\n\tat io.lenses.services.metrics.http.JolokiaMetrics.get(JolokiaMetrics.scala:49)\n\tat io.lenses.services.metrics.http.JolokiaMetrics.execute(JolokiaMetrics.scala:137)\n\tat io.lenses.services.metrics.http.JolokiaMetrics.execute$(JolokiaMetrics.scala:135)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest.execute(BrokerJolokiaMetricsReaderTest.scala:13)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerMetricsHttpReaderHelper.getBrokerID(BrokerMetricsHttpReader.scala:159)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerMetricsHttpReaderHelper.getBrokerID$(BrokerMetricsHttpReader.scala:158)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest.getBrokerID(BrokerJolokiaMetricsReaderTest.scala:13)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest.$anonfun$new$2(BrokerJolokiaMetricsReaderTest.scala:22)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.net.ConnectException: Connection refused (Connection refused)\n\tat java.net.PlainSocketImpl.socketConnect(Native Method)\n\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n\tat java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\n\tat java.net.Socket.connect(Socket.java:607)\n\tat org.apache.http.conn.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:75)\n\tat org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:142)\n\t... 73 more"
          }
        },
        {
          "name": "return the broker metrics",
          "classname": "io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest",
          "time": 19,
          "failure": {
            "message": "false was not equal to true",
            "type": "org.scalatest.exceptions.TestFailedException",
            "stackTrace": "org.scalatest.exceptions.TestFailedException: false was not equal to true\n\tat org.scalatest.matchers.MatchersHelper$.indicateFailure(MatchersHelper.scala:339)\n\tat org.scalatest.matchers.should.Matchers$AnyShouldWrapper.shouldBe(Matchers.scala:6982)\n\tat io.lenses.services.metrics.kafka.jolokia.BrokerJolokiaMetricsReaderTest.$anonfun$new$3(BrokerJolokiaMetricsReaderTest.scala:28)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:189)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.funsuite.AnyFunSuite.withFixture(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:187)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:199)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:181)\n\tat org.scalatest.funsuite.AnyFunSuite.runTest(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTests$1(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests(AnyFunSuiteLike.scala:232)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.runTests$(AnyFunSuiteLike.scala:231)\n\tat org.scalatest.funsuite.AnyFunSuite.runTests(AnyFunSuite.scala:1562)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1562)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:236)\n\tat org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:235)\n\tat org.scalatest.funsuite.AnyFunSuite.run(AnyFunSuite.scala:1562)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 219481,
      "tests": 2,
      "failures": 2,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyMetricsTaskTest",
      "timestamp": "2020-09-11T09:13:43",
      "failedTestcases": [
        {
          "name": "TopologyMetricsTask should detect metrics from the kafka metrics topic",
          "classname": "io.lenses.topology.TopologyMetricsTaskTest",
          "time": 61796,
          "failure": {
            "message": "org.apache.kafka.common.errors.TimeoutException: Topic top_metric_2630fab5-a75c-4388-bf72-0c29a03d2b65 not present in metadata after 60000 ms.",
            "type": "java.util.concurrent.ExecutionException",
            "stackTrace": "java.util.concurrent.ExecutionException: org.apache.kafka.common.errors.TimeoutException: Topic top_metric_2630fab5-a75c-4388-bf72-0c29a03d2b65 not present in metadata after 60000 ms.\n\tat org.apache.kafka.clients.producer.KafkaProducer$FutureFailure.<init>(KafkaProducer.java:1269)\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:933)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:856)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:743)\n\tat io.lenses.topology.TopologyMetricsTaskTest.$anonfun$new$2(TopologyMetricsTaskTest.scala:61)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat org.scalatest.wordspec.AnyWordSpec.run(AnyWordSpec.scala:1879)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: org.apache.kafka.common.errors.TimeoutException: Topic top_metric_2630fab5-a75c-4388-bf72-0c29a03d2b65 not present in metadata after 60000 ms."
          }
        },
        {
          "name": "TopologyMetricsTask should combine metrics for the same app",
          "classname": "io.lenses.topology.TopologyMetricsTaskTest",
          "time": 157684,
          "failure": {
            "message": "assertion failed: timeout (37500 milliseconds) during expectMsgClass waiting for class io.lenses.domain.topology.TopologySqlStreamMetricsUpdate",
            "type": "java.lang.AssertionError",
            "stackTrace": "java.lang.AssertionError: assertion failed: timeout (37500 milliseconds) during expectMsgClass waiting for class io.lenses.domain.topology.TopologySqlStreamMetricsUpdate\n\tat scala.Predef$.assert(Predef.scala:223)\n\tat akka.testkit.TestKitBase.expectMsgClass_internal(TestKit.scala:529)\n\tat akka.testkit.TestKitBase.expectMsgType(TestKit.scala:511)\n\tat akka.testkit.TestKitBase.expectMsgType$(TestKit.scala:510)\n\tat akka.testkit.TestKit.expectMsgType(TestKit.scala:929)\n\tat io.lenses.topology.TopologyMetricsTaskTest.$anonfun$new$3(TopologyMetricsTaskTest.scala:97)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat org.scalatest.wordspec.AnyWordSpec.run(AnyWordSpec.scala:1879)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 90779,
      "tests": 10,
      "failures": 9,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyActorTest",
      "timestamp": "2020-09-11T09:13:43",
      "failedTestcases": [
        {
          "name": "TopologyActor should return global topology",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10439,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$2(TopologyActorTest.scala:113)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "TopologyActor should render only topics that are referenced",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10017,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$21(TopologyActorTest.scala:300)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "TopologyActor should correctly get topology of a Mongo sink once it has been updated",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10012,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$26(TopologyActorTest.scala:400)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "TopologyActor should correctly get topology of a File Sink sink once it has been updated",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10007,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$34(TopologyActorTest.scala:467)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$34$adapted(TopologyActorTest.scala:467)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$33(TopologyActorTest.scala:467)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "TopologyActor should do not duplicate topic nodes",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10005,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$43(TopologyActorTest.scala:633)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "TopologyActor should forward events to permission actor so that they eventually reach the output actor",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10008,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$46(TopologyActorTest.scala:729)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "TopologyActor should handles closed loop processor INSERT INTO B SELECT STREAM * FROM A; INSERT INTO A SELECT STREAM * FROM B",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10003,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$47(TopologyActorTest.scala:785)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "TopologyActor should handles closed loop processor INSERT INTO B SELECT STREAM * FROM A; INSERT INTO A SELECT STREAM * FROM B;INSERT INTO A SELECT STREAM * FROM A",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10005,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$57(TopologyActorTest.scala:863)\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        },
        {
          "name": "handles updates of the number of runners",
          "classname": "io.lenses.topology.TopologyActorTest",
          "time": 10005,
          "failure": {
            "message": null,
            "type": "java.util.concurrent.TimeoutException",
            "stackTrace": "java.util.concurrent.TimeoutException\n\tat org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:108)\n\tat org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:272)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic(Cluster.scala:44)\n\tat io.lenses.test.kafka.cluster.Cluster.createTopic$(Cluster.scala:42)\n\tat io.lenses.topology.TopologyActorTest.createTopic(TopologyActorTest.scala:67)\n\tat io.lenses.topology.TopologyActorTest.$anonfun$new$69(TopologyActorTest.scala:962)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat io.lenses.topology.TopologyActorTest.withFixture(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat io.lenses.topology.TopologyActorTest.runTest(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat io.lenses.topology.TopologyActorTest.runTests(TopologyActorTest.scala:67)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$wordspec$AnyWordSpecLike$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyActorTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyActorTest.scala:67)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyActorTest.run(TopologyActorTest.scala:67)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)"
          }
        }
      ]
    },
    {
      "time": 61795,
      "tests": 1,
      "failures": 1,
      "errors": 0,
      "skipped": 0,
      "name": "io.lenses.topology.TopologyTaskTest",
      "timestamp": "2020-09-11T09:13:43",
      "failedTestcases": [
        {
          "name": "TopologyTask should read topology from a kafka topic",
          "classname": "io.lenses.topology.TopologyTaskTest",
          "time": 61795,
          "failure": {
            "message": "org.apache.kafka.common.errors.TimeoutException: Topic top1_1599812024173 not present in metadata after 60000 ms.",
            "type": "java.util.concurrent.ExecutionException",
            "stackTrace": "java.util.concurrent.ExecutionException: org.apache.kafka.common.errors.TimeoutException: Topic top1_1599812024173 not present in metadata after 60000 ms.\n\tat org.apache.kafka.clients.producer.KafkaProducer$FutureFailure.<init>(KafkaProducer.java:1269)\n\tat org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:933)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:856)\n\tat org.apache.kafka.clients.producer.KafkaProducer.send(KafkaProducer.java:743)\n\tat io.lenses.topology.TopologyTaskTest.$anonfun$new$2(TopologyTaskTest.scala:62)\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\n\tat org.scalatest.wordspec.AnyWordSpecLike$$anon$3.apply(AnyWordSpecLike.scala:1076)\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\n\tat org.scalatest.wordspec.AnyWordSpec.withFixture(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.invokeWithFixture$1(AnyWordSpecLike.scala:1074)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTest$1(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest(AnyWordSpecLike.scala:1086)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTest$(AnyWordSpecLike.scala:1068)\n\tat org.scalatest.wordspec.AnyWordSpec.runTest(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$runTests$1(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:413)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:390)\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:427)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:401)\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:396)\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:475)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests(AnyWordSpecLike.scala:1145)\n\tat org.scalatest.wordspec.AnyWordSpecLike.runTests$(AnyWordSpecLike.scala:1144)\n\tat org.scalatest.wordspec.AnyWordSpec.runTests(AnyWordSpec.scala:1879)\n\tat org.scalatest.Suite.run(Suite.scala:1112)\n\tat org.scalatest.Suite.run$(Suite.scala:1094)\n\tat org.scalatest.wordspec.AnyWordSpec.org$scalatest$wordspec$AnyWordSpecLike$$super$run(AnyWordSpec.scala:1879)\n\tat org.scalatest.wordspec.AnyWordSpecLike.$anonfun$run$1(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:535)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run(AnyWordSpecLike.scala:1190)\n\tat org.scalatest.wordspec.AnyWordSpecLike.run$(AnyWordSpecLike.scala:1188)\n\tat io.lenses.topology.TopologyTaskTest.org$scalatest$BeforeAndAfterAll$$super$run(TopologyTaskTest.scala:23)\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\n\tat io.lenses.topology.TopologyTaskTest.run(TopologyTaskTest.scala:23)\n\tat org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:318)\n\tat org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:513)\n\tat sbt.TestRunner.runTest$1(TestFramework.scala:139)\n\tat sbt.TestRunner.run(TestFramework.scala:154)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.$anonfun$apply$1(TestFramework.scala:317)\n\tat sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:277)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFramework$$anon$3$$anonfun$$lessinit$greater$1.apply(TestFramework.scala:317)\n\tat sbt.TestFunction.apply(TestFramework.scala:329)\n\tat sbt.Tests$.$anonfun$toTask$1(Tests.scala:311)\n\tat sbt.std.Transform$$anon$3.$anonfun$apply$2(Transform.scala:46)\n\tat sbt.std.Transform$$anon$4.work(Transform.scala:67)\n\tat sbt.Execute.$anonfun$submit$2(Execute.scala:281)\n\tat sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:19)\n\tat sbt.Execute.work(Execute.scala:290)\n\tat sbt.Execute.$anonfun$submit$1(Execute.scala:281)\n\tat sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:178)\n\tat sbt.CompletionService$$anon$2.call(CompletionService.scala:37)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: org.apache.kafka.common.errors.TimeoutException: Topic top1_1599812024173 not present in metadata after 60000 ms."
          }
        }
      ]
    }
  ],
  "summary": {
    "time": 2872234,
    "tests": 2290,
    "failures": 83,
    "errors": 7,
    "skipped": 87
  },
  "githubEvent": null
}